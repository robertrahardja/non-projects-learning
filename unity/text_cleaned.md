Hello and welcome to the course.
I'm really excited to have you here and hopefully you're excited to be here.
In this course, we're going to cover a lot and you're going to learn a lot about game development.
We're going to start with the fundamentals of programming and Unity, learning our way around the Unity editor and how to read and write code, and then we're going to get into some really advanced topics.
We're going to be using professional workflows and the things that you would use in an actual game development job.
We'll set up source control.
We'll set up build automation and we'll do some refactoring, learning, debugging, optimizing, profiling, and a whole lot more.
Don't worry though, I'm going to make sure that it's completely approachable and that you can understand it and won't get lost.
So, I hope you're excited.
It should be a lot of fun.
We're going to build some games, have some fun sharing them with friends and seeing what kind of cool stuff you can come up with while you're learning this whole process.
All right, let's get started.
Before we start building, I want to have a quick discussion about game engines.
Because in this course, we're going to be using a specific game engine.
I want to briefly explain why we're using that game engine and what the alternatives are and just give a little terminology so everybody understands where we're starting from the beginning.
So, the game engine that we are going to use for this course is Unity or sometimes called Unity 3D.
The actual name of the engine though is Unity.
Their web page is unity3d.com.
There are a couple of game engine options out there though.
Unreal is one of the most popular ones.
I'm sure you've heard of it.
Fortnite's built on that along with a lot of AAA games and Unity is the other big one or the other big player in the game engine space.
There are some other ones that used to be big.
They've all kind of shrunk off and then there are lots of little company or not little companies but lots of big companies that have their own custom engines.
But for the most part, the two leading engines in the industry are Unreal and Unity.
While there are a couple big differences between the two engines, you really can do just about anything with either of the engines.
Unity is generally seen as more of an indie friendly and mobile friendly engine that's kind of approachable by a single person or a smaller team.
And Unreal has, at least historically, been something that was more used in AAA games.
So, you'll find that a lot of AAA developers already have a lot of Unreal experience.
It's what I used to use before I used Unity.
And because of that, they're bringing that in there.
They also have some really cool features in Unreal, like the new Lumen and Nanite systems.
Unity also has lots of cool new features, though, and lots of stuff that's constantly coming.
In fact, one of the things that made Unity so big was that they were the first ones to the mobile market by, I think, over a year.
So, if you wanted to build out for an iPhone, Unity was the way to go.
And you'll find that's the case for most new platforms.
Unity tends to be ahead on that stuff.
And Unreal tends to be slightly ahead on rendering quality for AAA level graphics.
So, that's kind of the loose difference.
You can really use either, but for this course, we're very specifically going to use Unity, and we're going to use a specific version of Unity.
So, I want to talk a little bit about different Unity versions.
Unity is released in three or four different branches.
First off, there's an alpha branch of Unity.
This is where you'll see all of the latest and greatest newest features.
I'll talk about how you can get that and see that later, but just understand that it's not really that um reliable.
It's something that you should expect to crash.
You should expect to be somewhat unstable because it's testing out the new features.
They haven't been fully vetted.
They haven't found all of the bugs and fixed them.
The beta build or the beta branch you'll find is quite a bit better.
It's a lot more stable.
You'll find that a lot of the new features are there.
They get there quickly after they go out of alpha.
They'll go into beta and they're usually mostly stable there.
But it still does crash.
It's not super stable and you probably don't want to do your final builds off of that either.
There are two other versions though.
There's the LTS and the techream.
The LTS, which is the long-term support version, is the Unity version that's going to be supported for at least, I believe it's two or three years.
You can look on their page and see the exact details for each LTS.
But the one that I have up here is the Unity 2021 LTS, and you can see that they're going to support that all the way through 2023 and beyond.
And the Unity 2020 LTS version will start to reach its end of life cycle around 2023.
What does this all mean? not a whole lot for you except for if you're going to build a final version of a game, like you're getting ready to release your game, you want to use one of these LTS versions.
Usually, it just means that this version of Unity is going to continue to be supported.
If they find some weird bug like, oh, um, a Chrome update makes it so that this game now crashes, WebGL builds on this Unity version, they'll go back and fix that.
they'll find, you know, fixed things that they found in that issue or in Unity in that version in that LTS.
The Techstream, which is what we'll be using, is a little bit newer.
The Techstream is the latest version that's considered stable, but it's not like a locked down version that's going to have support.
It's going to have some new things.
It's not going to be completely stable.
It's not the 100% stable, but I consider it 99 98% stable.
So, that's what we're going to be using.
Again, it's called the text stream version, but you can always use an LTS.
And eventually, this text stream that we're using will be turned into an LTS.
Now, for your Unity version, I recommend that you either use the one that we're using or a newer LTS or newer um textream version.
Don't use an alpha, don't use a beta.
Just make sure you go with a Techstream or an LTS version.
And to get specific, in the next section, we'll actually go through the installation process.
You'll see the exact version that we're using.
So, just make sure you're using at least that version or newer.
In this lesson, we're going to cover installation of Unity.
If you already have Unity installed and you already have the latest tech stream, then you're probably good to go.
But I would recommend that you watch this through maybe on 2x speed.
So, the first thing that you're going to want to do if you don't have Unity installed is go to the unity.com page and then look for their download link.
I have it at unity.com/d download right here.
And you can see there's a button to download for Windows or download for other versions.
If I scroll down here, this is what that download for other versions option looks like.
There's a Windows one, a Mac one, and Linux.
We're going to completely ignore Linux, but if you're on Windows or Mac, just click on whichever one is your current operating system.
Hit the download button.
It should download your installer.
And once it's finished, just hit the open button or download and open your installer, however you do it on your system.
Once the installer starts, you'll see the license agreement.
Just hit agree.
Choose an installation folder.
I'll use the default.
This is for the hub, not for the actual Unity installs.
So, it's going to be a relatively small download.
I wouldn't worry too much about where you're putting it.
Probably just leave it in the default location.
If you want to worry about where you're installing the bigger versions of the editor, which is what we're going to be getting into, or the full actual editor versions, you can do that when we go to the editor installation part.
So, now that the hub has finished the installation, we'll just hit the finish button and allow it to run the hub.
I'll allow firewall access.
And then the hub should look like this.
If you don't already have a Unity account, you're going to need to create one.
If you have one, you're good to go.
just sign in with it.
Let's go through the creation process real quick.
I need to give it my email address, a password, which has some pretty strict requirements, a username, my name, and then agree to the terms of service, and prove that I'm not a robot by clicking on some it looks like bicycles.
There we go.
That's not a bicycle.
And fire hydrants.
Guess that's kind of a fire hydrant in there.
All right.
Now I'll create my Unity ID which is going to be just this Jason Wyman 2023.
And I should get an email that I'll go confirm.
Yep, I got it right here.
Let's hit confirm and then continue.
Oh, I've got to prove I'm not a robot on the phone first.
Now we continue and I have my account.
It didn't automatically sign me in though, so I'm going to need to go over back to Unity and sign in.
So, minimize this tab, hit the sign in button, and then allow it to use the authentication through the web browser, and there we go.
Look at that.
I didn't even have to put in my password.
Now, it's going to ask me where I'd like to install Unity and allow me to select a version of Unity to install.
Right now, by default, it wants to install 2021.3.16F1.
This is the LTS.
This is not the version of Unity that I want to use, though.
So, we're going to change this.
We're actually going to hit skip installation.
Hit agree and use the personal license.
And then we'll choose I don't want to switch to light mode.
So, hit maybe later on that.
And then on the installs section here, if you don't see this section right here, just go to installs if you're on projects or learn or somewhere else.
Go to installs.
Choose the install editor option.
We're going to find an official release that's not the LTS because I want to use 2022.2.
If there's a 2022.3, which I don't think there's going to be, or if 2023 something is here, then go ahead and use that.
But I want to use something slightly newer than 2021.
because there are just some new updates coming.
It's going to be an LTS for 2022 very soon.
And I feel like there's a couple cool features in the newer version that you should be aware of and be using.
So, let's install 2022.2 and hit uh install.
Then we get this popup here.
Now, here we have a couple of options that we can choose.
We can use the default code editor, which I'm going to leave installed by right now, but we're going to talk about code editors later and talk about installing another code editor later.
We also can choose if we want Android support, iOS support, support for Linux, Mac, or Windows.
What I do want is WebGL support.
So, choose whatever ones you want.
Don't overchoose and select a whole bunch.
If you're thinking, "Yes, I definitely want to build out to my Android device," you can choose the Mac or the the Android option.
You can always go back and reinstall or read these later, though.
So, don't feel like you have to, but if you're looking at options, just make sure that you get this WebGL build support because we are going to do WebGL build so that you can set up an automated build that's going to deploy this out and allow you to just play every time you do a commit.
It's going to be very cool.
You want to make sure that you have that.
So, I'll choose WebGL and leave the default code editor.
Hit continue.
Agree with the terms of service and hit install.
Then we'll let this install.
It's going to take a little while.
So, I'll be back when it finishes.
Once the install finishes, it should look like this.
You should see 2022.
Whichever version you've installed along with the platforms that you've installed support for.
If you don't see it, maybe you're in the pre-releases or official releases section.
You should be in official releases.
It really shouldn't show up in pre-releases.
That's where your alpha and betas are, but you should see everything in all.
This can end up having a lot of installs of Unity.
I generally recommend keeping maybe up to two or three of them around.
They get relatively big, so as new Unity versions come out.
I try to keep an LTS version around and a Techream or two Techstream versions around and occasionally I'll have an alpha or beta.
th those versions I want to make sure to clean up and just delete later because they do take up quite a bit of space.
Now we're done with the install though and it's time to create a project.
It's time to create a new project.
To do that, we'll go to the projects tab.
I'll click on projects and then we'll hit new project.
This should give us a popup of a couple different options of different project types that we can create.
There's also a drop down up at the top that's important to remember.
So, when you install new Unity versions, it'll let you select which Unity version to create your new project for.
By default, it's just going to be on the one that we've installed.
If you have multiple installed, though, just make sure that you've selected the correct editor version here and don't have an old one there.
Now, we have quite a few template options.
There's a 2D core, a 3D core, a 2D URP core, a 3D mobile core, 2D mobile core.
There's all of these different options down here.
They all kind of do slightly different things.
I'll talk really briefly about what those are and then we'll make our selection.
The 2D core option allows us to create a 2D platformer using Unity's older built-in render pipeline.
This is something that well was the only way to create 2D games in Unity up until relatively recently.
I would say it's now near being deprecated and probably not something that you should choose.
In fact, I don't think it should really be the top option here.
3D core is kind of the same way.
This is for creating a 3D game using the built-in render pipeline, which is the old non-customizable render pipeline.
Now, these are the two old ones.
The new ones are the 2D URP core, which is a 2D project using the universal render pipeline, which is a rendering system built for, well, rendering on just about every device.
That's why it's called universal mobile devices, uh, consoles, PC, web, just about everywhere.
It doesn't have the maximum like highest end graphics, but it has very, very good graphics, just not the super photorealistic stuff.
For that, you would go down to something like 3D HDRP.
In fact, there isn't even a 2D HDRP option because it's two-dimensional game.
2D games don't really have that realistic lifelike stuff.
3D HDRP is for a 3D realistic game or 3D URP for a 3D game that is well something that you're building without a giant art team that's giving you these great realistic 3D models.
So, your general options are usually going to be 3D URP or 2D URP.
Those are the two that I recommend for most projects that you're going to end up building.
For this project, though, we're going to choose 2D URP.
So, make sure that you've selected 2D URP.
And then scroll down and give your project a name.
I'm going to name mine Alien Blasters.
And then we'll give it a location.
So, choose where you want to save your project off to.
I generally like to have a folder right off of the root of my drive where I store all of my projects.
So, let's go create one.
Now, I'm going to create a new projects folder and then create or created into that folder.
So, we'll have an alien blasters folder that gets created in my projects folder.
I'll hit create and our project should get created.
Unity will launch up and in a minute or so we'll have our new project ready to go.
go.
go.
Now that it's finished opening, which took a little bit longer because I've got a bad internet connection here.
We can see the Unity editor and we can see my project.
The editor might look a little bit confusing right now.
There's a lot of stuff here, a lot going on.
And we're going to talk about that all in the next section.
And I'll go over each of the different areas and describe and explain what's going on there and what all of these things mean.
For now though, you can just go to window and choose the layouts option and choose default to get a nice default layout.
You don't need to go set up the project or do the linking or anything like that.
We'll do that afterwards.
Once you've got your view looking just about like this, click over to the game view.
Make sure that it looks blue.
Go back to the scene view and then come to the next section where we'll go over all of the different editor parts.
Now that we have our project created, let's take a look around at the editor.
If your editor doesn't look like mine, it's okay.
Just go to window, choose layouts, and choose default.
This should give you this default layout where you've got an hierarchy area or a hierarchy area on the left, a scene view in the middle with a little game tab up there, an inspector to the right, and on the bottom, a project and a console window.
Now, let's talk through what all of these different sections are and go into just some depth so that you feel a little bit more comfortable.
If you're already totally comfortable with the editor, feel free to skip this part.
But if you're new to the editor at all or you just haven't seen this version, recommend you just hang on for a moment and let me show you a couple of quick things.
First off, we've got the scene view.
The scene view shows us everything that's in our current level.
The hierarchy here also shows that, although by default, the Unity editor, when you open up a new project, for some reason collapses everything in there underneath the name of the scene.
Right now, we've got our sample scene open.
If you don't have that open, we'll talk about how to open it in a moment, but let's hit the arrow to expand it.
You'll see that there are two objects in our scene.
We have a main camera.
I can select it and a bunch of things just changed.
And I have a global light selected, and it looks a little bit different.
If you don't see this sample scene, that's okay.
We'll come back to this in a moment.
Let me show you how to open it.
Down here on the bottom, we have the project window.
There's a project and a console tab.
If it looks like this, just click over to the project window.
underneath the project window, you should see assets and packages.
There's also a favorites section up there.
Go to the assets section and then click on it and then choose scenes.
Double click on it and you should see your sample scene in here.
Just double click on it and it should open up the scene.
It might ask you if you want to save the empty scene that you're in.
You could just hit no.
So once we have this sample scene open, let's look at it again and talk through some of these objects here.
On the left, we've got our main camera in the hierarchy and our global light.
If I select the camera, you see that the inspector here on the right shows a whole bunch of somewhat interesting things.
It shows a transform, which may or may not be confusing to you, with some positional information.
It's got a position with an X, a Y, and a Z.
We're going to talk a lot about that later, a rotation, and a scale.
We don't really need to talk too much about the transform, though, so I'm going to collapse it by clicking the arrow.
Then, I'm going to talk about the camera here.
This is the next component on our main camera game object.
We'll talk a lot about game objects throughout this course.
This camera here has a couple of settings on it.
First, you'll see that it's set to orthographic here under the projection section.
This is because we're building a 2D game.
The other option for this is perspective.
So, if you're wondering how to get things into a 3D view, perspective mode is usually the way that we're going to want to go.
We'll talk a lot more about camera modes later, though I don't want to go too deep into it.
Just want to show some of the option stuff here.
The other option that I want to show is under the environment section.
Our background type right now is set to solid color and our background color is set to blue.
Right here, you can see a preview of our main camera is showing blue.
And if I go over to the game view here, you see that all we see is a nice big blue screen.
Now, if I change the background color by clicking on the color and then choosing a new tone or new color and go all the way to white, all the way to blue, go over to like a green or something else.
I can totally change what my background is looking like.
We can also add in images and we're going to do all that.
But background color is an important thing to understand and know about while we're learning about the inspector.
Now, let's undo this change.
I don't want to have a green background in my game.
It's kind of blinding me right now.
So to undo it, I'm going to hold control or command if you're on a Mac and hit Z.
That's the universal undo button.
And control or command Y is the redo button.
I don't want to do that though, so I'll control- Z again and remove that color change.
Now that we've got all of the different parts of the Unity editor talked about, let's kind of dive back into the hierarchy for just a moment.
In the hierarchy, we've got multiple objects and I can select between them.
And remember that the inspector is changing which object is or showing which object is selected, showing the selected one.
If I hold shift and I hit the up arrow here, I can actually select both of them or I can click on one and hold control and select multiple.
And you'll see that over here on the right, it looks a little bit different.
It has a transform section.
But here it says components that are only on some of the selected objects cannot be multi-edited.
So that means that because both of these objects have a transform component up at the top, that part can be edited together.
I can multi select them and edit it.
I could modify the scale or the rotation or something.
But because they don't both have a camera, I can't multi select and modify the camera or multi select and modify the light because only one of them has a light.
So that's pretty much the core of the editor or the core of the areas that you need to know about.
There's one other section that I want to show you though that you might get stuck with and might run into a problem with in the future and I think it's important to call out right away.
Well, two of them actually.
First, there's a lock button up here.
Say I've selected my global light and I accidentally clicked this lock and I go over to work on my main camera.
Notice that the lock button has kept it from changing.
It's actually changed or selected and locked onto this global light.
This window can't change to my newly selected object.
If I hit the lock again, it'll unlock and then I can now select objects and have them show up in the inspector.
This is very useful sometimes, but it's easy to get it mixed up and accidentally leave it on that mode.
Another issue that I see people run into often is right here on the triple dots.
See if we can drag this over just a little bit.
There's a debug option.
So, if you choose this debug option, things suddenly look really weird.
There's lots of extra text here and you're seeing things strange.
This comes in handy later.
We'll talk about how and when you can use this later, but if you ever see yourself kind of stuck in that mode, remember you can just go back here and choose normal.
Choose the three dots, go back to normal, and you're good.
And then the last thing is just remember that you can always go to window layouts and default to get back to a normal default layout and kind of match what you're seeing with my setup.
It's time to start building our game.
And to do that, we're going to need some art.
I usually like to start with a little bit of an environment and a player first because I feel like it lets me get right into the game, start to understand what I'm doing, and it makes it a lot more fun and interesting of a process.
So, to get started, the first thing we're going to need to do is download some art.
We don't want to be creating our own art.
You might be an artist and want to create your own art afterwards, but for this, we don't want to be creating our own art.
We want to be focusing on the game creation, coding process, and all of the other things that matter.
So, the art that we're going to use for this course is actually, well, two sets.
First, we're going to start off with some free online art that I really love from Kenny.
You can check out the Kenny NL page to find all kinds of awesome art that you can download for free.
and he's got some really great packs for $10 and $20 that I'd recommend you go check those out later.
You don't need them to get started, but as you start to build your game up, you might see some cool stuff and want to go grab it or just grab some more of the free packs.
But the pack that I'm going to use to start is this platformer pack redo, which has the latest version of the platformer assets that he's created in a slightly higher resolution than the old ones that were available before.
So, if you've downloaded these before or seen these before, they're just slightly upgraded ones that look a little bit nicer.
I'll hit download and grab this file.
And once the download finishes, I'll open it up with Explorer, or you can use your zip program if you prefer to use something that you have that deals with zips or Finder if you're on a Mac.
Now, inside of this zip, you'll see that we've got a couple subfolders.
There's a sprite sheets folder, a vector folder, there's a ken folder which has some info on how to use things, and there's a PNG folder.
The PNG folder has backgrounds, enemies, ground, HUD, items, particles, players.
This is what we want.
This is where all of the art assets that we actually want to use are.
And go down into here and see the details and see all of the different files in here.
So, how do we get these out of the zip and into our game? Well, first thing we're going to need to do is we'll put a folder down into our project that we can put them into.
But what I like to do first is just select all of these file or folders under the PNG folder.
Rightclick and choose copy or hit control or command C to copy onto your clipboard.
That's going to copy all of these folders onto the clipboard so we can paste them into our Unity project.
Now, I can't just rightclick and paste them into here, but I can rightclick, hit create, and choose folder and make an art folder.
So, we'll create a new art folder that we'll drop our files into.
Again, that was just right click in this project view in the open empty space.
Hit create and choose folder and then give it a name.
I named one art.
I'll make another one named art 2.
And then I'm going to delete my art too because I already have that art folder.
Once you have your art folder though, just double click on it and then rightclick and choose show in explorer or showin finder.
This should open up a window for you that you're used to.
just go right into the art subfolder.
It's going to actually open you at the assets folder with that art folder selected.
So, just double click or hit enter.
And then we're going to hit controlV or commandV to paste.
Or you can you might be able to rightclick and paste, but I noticed in Windows 11 for some reason the paste option is missing, which is a little strange.
Probably something with the zip.
Now that I've got all of these subfolders inside of my art folder, I should be able to use them.
But notice that back here in Unity, I don't see it.
It looks empty.
As soon as I click over to the Unity editor, it's going to import all of these folders and all of the files underneath.
Let's watch it happen.
So, I click and there it goes.
It's starting to pull in all of the different files that are in that zip file.
It's going to have all of my subfolders right down here.
And you can see it.
Now, I can go into perhaps the ground folder.
And let's go take a look at grass.
And I can see all of the different grass pieces that I can use to build out my game.
and go look at the planet folder, the sand, snow, and all that and see all of the different art assets that we've now got available to use.
There are some other asset packs that we can grab from Kenny that we'll talk about a little bit later, but for now, we're just going to stick with the the smaller pack and use this until we need something else.
We'll go through the process again of pulling in new things.
So, let's take a look at these art assets, though, because there's something that we're going to need to adjust for just about all of them.
And I find that it's a lot easier to just do them all at once than to do them later.
Let's go select this dirt center or whichever one you've got.
You could be on ground, grass, whichever.
Go grab one of the center icons here and look down here at the bottom right.
You'll see that it shows a preview of the graphic and it says 128x128 RGB compressed, a bunch of other weird stuff that may or may not make any sense to you.
What this is is telling us the resolution of this image.
So, it's telling us that it's 128 pixels wide and 128 pixels tall.
So, each dot there's 128 dots across, 128 down.
Now, that's really useful information if you know how to use it.
So, let me show you how to use it.
What we need to do with that info is put it into this pixels per unit field.
If we don't do this, things are going to be all weird throughout our entire process.
So, we want to do it right when we start to pull in our 2D art.
We want to set this to be 128 and then choose the apply button.
Now, you can't tell anything happened and this didn't update it for all of our sprites.
So, we're going to need to do this modification for every single sprite and then start to build our game up after we've modified them.
So, how are we going to do it for every sprite? Well, down here in the project view, there are a couple cool little tools.
And this one right here allows you to search for all of the sprites or all of things by a specific type.
So I'm going to choose sprite, but I also need to make sure that I go up to the art folder first.
So select the art folder, go up to the root art folder, and then search for sprites.
Otherwise, I'll only find the ones that are children of that folder or maybe some subset.
But if I go back to up to art and hit sprite, I should find everything.
Should be able to scroll through, see all of my players and boxes and everything else.
I think that looks good.
I want to go now select everything except for these backgrounds.
Actually, technically I could just select the backgrounds, too.
So, let's select the first one.
Grab all the way down to the last.
Hold shift and click.
Or you can just click in here and hit control A.
That'll select all of them.
Then go to the pixels per unit field here.
Change this to be 128 and hit apply.
Once that's done, it should finish importing and updating our assets.
We'll be ready to go and ready to start putting things into our level.
and start building out a level.
Now that we have art and we have a project, let's start building a game.
The first thing that I want to do is learn how to build a little bit of an environment and add a player.
So, we're going to expand out our sample scene so that we can see the main camera and our global light.
Again, if you don't have this scene open, just go to your assets folder, go to scenes, and double click on sample scene.
That should open it right up.
Once we've done that though, let's go over to the ground folder of our art folder and choose grass.
And then find the grass mid.
Let's see, where is it? Right here.
Grass mid.
We're going to take the grass mid and I'm just going to grab it and drag it right into the hierarchy here.
Not over here, but over here into the hierarchy.
It's going to center it and drop it right in the middle of our game world.
I can use the mouse wheel to zoom in and out.
And remember that middle mouse button to pan around.
Now, I don't like the position of that.
If I go to my game view, you'll see that it's got grass right here in the center of our world.
I want that to be down kind of near the bottom of our world.
So, let's make a change to do that.
But if we do it right here and I just grab, for instance, this Y position, click and drag and pull it down, it will move it down.
I could get it into a pretty good place, but it's going to be inconsistent because I haven't done a very important thing yet.
First, let's set this back to a zero.
And then let's go up to this game view window area and take a look where it says free aspect.
What this means is that our game will just kind of adjust and scale based on the the view of or the size of the window.
So the aspect ratio will adjust based on how much space we have.
If we have more wide space, it'll go widescreen.
If we have less, it'll go nice tall and portrait.
We don't really want that.
We want instead to be in a fixed aspect ratio when we're building a game.
That way we know what things are going to look like and have it'll be consistent.
Otherwise, we're going to have things looking all kinds of weird once we switch to an actual device that's playing full screen at 1080p or 4K or whatever the resolution you end up building at is.
So, what resolution do we want to choose? Well, by default, we go with full HD 1920x 1080.
It's what I would usually recommend.
Don't try any of the others yet until you have a need for them.
So, let's switch over to that.
Notice we've got some bars here now on the side.
And as I drag it, we keep that aspect ratio.
That's what we want.
Now, if I reset my layout, I go back to window layouts and default.
It is going to reset that back to free aspect.
So, I need to make sure to change it back to 1080 or 1920x 1080.
I could call it 1080p a lot from the old school TV times.
So, what's a value that I could put this grass at to have it be down here at the bottom? How can I move it around or how can I lower it? I showed you that I can click on this Y and just drag the mouse down to move it.
Look at that.
And you can see the number there changing.
Let's see what that's actually doing, though.
If we go over to the scene view, you can see that I've got an object here with with my grass.
And I can kind of click on it.
If I click the right spot, I get the mouse.
I can drag it around.
If I hit the W key, I'll get these arrows.
And then I can just drag it.
Oh, look.
Up and down or left and right, depending on which arrow I grab.
Right goes left, right, and the green goes up and down.
If I hit the E key, I can rotate it and spin it around.
I don't want to do that.
So, I'll hit control Z and undo my change.
And if I hit the E or R key, sorry, I can actually scale it up and make it nice and big or scale it down.
I also don't want to do that.
So, I'll hit control-z.
I also don't want this weird position.
So, I'm going to change that back to a zero.
And then we're going to move it downward.
So, to move it downward, I'm going to hit W, go into the move mode, but I'm not going to just drag it down like this.
Instead, let's control- Z.
I'm going to hold my control key, which is going to enable snapping.
Now, watch this value here, this position Y value.
As I drag it down, holding control, it's going to go down by increments of 0.25.
So, it's going to go down by one quarter of a meter is what that is.
And if you're not familiar with a meter, it's about a little less than three feet.
So, got to get used to that.
You're gonna have to get used to meter conversions.
But as I drag it down, it snaps down by a quarter meters.
And I can get it all the way down to what is this about -4.5 where it's right on the bottom touching this white line.
You're wondering what's this white line? That's actually the camera.
That's showing us where the camera bounds are.
If I go back to the scene view, this is showing us kind of the edge of the camera and the game view is showing us the the actual game rendered.
We can, by the way, drag these around.
Watch this.
If I drag this and see it, I can now see them side by side.
I could drag this around and see it on both of the views.
Again, control- Z to undo that.
I can grab my game view and just drag it back over here to dock them side by side.
Can always go to layouts default.
If you mess that up, just remember to change back to full HD.
All right, so now we've got some ground here.
What can we do with it? What if we want a whole bunch of ground? We want ground to go all the way across the bottom.
What should we do? Should we just go back in, find that ground object? Let's go find it.
and then drag another grass mid out here and try to lay it out and line it up.
I mean, technically, we could do that.
It would be a terrible way to do things.
That would be super inefficient and it would probably be really, really painful and take a long time.
So, let's undo that.
Let's go select this grass.
And I'm going to hit delete that second grass.
Not the first one, just the second one, the one that said grass mid with a one after it.
Then, let's go select the grass here that we've got.
And let's do a little bit of a modification to it.
Down here on the inspector, you see that we've got our transform that we've kind of looked at and moved things around with and looked at a couple times.
And then we've got the sprite renderer.
This is the component on our object that's making this sprite appear.
We've got three objects in our level, a camera, a light, and one object that has a sprite on it.
And it's named grass mid because that's the name of the sprite when we drag it out.
So, what does this sprite renderer do? It shows our sprite.
It gives us a couple different options of the way that we can show our sprite.
Right now, the draw mode is set to simple.
If I click on it, I can actually change that to tiled.
And a tiled sprite will allow us to repeat a texture and have kind of like a tiled background or a tiled floor or anything else that you'd seen tiled in a video game.
Now, to increase the tiling size, we can just modify the width.
Crank that up.
Make it 1 2 3 4 5 6 or whatever.
10.
I'm going to change this to be about let's go with a 20.
and then go over to the scene view and see what it looks like.
It's going just past our camera view.
We've got this nice long piece of grass.
Let's go back to the game view, though.
And then let's look at the sprite renderer and see what this little warning is because we notice we've got this big exclamation mark.
It's yellow.
And it might be a little concerning.
It says sprite tiling may not appear correctly because the sprite used is not generated with full wctck or sprite mode set to polygon mode.
To fix this, change the mesh type and the sprites import settings to full wctck and sprite mode to either single or multiple.
Now, for our use case, it actually works totally fine because the way these sprites are done, it's not really an issue, but it is something that I hate having there.
So, we'll just go get rid of the error by doing exactly what it said.
So, it says to change the sprite mode.
Let's Where does this to fix it? Change the mesh type, sorry, in the sprites import settings to full wreck.
So, we go find our sprite.
To do that, we'll select the sprite down here.
That's the actual sprite in our project view, not the one on the renderer.
And then we'll go to the mesh type right here, which is set to type by default.
And change it to full wrecked.
Hit apply.
And now our error will be gone once we get rid of the grass.
All that's really doing is making it pull in the entire sprite and not trim out edges if there were transparent empty corners or edges.
But these sprites don't have any empty corners or edges, so it doesn't make any actual difference.
That's why it's not actually changing anything.
So, now we've got our ground down below.
And I think it's time for us to add our player.
To add a player, we're going to go to the players folder.
We're going to select the 128x 256 folder.
This is the one where every sprite is the same height.
The other folder has the sprites at different heights.
We'll talk about that a little bit later when we get into ducking and jumping and all that stuff.
But for now, let's just go into the I'm going to go with blue folder and I'm going to find the blue alien that's idle.
Now, I can't see the names here.
So, I'm going to drag the little slider here so I can see them in list view.
And I'm going to take the one that says um what's his name? Uh alien blue front and I'll drag it right out into the scene view.
Now, I've got an alien sitting here right in the middle of our game.
And I should be able to press play and now have an amazing alien game with some grass underneath.
Let's see it.
So, there we go.
We've got our game and it works, but it doesn't actually do anything.
So, let's stop playing.
To stop playing, we click the play button again or use control or command P.
It's another hotkey I highly recommend you get used to.
Control P, command P to start and stop playing.
It toggles it on and off.
So, nothing happened yet because we haven't set up anything for our game.
We've got no code, no physics, no interactions, just kind of a static scene that we've drawn with some sprites.
Not so much a game yet.
So, in the next section, we're going to start hooking things up.
But before we do that, we want to make sure that we save our level.
To save our level, we're going to go to file and hit save.
That should get rid of that little star there.
And our sample scene name should just say sample scene without a sample scene star.
I don't particularly like that, though.
I don't like us working in a scene named sample scene or that we don't have a level of our own yet.
So, let's save one more time.
But to do that, let's go to file and choose save as.
We're going to go into the scenes folder and we're going to name our level level one.
So, right here in the file name section, we'll choose or type in the word level one with a space and hit enter.
We now have our scene showing up as level one here.
And go check this out.
If we go to the assets folder, go to the scenes folder, we now have a level one.
We also have a sample scene.
I can double click on it and see.
Yeah, it looks exactly the same.
Go back to level one.
Looks exactly the same.
So, not not anything too exciting.
I want to make sure that I don't accidentally work in this sample scene, though.
So, now that I have my level one, it's working and it's loaded.
I'll go down, select the sample scene in my project, and hit delete and delete it again.
Make sure that you're in level one before you do that and that you've saved it and it's all working.
Don't want to go delete that, otherwise you have to go recreate it afterwards.
Now that we've got that saved, we're good to go.
In the next section, we'll start to hook up our physics.
Now that we have our level created, let's talk a little bit about gameplay and physics.
One of the first things that we're going to need to do is set up physics for our player and our environment.
And to do that, we're going to need to add a couple interesting components.
The physics system in Unity is pretty powerful and robust, so you shouldn't have to do a whole lot of complex math or anything else to deal with collisions and combat and all of the normal stuff that you would want to do.
All we're really going to need to do is control the way that the player moves by sending it a little bit of data here and there and reading some inputs.
Sounds a lot more complicated than it is.
Let's take a look at how we can start moving our player around.
How we can start making it interact with the physics system.
To do that, we're going to go select the alien blue.
I'm going to go to this scene view again.
Remember, if you don't see it like this flat, just click that 2D button.
And we should see our alien here right above the ground with some stuff kind of covering his face.
If you want to get rid of the stuff covering a space, by the way, you can click this button to hide all gizmos.
Just make sure that you remember you can bring it back up so you can see that camera view and other things that it will show you later on.
So, I'm going to hide it for now.
And then we'll take a look at this character a little bit more in the inspector.
In the inspector, we've got the sprite render and we've got the transform and perhaps I could write some code that makes this thing move down or I could drag this thing down to make him fall with gravity.
But again, there's a physics system.
We don't want to do that.
but we want to use the built-in stuff.
So, how do we do that? Well, we need to add a component.
We need to add a physics component specifically.
We'll do that by clicking the add component button.
We'll clear out the search box that I've got there and then find physics 2D.
It's about what halfway down here and then click on it.
And you'll see there are a lot of different options.
Don't worry, we're going to cover most of these and they're a lot less complicated than they seem once you've gotten used to them.
So, now that I've got this popup though, I want to find rigid body 2D.
Select that and add it as the component to my alien.
So, now I've got a sprite renderer and a rigid body 2D component.
If I save by hitting Ctrl S or file, save and hit the play button, I should now see my alien start to fall down.
It's going to fall fall and kind of drop back either behind or in front of that ground piece and then keep falling.
If I look at my position here on this alien, I still have him selected.
So, he's showing up in the inspector.
So, he's just falling and falling.
The the value is going down lower and lower and lower.
A lower value on the Y just means it's lower down.
Up on the Y, positive on the Y is up.
Negative on the Y is down.
So, now he's falling very, very far.
So, now I want to make it so that he doesn't just keep falling.
I want to change it up so that my alien um when he falls down and touches the ground, he'll actually stop and land on the ground.
To do that, I'm going to need to add a couple more components.
I'm going to need to first add a collider.
So, to do that, we'll collapse the sprite renderer and I'm going to collapse this rigid body.
Notice you can click on these to collapse and expand them.
You don't have to find that little arrow exactly.
I'll collapse both of those and I'm going to hit the add component button again.
go to physics 2D and I'm going to find the polygon collider 2D.
I'll click on it and it should be added.
And if I zoom in a little bit, I might just be able to see it.
Oh, I've turned my gizmos off.
If I click the gizmos button, I can now see this green outline showing my collider.
It's a little bit hard to see because there's a lot of stuff in front of it.
But if I uncheck this sprite renderer, so my sprite stops showing up.
I can see this green outline showing me my collider.
And the collider is the thing that the game engine is going to use to determine how it actually interacts with the world.
So if it falls down, it'll land on this object.
It won't use the actual sprites.
The reason for that is you don't want every sprite to have collision on it.
Imagine I've got a fence sitting in front of me that I'm walking in front of or past or something that I'm trying to like run behind.
Um that object I don't want to collide with me.
So we have totally separate control over the collisions versus the rendering.
And this is kind of seeing that in action.
All right, let's zoom out with the mouse wheel, middle mouse to pan around and press play.
I'll let let my character fall down and see if he stops on the ground.
So, you can see that he didn't stop on the ground.
He falls all the way through.
And the reason for that is we need a collider on the grass as well.
Colliders only interact with other colliders and need something to actually hit and land on.
So, to add a collider to the grass, we'll go select our grass and we'll choose the add component button again.
go to physics 2D and this time we're not going to choose a polygon collider.
We're not going to choose the polygon collider 2D because we have a relatively square or rectangular shape.
So we can actually choose a box collider 2D.
And the reason that we want to go with a box collider over a polygon collider is primarily performance.
Calculating collisions for squares and boxes for the computer is very easy.
Calculating them for sprites is a lot more complicated.
Even when the sprite is technically just a box, there's no real reason to use a sprite renderer when we have a box.
So, we'll go with a box collider or sorry, a box a polygon collider, not a sprite renderer.
Said the wrong word there.
All right.
So, we've got our box collider.
And if I press play, I should now see that my character lands on top of the box collider.
So, I play and he lands right there.
Looking good so far.
There is an issue though.
If I uncheck the sprite renderer on my grass so that I can only see the collider.
Look at this little green box here.
That's where my collider is.
My collider isn't tiling out and using the same width like my sprite renderer was.
That's actually an option though.
Right here we've got the autotiling check box.
If I check that, the green box went all the way out and now it's covering the entire thing.
I'll recheck my sprite renderer.
Press play.
And it's going to work exactly the same because I was landing over there.
But let's see what would happen if I hadn't done that.
So let's say that I haven't checked autotiling and I move my player over here a little bit to the right.
Like I make his position be oh let's say two on the X.
Now look at the grass.
So the colliders there, my character is there.
If I actually select both of them, I can see the colliders for both.
And press play and see that he'll fall right past falls right past.
Yep.
And then if I go again, check that auto tiling.
So the collider covers the whole thing.
He'll land on top of that ground.
Oh, he did not land on top of my ground.
Why did he not land on top of my ground? Oh, I checked autotiling on the wrong collider.
If we go to the grass mid and check autotiling, then he'll land on the ground.
You got to make sure that you actually selected on the correct object.
There we go.
Looking good.
So, I think that's good.
I'm going to save my level and then we'll move on to moving our player around and setting up some source control.
Before we start writing code or doing anything complicated, we really need to talk about something that's somewhat of an industry standard.
Something that I think is very important that everybody understand, know about, and use.
Whether you're a beginner, a professional, or anywhere else, if you're doing software development or game development, you need to know about this.
And that thing is, you probably saw the title, source control.
We're going to be using source control throughout our project and throughout the entire course for a couple of reasons.
But before I dive into what those reasons are, let's talk about what source control is for those who may not know.
Source control is a system where every revision or every change that you make to your code can be tracked and modified or gone back to or shared with somebody else.
So, when we make changes to our game, we'll do what's called a commit where we'll just check that piece in, save it off, and it's not going to anyone else.
It's just going to be for you, but you'll be able to share it if you decide to later.
But you'll be checking this thing in to a remote system that will then save that version of your project off.
Then you can work on your project some more, and when you're ready, you can check that version in and save off your your latest changes every time.
Now, the benefits of this are enormous.
It might not seem that great.
It might seem like, oh, I could just copy and paste the folder of my project or something like that, which is what people used to do in the olden days is a terrible terrible idea nowadays because there's so much better options.
But let's dive into what what the real benefits are.
The first benefit of using source control is that if something goes terribly wrong with your system, you know, your computer gets stolen, catches fire, your hard drive dies, or whatever else, you're able to recover your work.
Now, when it's a small project, a side project that you don't care too much about, it's not a big deal.
But if it's something you've been working on for a couple months, or it's a school project, or your company work, it becomes a very, very big deal.
And even when it's a small project, it's kind of annoying that you've lost it for no reason.
Um, the other thing that it really helps with is giving you access to your project from other places.
So, if I'm working on a project and I'm using source control, when I commit my changes, they go up to a remote system.
That remote system can be accessed by me.
I can log into it from another computer and download my project, work on it from there, and then upload my changes by committing them again and resume my work on my other system later.
It allows you to go back and forth between computers relatively easily.
In fact, probably the easiest way to do it.
And it's one of the things that I do constantly.
I work on my desktop and I go back and forth to my laptop by committing into source control and committing regularly.
The other thing, and this is probably the most valuable thing that it does for you, is allow you to experiment and kind of play around and learn and try things out without worrying about losing or destroying your project or losing work or anything.
So, if you want, if you got an idea, you want to just, hey, go play around, try something out, you can go experiment all you want and delete things, change stuff up completely, and then you can just rightclick and undo your changes.
You can get go right back to the previous version that you were on or you can even do what's called a branch and have a totally separate version that you can then combine back in or ignore and just abandon later if it ends up not working out.
We'll talk a bit about those more advanced topics later.
Though I first just wanted to really dive in and kind of explain that source control is extremely important.
It's something that you're going to need to know how to use.
It's something that if you're a professional developer, you should already be using.
And it's uh I I think one of the most important things to make sure is also on your resume.
Now, before I show you how to get started with source control, I do want to mention that you can use other source control systems.
The one that I'm going to show you is actually owned by Unity.
They acquired it a few years ago and it's integrated really well into the engine and has pretty good support.
But if you're already familiar with Git or Perforce or something else and you really like using that, feel free to use that instead.
This is mostly for people who aren't already using source control, don't already have a workflow set up for that.
So, let's take a look at the workflow for setting up Unity source control system, which is called plastic SCM.
To get to plastic SCM, you'll need to find the window menu.
Let's go find window right here, and then choose plastic SCM.
This should give us a window down by the console and project windows that has an option to log in or sign up for a Plastic account.
Let's click on that button and we should get this popup.
If you don't get this popup, try just clicking on the button again.
I've had it in the past pop up an error message or just show nothing at all, show something in the console, and then going back and hitting the button again just made it work.
So, now that I'm at the point where I can sign in, I've got two options.
I can sign in with my Unity ID or with an email.
I'm going to use the Unity ID option since we've already set up a Unity account.
And now I should be signed in with my new Unity account that I've created.
Now, I don't know why it gave me an error saying there was an invalid token, but I'm guessing I can just jump back over.
Yep, went back over to Unity.
And now it tells me that it's time to create a new cloud organization.
This is something that we'll be using along the way through the project to do more than just committing files.
We'll also use it for our build automation stuff.
But for now, we just need to hit the create button and come up with a interesting or cool or unique name.
It doesn't have to be something amazing.
I'm going to call this Jason or I put game Jason courses.
There we go.
I recommend obviously don't use my name.
Use something else.
Use whatever it is that makes sense for your organization.
You probably only want to have one of these.
You probably don't need multiple.
So come up with something that you'll want to stick with longterm or don't worry about it and just change it later.
Then choose the correct region for yourself.
I'm going to choose uh US East since I'm in the US.
And then hit the create button.
This should create the organization and create our repository.
So this is doing a little bit more than normal source control but not a whole lot.
It's creating well the repository part is normal.
the extra stuff.
The cloud services stuff is a little bit extra.
All right, so we've got the organization created.
We hit the continue button and then it's going to pop up the documentation.
You're welcome to go through this.
In fact, I recommend that you do.
There is a standalone plastic SCM tool.
We're going to take a look at that later on down the road, but if you want to dive in more into source control stuff, if you're just kind of curious about it, you can definitely check out this documentation.
But for now, we're going to go back into Unity and we should have a little popup like this that says we've joined Plastic SCM or joined our organization or we have a button to join it.
If you don't have this, just click that login button again.
It's possible that the token thing didn't work.
Just hit that button and it should pop you get get you back to this window.
I'll hit the join button and now it popped me back up to the documentation again.
We'll go back into Unity and we'll hit the create workspace button.
Now that I'm logged in, I should be able to create a workspace.
And it's going to come up with a default name.
It's going to say Alien Blaster at JSON coursescloud.
That's exactly what I want it to say.
If you don't see that, if you see, well, you shouldn't see JSON courses, but you should see your own version.
If you don't see that, click this little dropown and make sure that this isn't selected onto local.
I've seen that happen multiple times and it just won't work.
It'll give you a little error, a timeout, or something else.
If that says local, just switch it over to the cloud one, whatever your cloud one is, and then it should work.
The last thing we need to look at before we hit create is this little option for which way we prefer to work.
If we want branching, merging, and the ability to push and pull using a plastic workspace or if we want the older simplified version.
We're going to stick with the default.
We want branching, merging, and all of that.
And then we'll hit create workspace.
This should create our repository and then change our UI to show us all of the files that we've added to our project.
It's got 455 files and I can scroll through them and view them all.
Kind of get a quick list view of them.
See the icons, but I don't need to see them all.
It's all of the files in my project.
So, I'm just going to check this little box here at the top on added and private.
It's going to select all 455 of the 455 items.
And then we're going to type in a message.
I'm going to just say this is a we've added our initial art and level one and then I'll press the check-in changes button.
This is going to commit our changes to the repository, upload them to the remote server, and then show us that we have no new changes.
If you get an error when you click that, probably just click okay and then click the check-in button again.
I've seen that happen multiple times.
An error pops up, you hit check in again and it just kind of works.
All right.
Now that that's done, we should be able to go over to our change sets window and we should be able to see our actual commits.
So right here we've got our added our initial art and level one.
But notice that that's number two.
There's actually a commit number one that was created when we initially created the repository and another one that was created I guess the first one.
So zero was created when we created our repository.
Then it automatically uploaded some of our project settings files.
These are files that you don't need to worry about.
They're managed by the editor and they're changed when we go into edit and then find our project settings.
All of these little sections here have their own little settings file.
That's what was committed in the first one.
And then commit number two is ours with all of the art.
So now we've got all of our art in there.
I've accidentally unloaded my level.
Let's go back into level one and we'll continue on.
All right, it's time for the fun part.
It's time to start writing some code.
To do that though, we're going to need to create a folder for our code to go in and get our code editor set up and running.
Let's start by going into the assets folder.
I'm on my project window.
Go to the assets folder.
We'll right click in anywhere the empty space or anywhere in the empty space.
Choose create and then choose folder.
We'll name this folder scripts.
S C R I pts with a capital S there so that it matches the casing of the rest of our project and hit enter.
I'll hit enter one more time to go into that folder or just doubleclick on it.
Now we have a scripts folder and this is where we're going to keep all of our code.
We can move our code pretty much anywhere in the project, but in general you're going to find that Unity projects tend to keep their code in a scripts folder or something similar.
Scripts is kind of the default that's um recommended and in a lot of examples.
So that's what we stick with.
It's what I generally stick with.
I used to use some custom ones, bounced all around, and now I just go with the scripts folder.
I like that and it works really well.
Let's rightclick now in our scripts folder and create a new script.
So, we'll choose create and right up here, right below folder, there's a C script option.
I'm going to click on it and be very careful not to hit anything else.
I'll get a new script down there that's named new behavior.
And it's right now in renaming mode.
I don't want to hit anything until I've renamed this script.
I'm going to rename it to player with a capital P.
So, hold shift P and then lowercase L A Y R.
And now I've got a player script.
I'll hit enter and it's going to actually generate that script.
Now, the reason that I wanted to be very careful about that is because if you look over here at this script in the inspector, which is not where we'll normally look at scripts, but gives you a nice little preview.
It has this part right here where it says public class player.
And if I had hit the enter button before and then went back and tried to rename this or something, this would be named whatever the file was when it first went in.
So it would have been that uh new behavior or I forget what it was called.
I think it was new behavior instead of player.
And I want this to be player.
So now I've got my script here and it's time to work with it and start writing some code.
To do that, we're going to need to open up our code editor.
And the code editor that's installed by default with Unity and Windows is Visual Studio Community.
And you get Visual Studio Code on uh Mac.
Now, I prefer Jet Brains Writer.
We'll talk about that code editor a little bit later.
I don't want to confuse things though.
So, for now, we're just going to go to assets and go to open C project.
This should open up Visual Studio.
And you'll probably get a window that looks something like this.
If you've never opened up Visual Studio before, first time in, you're going to get this what's new window.
I'm going to close that.
Expand out this assembly part.
Expand out assets and scripts until I can see my player script.
I click on it and double click it and it should pop right up here and show me my player class.
Let's zoom in by holding control and using the mouse wheel.
So, I hold control and mouse wheel to zoom in or uh there's a drop down somewhere around here that you can use.
Ah, bottom left corner.
It moves around.
It's at 214% right now.
So, now that I'm zoomed in, I can see my script nice and large.
And there's a lot of stuff going on here.
If you've never written code before, if this is first time seeing code, first time writing code, it can be a little bit overwhelming, but don't worry, it's going to get all very simple and make a lot of sense relatively soon.
So, the first thing that I want to call out is this class name.
Right here on line five, we have the word public class player.
This is the name of our script.
This is the thing that we've named it when we created the script and it's the thing that's going to show up as our component name when we add it to our actual player game object or that alien that we've created.
So, this is important that it matches exactly with the file name.
If we change the file name or we change this little bit of code here, I add in a K here in the middle of it, we're going to get errors.
Everything is going to break.
It has to match.
It's kind of a weird Unity thing and it's not something that most coding systems require, but with Unity, it's very important that our components that we're going to add or our scripts that we create by hitting that rightclick and create new script that the file name matches the class name.
So, the next part that we have is a colon and the word mono behavior.
Now, this actually means that our player script or our player class is going to what we call inherit from the mono behavior class.
That means that it's going to get some abilities and some stuff that it can do because of that.
It's essentially going to get some of all of the abilities that a mono behavior class has and make them available to our player class.
You don't need to know what all of those are, but we will talk about what some of them are.
It essentially makes it so that our player class does a lot of things for us automatically and we don't have to write code to do all of the things that a game engine would do for us.
Kind of gives us ways to tie into all of the different things that we would care about like when we've hit something, when the player has pressed a button or when every frame has happened.
In fact, that's what this is right here on line 13.
You'll see what we have is a comment.
You can tell it's a comment because it has two forward slashes and it's colored green.
And a comment is just code that doesn't actually run.
It's not really code.
It's like notes in the code just for humans.
This comment says that update is called once per frame.
Which means that this method here on line 14, which says void update, it means that void means that it doesn't return anything.
We'll talk about that in a bit.
For now, just know that that's kind of the default thing you're going to see in front of a method.
And then we have the name of the method, update.
So this update method gets called once per frame.
So, if we have something that we want to happen every single frame of our game, we can just write that right into this update method.
So, let's do something here.
Let's write a little message that uh will log something out to our console every single frame.
To do that, I'll go to line 16.
So, right here in between 15 and 17, click.
And I'll type debug with a capital D.log with a capital L.
And I'll do an open parenthesis.
That's shift and number nine.
And then quotation marks.
and we'll say updated at and then I'm going to put a space and watch this.
We're going to do something a little bit complicated after the quotation mark.
So I moved over to the right of the quotes with the arrow key.
We'll add a space and a plus.
So shift and equals for me at least.
And then we're going to do time do time and then I'll go to the end and add a semicolon.
So take a look at this line.
There's a little bit there going on.
You want to make sure that it's copied exactly as I have it.
debug.log open parenthesis then open quotation marks.
It's a double quotes updated at and then we have a closing quotation marks and then plus and then time with a capital T dot time with a lower case t.
Very important that they all match.
Next, we're going to press Ctrl S and save to get rid of that little star.
So, there are changes to our file have happened.
You're going to find that throughout the process of building games, you constantly forget to save your file and then wonder why things don't work.
Just make sure that you go back in here and hit Ctrl S.
Now I'll minimize the window for our code editor.
Go back into Unity.
And if I press play right now, what do you expect's going to happen? Think about it for a second.
Let's click on the console window.
Press play and think what's going to happen.
See what happens.
We can see in the console window, nothing seems to be happening.
There's nothing appearing down here.
We're not getting a log message like we just written out.
So, how do we get that message to appear? Let's stop playing, go back to the project view, and let's go select our alien blue front, which is actually our player character that we have.
What we need to do is add our player script to the character or to this game object.
Until it's added to the game object, it doesn't exist in the world and it won't do anything.
So, we can write a script.
If the script isn't actually used or referenced in our game, it won't do anything at least until we use it or reference it in our game.
So to do that, we can do well a couple different things.
We can hit the add component button and then we can go down to scripts and then find player.
That works perfectly fine.
That'll add it right on.
I can rightclick and remove it though because I want to show you one other way to do it.
I can take this player script, click and drag it on and also assign it that way.
Now if you just single click, it'll select it and that won't work.
You actually have to go back over here, click on your alien, click and drag and hold it and drop it onto there.
But look, now I've added two players.
That's a problem, too.
I don't want two of them.
So, I'll right click and remove the second one.
Now, I'll save my scene.
So, we get rid of that star, press the play button, and we should see our console start to log out our message that we've written.
Let's see.
Go to console, updated at, and look at these numbers here.
The numbers are actually the amount of time that's passed since the game started.
So, updated at 10 seconds in, 11 seconds in, 12 seconds in, and so on.
Let's stop playing now.
Now, let's go to Plastic SCM and commit our changes.
So, we've got our new player script and our level updated.
We'll say that we've added the player script and attached it in level one.
And we'll check in our changes.
Hit save to make sure that my level is saved.
Oh, and if we get that error, can just hit that check-in button again.
There we go.
Now, we're going to write some code to make our player move or allow our player to control the character's movement with some input.
We'll allow them to move around with a controller or the keyboard that they have.
So, to do that, we're going to need to reopen up our player script and add in a couple more lines of code.
It's actually relatively simple.
You'll be pretty impressed with how easy it is, I think.
Let's open up our player script and then go down here to our update method.
So in our update method right now we have this message that we're updating at some time.
We're going to delete that message.
We don't need to log something every frame.
This is just so that we could see the code and see something happening without doing anything complicated.
So I'll select that line of code and hit the delete key.
That should clear it all out.
Now what I want to do next is move my rigid body component or move my object around using that rigid body component.
So I'm going to need to do two different things.
I'm going to need to read the input from our player and then apply that input to our rigid body.
So let's start by reading the input seeing what that looks like and then see how we can apply it to the rigid body component.
So what we want to do is read in the horizontal and vertical inputs for our keyboard controller and our basically our entire system.
So to do that we can say var horizontal.
I'm going to spell this correctly.
It doesn't have to be correctly, but the next part does have to be equals, and we're going to use the word input with a capital I, I pu t dot get axis, which is a capital G and a capital A.
Then open parenthesis, which is that shifted nine, and a quotation marks, the double quotes.
And here we need the word horizontal.
It needs to be spelled exactly right.
And it needs to be cased correctly, too, with a capital H.
So I'll add a semicolon to the end of it.
So it looks just like this.
Now we've got a variable that will be assigned to whatever the horizontal value is on our system.
We're going to talk about what that means in a moment.
First, let's log this value out.
So on the next line, we'll hit enter at the end.
We'll type debug.log.
And you can see it's actually trying to autocomplete for me.
I can hit tab and tab and it'll just autocomplete and fill that in.
or you if it doesn't autocomplete, you can add the parenthesis and put the word horizontal with no quotation marks.
I'm going to save S.
That got rid of the star there.
And we'll jump back over to Unity and see what this did and how this works.
And now that we're in Unity, it's not going to do anything until we've pressed play.
And of course, it won't do anything if our alien doesn't have the player script.
So, make sure that you select your alien, make sure that it still has your player script that you haven't accidentally forgotten it, removed it, or did something weird, and then press the play button.
Once we do that, we should see our game mode.
We got our character right there.
And if we go to the console window, we should see a bunch of zeros writing out here.
That's because our horizontal input right now is at nothing.
It's zero input.
We're not pushing to the left.
We're not pushing to the right.
But if I click in my game window and I hit the A key or the D key, I'll see this value start to change.
The D should turn it all the way up to a one and the A all the way down to a negative one.
And you'll see it kind of go in between there as well.
What it's actually doing is trying to replicate the behavior of an analog stick.
So if I push to the left, I should get a negative one.
And if I push to the right, I should get a positive one.
You can kind of see that happening.
And the reason that I get the partial values is if I'm like partway over here.
So, if you tap on a keyboard, it'll actually kind of pretend that you slid a a stick over instead of going immediately and snapping all the way over.
So, now we're reading our inputs, and you can see that value showing up there.
Now, we just have to apply that to our player's rigid body to move them around.
First, we'll stop playing.
And then, let's take a quick look at the game object that we have here in the inspector.
We have a player script here.
And if you look to above above this polygon collider, we have a rigid body 2D component.
And what we want to do is tell this play have this player component tell the rigid body how to move or what to do for its movement based off of that input.
So let's open up our player script again to make that change.
To do that, we can actually get to our player script a couple different ways.
We can go back in the way that we went before, or I can just double click on this player script right here, and it'll pop it open.
So now that I've got my horizontal value, I want to apply that to my rigid body.
I'm going to add another line here.
And I'm going to say var RB, which is just short for rigid body equals get component.
And I'm not going to hit tab to autocomplete this because it's actually wrong.
It wants to get a rigid body, but I want a rigid body 2D.
There we go.
I can actually hit the down arrow and select the correct one.
Now I'll hit tab and let it autocomplete.
So, this is going to get a 2D rigid body component.
If I just did rigid body without the 2D, it's going to fail to find that component because I don't have a non- 2D one.
That's for the 3D one.
That was the original name.
It's not called rigid body 3D because there was no 2D long before 3D existed long before 2D ever came around.
So, it was called rigid body.
So, I'll undo that with control Z.
Have my rigid body 2D.
And then we'll go to the next line.
Let's talk actually really quickly about what this git component does.
Git component will actually search the game object that you're calling this component this this code from this player script is attached to.
So it'll search this game object that this alien has with this player script and look for that type of component.
It'll look for a rigid body 2D component and if it exists, it will assign it to this variable.
And in fact, I can change this from being var to be a rigid body 2D and make it slightly more explicit.
Now, on our next line, we're going to use this RB variable and we're going to use it by setting the velocity.
To do that, we say RB, which just gets us our reference.
And look, it actually knows we want to modify the velocity.
Just know what we want to do with it.
We'll say dot velocity equals and we want to make this a new vector 2 or vector three.
I think new vector 2.
A new vector 2.
And a vector 2 is a variable with an x and a y value.
So imagine you've got a grid with an x going along the horizontal and a y going along your vertical up and down.
The vector 2 just has the two values that you have, the x value and then the y-value in that order.
So the first value that we want to give it is the x or the value along the horizontal axis which is going to be our horizontal value.
And then we give it our vertical value.
So how what we're doing up and down.
For that I'm just going to give it a zero and we'll put a semicolon at the end.
We'll save this off and then minimize our window.
Go back into Unity and we should be able to see our player moving around.
Now we just have to hit play play play and then let's use the arrow keys or A and D and we should be able to move left.
Look at that.
I can move to the left or to the right.
Notice that I fall slightly strangely though.
That's because right now I'm actually setting that hor or the vertical velocity.
We're setting it to zero every frame.
So I don't fall smoothly and my falling speed doesn't kind of stay consistent.
So let's stop playing and we'll make one last change to that little bit of code.
We'll go back to our player script and instead of putting in a zero for the y value, let's use our current y velocity.
And we can actually access that by saying rb.ve velocity.y.
So now what we're going to do is modify the velocity, but we're only modifying the horizontal part, not the vertical part.
Now you might wonder why we can't just do rb.ve velocity.y y or x, sorry, equals horizontal.
And that's because we can't assign one of the variables of a vector 2.
You can't modify the x or the y of a vector 2.
You can only create a new vector 2.
So, we have to not do that and assign that new vector 2 where we pass in the horizontal and the velocity.
Let's go see what this looks like in game.
We'll jump back in and press play.
We should be able to move and then see our character kind of falling slightly more naturally.
They're going to get that regular gravity fall.
There we go.
Yep.
Gravity fell and everything was a little bit normal.
So, we'll stop playing.
We'll go back to plastic SCM and commit our changes.
Say that we've added horizontal movement to our player and check in the changes.
Now, we're going to give our player the ability to jump.
To do that, we're going to open up our player script and we're going to make a couple little modifications.
Instead of just setting the velocity or the vertical velocity to its current vertical velocity, we're going to want to set it to a jump velocity when the player presses jump or leave it at that if the player hasn't pressed jump.
So, how can we do that? Well, let's add a line right between line 18 and 19.
So, I'll go to the end of line 18, click here, and hit the enter key.
And we're going to create a new variable.
We'll say var horizontal equals no not horizontal vertical var vertical equals and we're going to set it to equal to our rb.v velocity.y.
Now we're going to hit enter and I'm going to hit escape.
The autocompletes popping up.
Those are all that gray stuff there was just autocompletes.
So just hit escape and it disappears.
Now, what I want to do in my velocity setting is instead of setting it to a new vector that's the horizontal and the current velocity, we're going to set it to the horizontal and the vertical.
And right now, this actually hasn't changed anything at all.
It's going to do exactly the same thing.
All we've done is added another variable here.
Instead of setting it directly to this y values var value y variables value, we assign it to a vertical variable.
And then we're just using that.
So we need one more bit of code.
We need to check to see if the player has pressed the jump key.
So we're going to add in a if statement or an if statement.
We'll say if and then we're going to do open parenthesis.
Notice that it's purple because it's a different type of keyword.
It's a new one.
What this is going to do is check to see if something is true.
And if it's true, it's going to run some extra code.
So we say if input get button down capital B, capital D, and a capital G there.
and we use our open parenthesis and quotes and we're going to check for fire one which is our leftclick button and I think it's also our space button.
So if we have pressed that button then we're going to run the code on the next line which is going to say vertical is equal to and we're going to assign it to let's just say five.
So we're going to give it a big value of five upwards and then we'll hit enter and add in a new line.
So we'll save with control s get rid of that star and we should have no errors.
If I hit control shiftB, it should actually do a build and show a build succeeded message down there.
If you don't see that, if your hotkeys are different, go to build and look for the build solution one.
Control shiftB is the default.
That's what I use.
Make sure there are no errors.
So now I've got my update method with the check to see if we pressed fire one.
That should modify the vertical velocity whenever we press fire one.
So let's minimize this window.
We'll go back into Unity.
We'll press play and then we'll see if it works and then talk about where these buttons are coming from.
So, we hit play.
I can click and look at that.
My character jumps up, bounces up.
I can move left.
I can move right.
Kind of spin around and jump.
I can spam jump as fast as I want.
It just seems to work.
So, all right.
So far, things are looking pretty good, I think.
But you might be wondering where are these inputs coming from? What is this all? Where's this magic? What are these strings? Let's go take a look at our edit and then project settings.
You go to edit project settings.
You should get a window like this and then look for the input manager section.
In the input manager section, there's an axis section or an axis drop down tree, I guess, you can expand.
And underneath it, you'll see that we've got horizontal.
Look at that.
It shows the keys that it's bound to.
We've got vertical.
We've got fire one, fire two, and so on.
Yeah, it was left control and mouse zero.
So, you can see what these buttons are.
Um, fire two is the right click and I think fire three is your middle click.
These are all part of the old input system.
This is the system that's been built into Unity forever.
It's very simple, very easy to use.
It works great for the most part, but it does have some downsides when you start to get into doing multiplayer development and other things.
Relatively soon, we're going to switch away from the old input system to the new input system.
But I wanted to make sure that you understand that this exists, understand how it works and that it's slightly different from the one that we're going to be using throughout most of the course.
But you will see projects that are using the old input system constantly and tutorials and everything else.
So, it's very important that you understand it, know it exists, and even if you don't regularly use it, you should know that know how to use it.
So, there we go.
Let's go back into our plastic SCM window and let's commit our changes.
So, right now we've added a jump.
So, we'll say added a basic jump and check in our changes.
Cool.
Now, we're going to make some modifications to our jump.
Our current jump makes our player bounce up every time we click.
I can keep clicking as much as I want, but I can't hold and jump.
I don't have a whole lot of control over it.
So, what we're going to do is modify our jump code, add in a member variable, and take a look at some timing.
Let's stop playing and open up our script.
To do that, I'm just going to double click on one of my log entries down here just to show you another way that we can open up scripts.
Double click a log entry and it'll actually take you to the script at the specific line where that log was being written.
Notice that my cursor is right here at the end of that debug.log line.
If it doesn't work the first time, sometimes you just got to double click on it again.
Sometimes it's opening up the project for the first time or something.
So, let's continue on by looking at our code.
The code that does the jumping is here on line 21 and 22.
We check to see if the player has pressed the fire one button, which remember a moment ago we looked at was bound to the left click on your mouse or I believe it was left control.
And if they have pressed that in this frame, then we'll set their vertical up to five.
Otherwise, we set their vertical to the current velocity.
So, it just continues to fall down.
So, what is this doing? Well, it's only checking when we press the button.
Let's change it real quick and get rid of the word down here.
There's actually a get button method, a get button up, and a get button down.
Let's just change it to be get button though.
And I'll hit Ctrl S and save.
Make sure that that star goes away.
Make sure it's spelled exactly right.
Jump over to Unity and guess what's going to happen if I hold my button down now.
Well, I'll let you guess.
I'll let you try it out and then see if you guessed right.
So, we start to play and we fall and I hold the button down.
And look at that.
I continue to go up for as long as I hold the button down.
And that's because the get button method is checking to see if I'm still holding the button down or if the button is down this frame where get button down is checking to see if the button was pressed down this frame.
It's a little bit confusing.
Again, you don't need to worry too much about these because we're going to move on to the new input system shortly after this.
But for now, let's just remember that get button down is for pushing it down or the event when it fires or when it's pushed down, the frame when it's pushed down.
Get button up is for the frame when it's released.
So if you release the button, you can have it do a jump on release or get button is the one for checking to see if it's currently down this frame.
It'll be true for every single frame.
All right, let's go back into the code.
So we now know how to check to see if the fire button is being held down.
Now, how do we make it so that we can only hold the fire button down for a certain amount of time? Because I want the player to be able to jump and hold the jump, but maybe only for 1 second or something.
I don't want them to be able to hold it indefinitely.
Well, to do that, we're going to need to keep track of when the player started jumping.
And we know how to track when the player started jumping, or we should have a good idea because we just talked about it a moment ago.
We can use the get button down method to see when they've started jumping, keep track of that time, and then use that time in our calculations to see if they can continue jumping or not.
So, let's add in a new line here above line 21.
So, right after 20, I'm just going to add in a line.
So I have a little bit of space.
And here, let's check to see if the player has pressed the fire button this frame.
So that means that they've started the jump.
If they have, then we'll keep track of when they can release the jump or when the jump has to end, I guess, is really the way that I want to say that.
So say if input.get button down.
Remember, this is the one that fires off whenever the button is clicked for the the first time for the frame or the first frame that it's pressed down.
So we'll put in fire one.
So if the fire one button is pressed, we want to run the line of code right after it.
And that line of code is going to say that our let's see jump end time is equal to time dot time plus and let's just add a one here.
So we're going to add 1 second to the current time.
So our jump's going to end 1 second from now.
That's the longest we can hold it.
I'm going to add in an extra line by hitting enter.
And then notice that our jump end time doesn't exist.
So we need to create this variable for our jump end time.
And we're going to create this variable as a member variable.
So instead of it being something inside of our update loop where we have here this update method where we have for instance our var horizontal and our var vertical we can't do a var jump time or jump end time equals zero here because if or we'd have to put an f because it's going to be a floating point v value.
We'll talk about that in a moment.
We can't do this here because this jump end time would get reset every single frame.
So every frame the code would run through jump end time would get created set to zero and then the time would get checked to or maybe get set here.
And this would not work at all.
We need to keep track of jump end time across update loops.
So we're going to delete this line 21 here that I've added there.
And I'll hold shift and delete to delete out those extra lines.
Shift delete will actually delete whatever line you're on.
Just make sure you're on the correct line.
Remember you can always control Z to undo.
Shift delete to delete those lines.
So, we need to make jump end time into a member variable.
And there's something special that I do when I create member variables.
And that's I go to the beginning of them and I usually add an underscore with shift and the key.
It's next to zero.
Adds a little underscore there.
And this just is an indicator for me that this variable is something that's going to be used across multiple methods.
It's not just a method or a variable that's for this method only.
So to create this member variable, there are a couple things that I could do, a couple different options.
One, I could copy the name of it, and then go up kind of to the top of my script here, paste it in with with writing the code.
I'll show you how to do that later, cuz the other way that you can do it is just hit alt enter, and then hit generate field.
This looks a little bit different in every editor, but it's pretty much the same.
It's always available.
There's always a generate field option.
and we'll just hit generate field.
And you'll see that I now have a private float, which is a floating point number.
It's essentially a number that has decimal points.
There's a little bit more to it, but just think of it as a number with decimals versus an int, which is a number without decimals.
We've got our variable name jump end time.
And notice that this is inside of this player class squiggly brace here.
So, there's an opening squiggly brace at the end of our player class definition or declaration.
And there's the variable here inside of it.
We also have our start method in here.
We haven't really talked about that one yet, but it's up here.
We can kind of ignore it for now.
Let's look at the update.
The update method that we've been using is also inside of this squiggly brace.
The main thing to note here is that this variable is inside the class.
It's part of the class, but it's not part of the method.
You see how look inside update? It's not part of the method.
So, it's going to be stored and kept along or persisted indefinitely as long as this object is around, not not updated and recreated every single frame.
So, now that we have that time, we need to actually use it.
And to use it, we're going to modify the if statement on line 26.
Remember, this statement checks to see if the player still holding down the fire button.
And if so, it runs the code on the next line 27 that sets our vertical to five so that we go upward.
What we want to do though is check to see if they're holding the button and if it's not past the jump end time.
So if the current time is not greater than or past or beyond the jump end time and we can do that in an if statement by adding a double amperand after the first condition.
So our first condition is this input.get get button fire one all the way up to the ending parenthesy right there that middle right in between them.
So we'll just add a space between the two parenthesis and add two amperands shift 7 shift 7 and we'll check to see if jump end time is greater than time dot time.
So, if jump end time is sometime in the future, any time up to 1 second from when we initially set it, then we'll allow our player to continue jumping.
If that's not the case, so say jump end time is at 1 and our current game time is at two, then well, we can't jump because we've already started falling.
We should have landed.
Let's take a look at that in practice and see how this actually works.
So, we'll save S to get rid of that star.
Minimize our window.
go back into Unity and then press play.
We should expect to see that we can jump up and then start to fall down automatically.
We can still click and spam click all the way up if we want.
We haven't stopped that, but my maximum jump should now be about 1 second.
There we go.
I click and hold and I fall after about a second.
Now that that looks good, let's go modify it a little bit and make that jump half as high.
So, I'm going to go back to our code.
And when we modify our jump end time or set our jump end time here on line 24, we're adding one to the current time so that we can jump for up to 1 second into the future.
Let's make this half a second.
To do half a second, we just need to put a value that's half of one or 0.5.
Whoops.
Got to get it on the right spot on my keyboard.
0.5.
Get my semicolon there.
And notice that we've got a little error here.
What it's actually telling us is that this 0.5 is a different data type.
It's a double and not a float and jump end time wants a float.
It's nothing that you really need to worry too much about.
U we'll talk more about data types and numbers later.
You just need to know that when you see this, you need to add an F just so that it knows that you want this to be a 0.5 that's a float, not the 0.5 that's not a float, so that it can actually work.
So if you see that error again, remember, just try adding that F to your zero.
We'll save, get rid of the star, minimize, and let's go see if our jump is now cut in half.
That's what you should expect to see.
So, hit play and we hold the button.
And look at that.
Now, I'm jumping.
I would say about a reasonable height.
So, let's stop playing, go back into plastic SCM, and commit our change.
say that we added a maximum jump time to the player and we'll check in our changes.
Now, it's time for us to learn a little bit more about variables.
What we're going to do is modify our player so that we don't have to go into the code and change things when we want to modify how long the player can jump or even how fast the player moves.
We're going to make some variables that are these fields that we talked about, but we're going to make them available to us at runtime in the inspector.
It might sound like a lot.
It might sound simple.
Don't worry, it is simple.
Let's start by opening up our player script.
This time, I'll double click on our player.
Actually, I'm going to stop playing first.
Actually, I'm not in play mode.
Double click on our player.
And I'm going to find our jump code.
So right here where we do the jump, we set our jump velocity to five or we set our vertical velocity to five, which is our how high we are f how fast we want to jump.
And by the way, if you're wondering what that five is, that five actually represents meters/s.
So we're jumping up at 5 m/s.
Imagine that the game is scaled to one meter um units.
So each block that we move over is 1 meter and we're going to jump up five of those per second.
That's what that is.
So we need to make this variable so that we can adjust this without having to come into the code and change it over and over.
Same with this maximum jump time.
We had to go in and change this by putting a 0.5 instead of a one.
Let's say I want that to be variable as well.
Well, to do that, we're going to create a new field to I'm going to delete my five here.
So, I've got my cursor right at the beginning of the five.
I'll hit delete.
We're going to create a new field, and I'm going to call this jump velocity.
Since it's going to be a member field that's going to be stored up at the top like this, I'm going to put my underscore there.
Again, this is more of a syntax that I just prefer.
It's not required.
You don't have to have an underscore there.
Sometimes you'll see an underscore.
Sometimes you'll see an M with an underscore on some really old stuff.
And sometimes you'll see absolutely nothing indicating it.
I just like to have something there indicating it that it's not part of this me member or this method here.
It's not a variable like this horizontal.
It's something that's stored at the class level.
I'm going to give this the name underscore jump velocity.
There we go.
V E L O CI TY.
And then I'll hit alt enter.
And I'm going to generate a field for it just like I did before.
Now, one cool trick that I can use is hitting F12 on my keyboard to go right up to that definition.
F12 is the go to definition hotkey and it'll take you right to wherever the thing is defined.
So here I have my jump velocity, but it's not set to anything.
It's not set to that five.
And right now if I save, it's not modifiable in the editor in the inspector.
What I need to do is take this private keyword.
I'm just going to double click on it.
Or actually, let's go to the front of it.
We'll just leftclick it right at the front.
And we'll add a square brace.
This is the key right next to P on my keyboard.
and we're going to add the word serialize field and then a closing brace the key right next to that other one.
Now, make sure that you spelled it right.
There's no D.
It's not serialized.
It's serialize field.
And then there should be the braces around it.
It should light up.
You can hit save with control S.
Go back into Unity.
And now you should see a jump velocity on your player.
If you don't see that, make sure that you've selected the alien.
Don't be on the grass or the light or something.
Go to the alien.
Go find your player script.
If it's collapsed like this, expand it out and then find the jump velocity.
Also, if you have too many things expanded, it could be way down at the bottom.
Just collapse the other stuff.
So, we've got a jump velocity right now that is a zero.
So, the default value right now is zero.
And I don't like that.
So, let's go back to our player script and give it a better default.
We had a value of five before.
So, right at the end of jump velocity before the semicolon, we'll add an equals and we'll put in a five here.
By the way, the semicolon is always the indicator for the end of a line or a command.
We don't have it when we have braces.
So, you're not going to see semicolon at the end of a brace, but you do see it at the end of every variable definition and at the end of every line that's executed.
Not at the end of a method with the braces, but at the end of everything else pretty much.
Let's save.
And often if you see an error like this, say I delete that, this little expected semicolon.
Look, if I put my mouse over it, you'll see it says CS 1002 semicolon expected.
Ignore the part above it, the readonly strruct part.
You don't need that.
That part's a little confusing, but it's telling you right there it needs a semicolon.
So, let's go add a semicolon.
Save again.
And it should work.
We should now have a default value of five showing up here, unless we've modified that value already.
Let's see.
Did it show up? Oh, no.
It didn't actually show up.
That's okay.
So, if it doesn't show our default, we can rightclick and we can choose reset.
That'll reset to the default.
Now, you don't want to do that later on once you've set up a whole bunch of stuff because it's going to reset everything to defaults, but right now there's really nothing on there except for our jump velocity.
So, let's play and see how this works.
I'll hit the play button.
I haven't saved, but that's okay.
I probably should have, but it'll be fine as long as I don't crash.
I should be able to jump.
There we go.
And I jump to about halfway up my screen.
Let's change this jump velocity to 10.
So, I jump 10 meters per second instead.
And then I'll jump.
And look at that.
I now jump way above my screen.
Let's change it down to one.
And you can see that I have a very slow, very small jump.
Now, I like the value of five for now.
So, I think I'm going to go back to five and just leave it at that.
But we now have the ability to modify it completely.
Let's continue on and make it so that we can modify the jump duration as well.
We'll go back to the player script.
And just like we did the jump velocity, we're gonna do the same kind thing for our jump duration.
We have this 0.5 and we're going to need to figure out a way to make a variable that controls how long this player can jump.
In fact, what I'd like to do now is present that to you as a mini challenge.
Don't worry if you get lost.
I'll show you how to do it in a moment.
But my goal for you is that you go through this process and create a jump duration variable.
see if you can create it yourself and then continue on and I'll show you the process to do it in case you got lost or had any problems or questions.
So, go ahead and give that a try now.
All right, it's solution time.
Let's change this 0.5 and put in a variable.
Hopefully, you've found a way to do this by just putting underscore jump duration or something similar and then hitting alt enter and generating a field.
Then I hit F12 to go to that field.
Hit home to go to the beginning of the row there.
And then put in my square brace and do serialize field.
There we go.
I'll save with S.
Oh, and let's give it a default time.
Right now I have it at 0.5 seconds.
So I'm going to add in a 0.5F right there.
We'll save one more time.
Minimize the code editor and jump back into Unity.
And I should now see a 0.5 value and my jump velocity.
There we I've got a jump duration and a jump velocity.
Let's try jumping and see if it actually works.
So, we jump and I go about half the way up.
Let's change that jump duration to 0.25.
Try jumping.
And yep, I jump quite a bit shorter.
And if I change it up to one, I can jump for a very long time.
All right, I now have two variables that I can modify and see how I like things and get them to the levels that I want them at.
There are a lot of different ways that you can use these and we'll be talking about them and using them in different ways in the future.
But just remember that if you want to make a field modifiable, you want to have a variable that you can modify in the inspector.
The key thing you need to use is this serialized field attribute.
There is one other way to do it.
There is an alternative way to do it, which is to make this public instead of private.
We'll talk about what that means later, but it's not the way that I would recommend doing it.
You can replace this right here with the word public.
Save and it's going to work exactly the same.
Everything will work.
You'll have no problems except that this jump velocity could get messed up later.
And I'll talk about how that happens in a later lesson because it's a slightly more advanced topic.
For now, I'm going to hit control-z, save, and then go back into plastic and commit my changes.
So, we've added two variables, a jump velocity and a jump duration variable.
also say added jump velocity and duration variables to the player and commit or check in.
The next change we're going to make is going to require us to take a deeper look into the Unity physics system.
Right now, we can jump unlimited numbers of times while we're flying around in the air.
There's nothing really stopping us from just flying indefinitely.
Now, I want to change that.
That's more like a swimming mechanic.
I want it to be so that we can only jump when we're on the ground or when we've decided that we want to let the player jump.
Maybe it's off of a wall.
Maybe there's a double jump.
But for now, only when they're landed on the ground, not this weird state where I can just keep jumping indefinitely.
To do that, we're going to need to figure out when the player is on the ground.
Let's stop playing and let's go to the scene view real quick.
So, here I am at my scene view and I've got my alien selected.
I'm going to double click on him and then zoom out just enough so that I can see the ground.
Now, when I play my game and I let my character fall down, let let's see what happens.
I'm going to take the game view.
I'll drag it down here to the bottom so it's kind of out of the way.
Press play and watch as the player falls down.
So, he falls down and he kind of lands there.
And I've got, you know, him right above the the actual ground.
I need to determine how how to tell if he's kind of on the ground or I need to find a way to tell if he's on the ground.
And there are a few different options for this.
The way that works the best though, the thing that I found to be the most useful is to do what we call ray casting, which means that we'll do a little check.
We'll add essentially a little laser right down here at the bottom of this character and shoot it down and see if there's ground underneath him or if there's not ground underneath him.
And if there is ground underneath him, if he's like very close to the ground, then we'll allow him to jump.
If there isn't, then we won't allow him to jump.
Now, to see this or to get this working, I like to visualize it first.
So, I like to open up my Let's stop playing, open up my player script, and add in some code to draw some cool gizmos so that I can see what I'm doing and kind of understand it quite a bit better.
To do that, we're going to find our start method.
And I'm actually just going to delete this first.
We'll take lines 11 through 15 and just hit delete because we haven't needed our start method and it's just kind of sitting there taking up five lines and getting in the way.
So, I'm going to delete them.
My code should now look like this.
I've just got my fields up top, my floats, my three floats, and then I've got my update method and then my closing braces.
Make sure that everything matches before you start.
And then right here on line 11, let's add an ondraw gizmos.
Now, notice that I didn't capitalize it.
That's because I know it's going to autocomplete and I'm just going to hit enter and it's going to capitalize for me.
So, it automatically created an ondraw gizmos.
It's got the private void part right at the beginning and the parenthesis.
I don't actually need this private keyword.
So, I'm just going to double click on it and hit delete twice just to get rid of it.
The void method doesn't have it.
Um, ondraw gizmos doesn't have it.
It doesn't need to have it either.
The reason for that is that private is the default.
It's like uh adding a special decoration to say that it's already the thing that it is.
So, we don't need the private keyword there.
It's already private by default.
The alternative is public and we don't need this to be public.
We'll talk a lot more about public and private later once we get into some scenarios where it actually makes sense.
In our ondraw gizmos method, we have the ability to draw gizmos on the screen or in the scene view.
Now, if you're forgetting what those are, don't worry.
We'll come back into Unity and take a look.
Remember this little world that toggles all the gizmos on and off? That's that these little icons, the colliders, and other things.
This is going to be our own custom one.
So, let's go back to the player.
Let's draw a simple line.
First, we'll say gizmos.draw line, and we're going to draw it from vector 3.0 to vector 3.1.
And we'll add the semicolon to the end.
Let's go back into Unity and see what that does.
We should expect to see a line right around the center of our world.
There we go.
Going from 0 0 to one one.
So, this is now actually in 3D, too.
If I go into the 3D view, you'll see that it's actually moving kind of over there backwards a little bit.
If we go back to 2D, though, it looks pretty flat.
So, this draws a line from one point to another point.
What I want to do is draw a line from the feet of my character just downward a little bit.
so I can see where I'm checking for the ground.
To do that, we'll go back to our player.
And we need to figure out where the feet of our player are.
To get the feet of our player, we're actually going to use the sprite renderer component.
Remember, that's the component right here that's drawing our sprite.
This thing knows where the bottom of the sprite is.
So, we can use that value or use the sprite renderer to get that value and then pass it into our gizmo system.
So, let's go back into the code.
And the first thing I want to do is calculate where the bottom of our character is.
And to do that, we're going to need to use the sprite renderer component.
Remember how we got a component before on line 21 using the get component method.
We're going to do the same thing here on line 13.
We're going to add in a new line for our line 13.
And we're going to say sprite renderer.
And let's call this sprite renderer with a lowercase s.
Notice the casing here.
We've got an uppercase sprite renderer and a lowercase sprite renderer.
The uppercase one is telling us that this is the definition or the type, the class definition, the sprite renderer type.
We're going to say that whatever comes after this is going to be a sprite renderer.
And then we're going to name it the exact same thing, but it can't have the the same casing.
We want to have a lowercase casing or what we call Pascal case.
So it starts with a lowercase S and then we add in the capital R there so that it's easier to read.
I mean if we did it like this sprite renderer it would just be harder to read.
That's why we use Pascal case or camelc case not Pascal case and it's much easier to read.
This is C Pascal case with capital S.
This is camelc case with the lowercase S.
That's the difference between the two of them.
All right.
So sprite renderer sprite renderer equals.
And then look at that.
It already knows what I want.
I'm just going to hit tab and let it fill it in.
Get component sprite renderer.
So that's going to get our renderer.
And the renderer has a couple of unique or interesting fields on it.
The one that we care about right now is the bounds.
So we can get the bounds of the sprite renderer to tell us where the top, the bottom, the left, and the right are.
So let's go back into our code and we'll do that by saying let's let's actually keep this off as a y value.
So say float bottom bottom y equals and we'll use the sprite rendererbounds.extense.y.
Now let's use this bottom and this position in our draw line.
To do that, let's actually create a vector 2.
We'll say vector 2 origin and we'll make it equal to a new vector 2.
And we're going to use our characters position.
So we'll say transform.position.x.
And then for the y, we'll use transform.position.y.
But we're going to subtract out that w that bottom y or the extents.
So we'll say minus bottom y.
Then we'll add a semicolon here.
And then on our draw get draw line code, we'll change it from going to zero or starting at zero to starting at origin.
And for our second value here after the comma, I'm just moving around using the arrows.
By the way, if you use control in the arrows, you can actually bounce around word by word.
Hold down shift and you can bounce over here and select the word.
So I'm going to select that vector 3.1 and replace it with origin plus.
And now what I want to do is do a line that goes downward just a little bit.
So I'm going to use a vector 2 down times 0.1f which is going to give me a downward vector that's one/10enth of a meter.
Remember vector 2 down would be down one unit or 1 meter time 01 is 110th.
So it's going to take us down one/10enth of a meter.
So, I should get a line going from the bottom of my character down one/10enth of a meter.
Now, one last thing I want to do is make this line red.
Let's do it right before we draw it.
Let's go up ahead up one line.
Add a line on 16 and say gizmoscolor equals color with a capital C dot red with a lowercase R.
We'll save.
Get rid of that little star.
Jump back over to Unity.
And let's see if we have a little red line pop out of our character once it finishes reloading.
Here it goes.
And look at that.
We've got a little red line down there.
So, we haven't used this to do anything except for draw a red line.
But watch when I move my character around.
Oh, accidentally added a child object there.
Let's move this guy around.
And look, we've got a red line following him around.
So, that's perfect.
That's kind of what I wanted to see.
So now what we want to do is make it so that when our character's red line is overlapping with the ground, we can jump.
If it's not overlapping with the ground, we can't.
By the way, I'm just clicking and dragging him, moving him around.
Remember that's W on the keyboard to get into move mode.
Or you can click the move tool right here.
You could be on a different tool like the panning tool or the rotating tool or something else.
Just go to the move tool with W and move him around.
So so far so good.
We've got our character drawing the line to show us where he's checking to see if he's on the ground.
And I think that's good for this lesson.
So, let's save.
Go into plastic SCM and say that we added a grounding gizmo.
We'll talk about what grounding means in just a moment.
Added grounding gizmo and check in our changes.
Now that we've visualized where we want to do our physics checking, it's time to do the actual code for physics checking.
And again, this might seem complicated.
It's going to seem simple by the end of this course.
Let's open up our player script one more time.
And we're going to go down to our update method.
In our update method, we want to check to see if the player is touching the ground or if they're not touching the ground.
And we want to do that by using this little laser that we've drawn in the gizmos.
But unfortunately, the gizmos are just a debugging visualization.
They don't actually give us any information back and the gizmo code can't check to see if we're touching the ground or anything.
It just gives us an idea of what we're looking at.
And as long as it matches up with our physics code, then it'll tell us kind of what's going on with our physics code.
So, what we're going to do is use the physics 2D ray casting system.
And if you want to take a look at the documentation for it, the Unity page has pretty big documentation that goes over a lot of the different parameters that are available and has some example stuff, but I feel like the examples a little bit more complicated than what we need right now.
Let's go back to our code now.
And before we make the physics code, let's do one little change to our gizmos code.
Right here on line 15, we calculate our origin by using our position and then this bottom y variable.
The bottom y variable is assigned right above on line 14, which is actually just the extents.y.
Let's replace bottom y here with just extense.y.
So we can get rid of this variable.
And I'll explain why we're doing this in just a moment.
But first, we'll copy.
So I'll select this whole sprite renderer.bounds.extense.y.
control or command C or rightclick and hit copy.
And then go to bottom Y over here.
Just double click on it and controlV or commandV to paste over it.
I'll zoom out with the mouse wheel here.
So it's control and the mouse wheel.
Remember this little slider down here.
So I guess it's like a drop down.
Go to 100% or whatever.
Zoom back in a little bit.
But now we've got this origin calculated without this extra line here on 14.
I'm going to go to line 14 anywhere on it.
Hold shift and hit delete.
And then I'll explain why we did that.
We're actually going to reuse this origin right here down below in our update.
And if we have two lines of code that we have to copy, then we have two lines of code that we need to update and double the chance of making mistakes.
If we cut it down to a single line here that does everything we need, and we don't need that extra variable, which really wasn't very useful for us, then this will just kind of work.
So now we're going to take line 14 and we're going to copy it.
We're going to hit Ctrl + C and then we'll go down to line 21.
Hit enter.
Enter.
I'm going to go up.
I just wanted a little bit of space there.
And then hit Ctrl +V.
We're going to get an error here.
Take a look at it and see if you can spot the error.
You should be able to tell by the little underlined squiggly that there's a problem here.
It's saying, "Hey, this sprite renderer does not exist in the current context." And why is that? Well, if we look at it up here on line 13, we're finding the sprite renderer, but that's inside of our ondraw gizmos method.
Down here on line 22, we're inside of the update method.
Since this variable is defined inside of a method, it's not a member variable.
It's not available to everything in the class, only to this method.
So, our update method can't see the sprite renderer.
Now, our jump duration and jump velocity, jump end time, these variables are all defined outside of the scope of a method.
So, they're all accessible outside of there.
So, what we could do is make it so that our sprite renderer is available outside of the scope.
There are a couple issues with that, specifically with how on draw gizmos works, or we could alternatively just get the sprite renderer down and update.
And that's where we're going to start.
and we'll talk about caching and some performance benefits of other ways we can do it a little bit later on.
So let's take line 13, select the entire line, copy it with control or command C.
Go up above line 22 right here on 21 after the brace.
Enter.
Get a new line and controlV to paste.
The error should go away.
And now we have an origin.
We haven't done anything with it yet, but we've got the origin in our update method.
Let's add a new line.
And so I'll click at the end of line 23, add one more line.
And in here, let's do our raycast.
We're going to say var hit equals.
And this is where we're going to tie into the physics system.
Physics physics 2D.
Got to get that 2D part in there.
Dot raycast.
Then we'll do an open parenthesis.
And the first variable that we need to give it is the origin.
So that's where we're going to start.
And notice that I name my variables to kind of match.
That's just out of habit and out of experience.
I know that origin is what it kind of expects and that's the start of a ray or the origin of the array.
So I name my variables to match.
It's not something magic.
It doesn't have to match but it does because of habit habit mostly.
So our first variable is the origin.
The next variable I hit comma and space is the direction.
And the direction that we want to go in is downward.
To get down, we'll do vector 2 down.
Next, we need another parameter.
So, right now, it would allow me to add a semicolon and be done.
But that's not what I want.
That would give me a ray that goes from my origin down infinitely forever.
I want to add another comma here after the down.
I want to add a maximum distance.
And I want to go that 0.1 m or that tenth of a meter.
The same variable that I've got right here.
So, 0.1f or the same value.
It's not really a variable.
It's more of a a constant.
And the last thing that I want to do is check for the ground.
And to do that, it's a little bit more complicated.
So, we'll wait until the next um the next section.
We'll get into the the layers, but there actually is another layer mask here that we'll use shortly after.
For now, though, we're just going to go with these three parameters.
And then we'll go to the next line and we'll say if and then open parenthesis hit.c collider and then closing parenthesis.
So what this is going to tell us is if we hit an object and that object or we hit something and there's an object there.
If that's true then hit collider will just basically return back true.
It's actually going to give us back the collider the instance of it.
But this variable check, this if check is going to be true.
If that thing exists and if there was no collider, if we didn't hit anything with our laser beam, then it's going to return back false.
So if we did hit the something with it, then we want to set a variable to true.
And we're going to set a member variable, something that we can see in the inspector and that we can use later on.
Let's call that is grounded with a capital I.
Okay, so we'll say is grounded equals true and a semicolon.
Now we're going to hit enter.
Don't worry about that error.
We're going to address it in just a moment.
Next, we're going to write the word else.
E L S E, which is also going to be purple.
And then we'll hit enter one more time.
We'll say is grounded equals false.
Now, if your editor added some braces around things like this, don't worry.
You can just delete those.
You can leave them in there, but if they're the wrong way, then you don't want to have them there.
So, you can just hit shift delete.
And shift delete get rid of those braces.
Now, what are we going to do about this is grounded? And what does this else statement mean? Well, the else statement means that if it collider is true, well, we'll set is grounded to true, but if collider is not true, so otherwise or if else, not if else, but else, then is grounded will be set to false.
So, we're essentially setting grounded to true if we've touched something with our laser and setting it to false if we haven't.
But is grounded doesn't exist.
So, we need to create it.
And to create it, I'll select it, hit alt enter, and we can generate a field, a property, a local, or a parameter.
The one that I want to choose is a field.
We're going to generate a field right up at the top.
And it's going to give us a private bool named is grounded.
And I'm going to change this private and make it public.
We'll save.
and then look for errors.
Let's go take a look at the entire script.
This is all of the script.
This should show us everything.
Let's jump back into Unity.
And now if we go select our player, we should see that is grounded field.
Remember that I said that public fields and serialized fields both show up in the inspector, but public ones you want to use a little bit differently.
Let's go check it out.
We should see our public field showing up any second now.
as soon as it finishes compiling our is grounded.
Let's press play.
There we go.
And I fall down.
When I'm on the ground, the is grounded is checked, which means true.
And when I jump in the air, it's not checked.
As soon as I hit the ground, it's true.
And checked.
As soon as I jump off the ground, it's not checked.
Pretty cool, right? Now, we can tell whether or not our player is grounded.
The last thing that we need to do for our jump modification then is go down to the jump code where we check to see if they've pressed the button down.
And we just need to check if uh they're grounded as well.
So if they're not grounded, then we can't allow them to continue to to fly up and or to start a jump, not to fly up.
We don't want to stop them from continuing a jump, just from starting a jump.
So here on line 36, if they pressed fire one and so remember we got to add the double amperand in between the two parentheses and is grounded.
So what that's going to say is if they're grounded on the ground and they've pressed the button, they can start the jump.
Otherwise, this will never return true.
The and means that both statements have to be true.
Let's go jump back into Unity.
I'm going to press play.
Okay.
And now I should only be able to jump if I'm on the ground.
Jump.
Oh, look at that.
I can only jump when I'm on the ground.
I can hold a jump, but I can't uh or I can kind of continue a jump.
So, watch.
If I'm already jumping, I can I can continue it, but I can't start a new jump.
So, I can't get to the top and and keep jumping.
That's looking pretty good.
We've got our raycast working.
We've got our grounding working.
I think it's time for us to go into plastic and commit our changes.
So here we've added a grounding check for our jump to the player.
So added grounding or let's say added is grounded to the player and made the jump check for grounding state.
And then we'll check in.
Now that we can jump, let's give our player something to jump on and stabilize things just a little bit.
Notice that when we jump around, we kind of tip over and fall to the side.
That's something that we can actually control.
First, let's reproduce it.
Let's jump.
Okay, I jump, jump, jump.
And if I fall, I kind of start rolling to the side.
That's actually controlled in the rigid body.
If we expand out our rigid body component, and remember if you don't see this, you can just select your alien over here on the left in the hierarchy and then find your rigid body and expand it out and then expand out the constraints section.
Notice the freeze rotation option.
If I click this now, well, it's not perfect because I'll stay frozen upside down.
That's not really what I want.
But if I stop playing, let that uncheck itself automatically, which happens.
All of your changes that you make while you're playing are going to get undone.
So don't make changes while you're playing and expect them to stay around.
Now that it's not playing though, I can freeze rotation by clicking that box, that little Z there.
Save my scene with Ctrl S.
Get rid of the star.
Press play.
And I should stop tipping over.
Let's see if that's the case.
So, do I tip? Nope.
No more tipping.
Looking good.
So, the tipping is fixed.
What about giving us something to jump onto? Well, let's zoom out a little bit and let's select our ground platform.
We've got this nice giant ground platform that we know we can walk on.
Let's just make another one of them.
We've got a couple ways that we could do that.
We could go down to our project.
We could go find our ground, our grass, and find the grass um where was it? Grass uh mid right here at the bottom.
And I could drag that out into the scene view.
Take it, drag it out, and recreate it.
Or I can go to my grass mid object here and just hit control or command and D.
That's going to duplicate it.
Now I have two of them.
But you can't tell I have two of them because they're stacked on top of each other.
Let's move the selected one right here.
This one that's already got selected automatically.
I'm going to hold control, hit the click the green arrow, and drag it up.
And look at that.
I've got two pieces of ground.
I'm going to drag this up to about here so that it's at 0 0 and zero.
And then I'm going to shrink it down.
It's way too large.
I don't want this thing stretched out nearly that long.
So I'm going to select the sprite renderer and expand it out.
And remember that tiling width that we had set to 20 before.
I'm going to set this one down to three.
Oops.
Let's hit num lock and a three.
So now I've got this nice small block here in the center.
I'm going to save my scene.
press the play button and see if I can jump up onto that platform or not.
Might be a little bit too high.
Let's see.
Can I make it? Oh, not quite.
So, I can't quite make that jump.
So, I've got a couple options.
I can either move that platform down or increase the player's jump height.
Remember, we can modify that jump height by going over here to the player, collapse down some of these other components.
Look at the player component, and just change that jump velocity to six.
So, I jump up six meters or six blocks per second.
And that'll probably cover it so I can just about make that jump.
It's not quite the feeling that I want, though.
So, I'm going to stop playing and instead go grab my block here, my grass mid, and I'll move the Y value down to negative 1.
I got a couple ways I could do that.
Hold control and drag the green down or just type it in here.
I know I want a negative one there.
Bring it down to about the height that I want.
Let's press play one more time.
Make sure that I can jump on it.
Oops.
Let's see.
Can I make that jump? Just barely.
Oh, almost.
The jump is not quite making it.
And I'm getting a little bit stuck on the edge.
Let's see.
I'm going to give myself a tiny little bit more jump power.
So, we'll go up to our jump velocity to maybe a 5.5.
We'll press play one more time.
And this should get me enough power to jump up onto there.
But I still move so slow that it's it's very very difficult to kind of get around.
So let's stop playing and do one final change.
Let's go back to our player.
And when we're moving our player, instead of just going from zero or negative one to one for our speed and our velocity on the horizontal axis, let's give our player some actual speed control.
And in fact, let's give ourselves some speed control in the inspector.
Let's go up and do this a slightly different way than we've done it in the past.
So, scroll to the top and I'm going to go find my jump velocity line right here, line 8.
I'm going to hit control D to duplicate that line or command D if you're on a Mac.
And I'm going to rename this first one up here to um move velocity or let's call this horizontal horizontal velocity.
So, we now have a horizontal velocity of five.
I think I want to change this to about a three for the default though.
I'll copy horizontal velocity by double clicking on it.
Ctrl + C.
And then scroll down to the part where we set our velocity on line 43.
Right now, we set the velocity of our character to the horizontal value, which we've read directly from the inputs, and the vertical value that we've done some actual calculation on.
So all we need to do now is calculate something for our horizontal so that it is modified by our speed variable.
To do that we can just say horizontal times our speed or right here on line 42 and say horizontal star equals and then paste in our horizontal velocity.
Star equals means that it will multiply itself by this value.
So if we do a value star equals another one, it's going to take that value and then multiply itself by the other one.
So if we have a horizontal of one, it's going to multiply by that three and it's going to give us a three.
If we have a negative one, it's going to give us a negative three.
If we have a horizontal of.5, if I'm pushing just halfway on my little controller here, then we're going to get a value of.5 * 3, which is 1.5.
So this is how we can give ourselves some nice speed controls.
Let's save.
jump over to Unity and try them out.
We should now be able to control how fast our player moves left and right, how far they jump or how fast they jump, and how long they jump for.
We'll press play.
Oh, there we go.
We've got our horizontal velocity variable.
Let's hit play and see if it works.
So, now I can see that I'm moving quite a bit faster.
I still get stuck, but that's okay.
That's part of the collision stuff.
We're going to talk about that in a moment.
We can jump around and yep, I can make it up up and probably onto another platform.
I'll stop playing.
I'm going to go select this little small platform, duplicate it one more time, and grab it right here, holding control, and just move one up to right about here.
5.5 and two, and then save again.
And now I should be able to make a double kind of jump across those two.
Go ahead and play around a little bit with placing platforms.
Don't put too many of them down.
Two or three is good.
Um, we're going to talk about a couple more things before we dive into lots of platform placement.
You don't want to put down a whole bunch and spend a lot of time on them because you're going to end up wanting to delete them.
Also, notice that we can kind of jump off the camera right now.
We can disappear and get away relatively easily.
That's something that we'll be addressing soon.
But for now, just play with your variables.
Play with your horizontal velocity.
Try moving it like a six.
Oh, see it starts to get a little bit faster.
I kind of like a a six a little bit more than the three.
But you can play around.
see what you like.
Um, come up with some variables and then reset back to the defaults.
So, let's go to three, five.
Let's put that back at a five.
And the jump duration of 5.5.
I'll just hit the reset button.
And then we'll go into plastic and commit our changes.
Say that we added velocity controls and new platforms.
And checking our changes.
It's time for us to start playing with graphics.
Specifically, we're going to add a jump graphic to our character for when we're jumping so our player can tell when they're jumping and we can debug things a lot easier and figure out what we're doing as well.
I think it's an easy, nice thing to get in.
And it's going to show us quite a few interesting concepts.
The first thing that we want to do is take a look at our sprite renderer.
If I expand out the sprite renderer, it has a few fields on it.
It's got the sprite, a color that allows me to tint it if I want to change the color.
It kind of not the really the way that you want to change the color of your sprite most of the time, but you can modify it there.
You got a flip option that allows us to flip it upside down or left and right, which is something we'll get into shortly.
And then a couple other options like the draw mode for tiling that we've already looked at.
What we want to do though is change the sprite.
So, if we select the sprite by clicking on it, we can see all of our different alien sprites.
I'm going to hold control and use the mouse wheel.
You can also use this slider right here to get a big view of all of our sprites.
And what I want is our jump sprite to appear when we're jumping.
So, let's find our jump sprite.
Click and drag it right in here.
And there we go.
We can see our jump sprite is there.
But if I press play now, we're just going to have our jump sprite on permanently.
And obviously, I can't jump and then click and drag the sprite out there uh at runtime.
That would probably be pretty hard if I was trying to like Oh, here now I'm in climbing.
Oh, now I just took a hit.
I got to drag him out.
So, that's not what we're going to do.
Instead, we're going to stop playing.
We're going to change it back to being the default one, which I believe was named front uh alien blue front.
So, we'll drag that back into the sprite so he's got that default on.
And we're going to write a little bit of code here that can change this sprite dynamically for us.
Let's open up our player script.
And first things first, at the top, we're going to need to get a reference to a sprite.
We're going to need to know what sprite we want to put in.
So, we're going to add another serialized field.
I'm going to do that right here after line 10.
We'll add a serialized field.
In fact, I'll just let that autocomplete for me.
But instead of it being a private float, we're going to add a sprite.
And we're going to call this underscore jump sprite with a semicolon at the end.
And so we have a serialized field sprite jump sprite.
Now notice that we don't have the private keyword here.
That's because this private keyword is redundant and just doesn't need to be here.
I could put it there, but I don't need it.
In fact, because I don't need it, I'm going to delete all three of these other ones.
And that fourth one.
Let's delete the first one by double clicking on it.
Hit delete and delete.
Now for these other three, I can do it a couple different ways, but check out this cool trick.
If you hold down alt, click.
So I've got my cursor here already.
So, let's click the cursor there, then hold down alt, click and drag over the private keywords.
I can block select them, and then just hit delete, and hit delete one more time, and I'm good to go.
Now, make sure that you click away so that everything else you type in the future doesn't go to all three of those lines.
It's a neat little trick, though, to get rid of things or to past things in when you want to kind of batch update.
So, now we have our jump sprite.
Let's save, go back into Unity, see what that looks like, and then figure out how we're going to hook it up and write the code for it in a moment.
So, we'll minimize the code.
Go make sure our alien is selected and our player should show up in the inspector with a new field, the jump sprite option.
Now, we just need to go find our sprite.
And I can click this little circle to pop up every sprite in the game.
That's probably well actually surprisingly it's finding the one that I want right here.
Jump blue.
But if you find that there are too many, you can always just search.
So, I can just search for jump and find my blue jump right here and just double click on it.
Notice there are two of them.
I want the one that matches.
I used the fulls size one.
So, I'm going to use the fulls size one here.
I'm going to pick the one that's 128x 256, not the one that's 135x 191.
I just got to make sure that I'm using the same set of sprites.
So, I'll double click on that one.
Now, I've got my sprite here, and I need to go into the code and make it actually set it or switch it at runtime when we're playing or when we're jumping.
So, to do that, we're going to go back to our player script, and then let's find the spot where we set our grounding.
So is grounded is equal true or is grounded is equal to false.
And we essentially want to set the sprite based on whether or not is ground were grounded or not.
We have a couple ways that we could do this.
The first way that we could do it and the way that we're going to start is by adding some curly braces.
So right after the hit if hit.colider, we're going to add a curly brace on a new line.
And then after the is grounded is true, going to add another curly brace.
So what that's going to do is allow me to write more than one statement after this if.
So the if check before was only running one line of code.
Now it'll run all of the code that's inside of these braces.
Right now that's one line, but let's add another line.
So if they are on the ground, we want to set our sprite to its default sprite value.
So let's say sprite renderer.sprite equals and we need a our default sprite.
We don't have that yet.
So, let's just say underscore default sprite.
We'll add that in a moment.
We'll fix that error up.
Now, let's go down to our else section.
After the word else, we'll add a new line and again a squiggly brace.
Now, I'm going to delete this other closing squiggly brace here because I want to go down two lines and read it.
I just wanted to move that so that the is grounded was inside of the two squiggly braces.
After that is grounded check or is grounded line being set, sorry.
We'll add a new line and we'll say sprite renderer.sprite equals jump sprite.
So, what's this doing? If we're on the ground, it's going to say is grounded is true or set is grounded to be equal to true and set our sprite to the default one, which we haven't figured out yet, but we're going to do that in a moment.
If we're not on the ground, it's going to set us to the jump sprite and set is grounded to false so that we can use that for our jump checks.
All right.
So, how are we going to get our default sprite? Well, first we need to create a field for it.
So, I'll select it and hit alt enter and let it generate a field.
Remember, I can hit F12 to go up here and see my field.
But this field doesn't have a value.
So, if I play right now, my character is going to disappear.
Let's try it out.
Let's save.
Go into Unity and press play.
And look at that.
Our player just totally disappeared.
The other interesting thing to note is that if I try to jump and have my player appear, it doesn't actually show back up.
And the reason for that, if we look at our little gizmo here, is that our sprite renderer no longer has an extent.
It no longer has a bottom.
So it doesn't have a bottom to draw the ground from it and thinks that the ground is at our center.
So we're going to have to make some small changes here.
That's so the first change that we're going to do is get the actual default sprite.
So we're going to stop playing.
We'll go back to our player script and we're going to do something called caching.
We're going to cache this default sprite when our object is created in or awakened or our level has started.
To do that, we're going to add in a new method, a new one of the Unity methods, one of the special ones that we get from the MonoBehavior class.
We're going to add two new lines here right above on gizmos.
And I'm going say void awake.
This is a special method that gets called at the start of the object's life.
So, at the start of our player's life, when this level first loads, this awake method will get called.
And what I want to do in the awake method is get the sprite that's already on our sprite renderer.
So, I'll say default sprite equals.
And now I've got to get my sprite renderer and get the comp get the sprite from it.
So, I'd say get component sprite renderer.sprite.
And this will get the sprite renderer.
Then get the sprite and save that off to this default sprite variable.
Let's save that and see if it works real quick.
Go back into Unity and we should be able to press play and see our sprite changing and our grounding continuing to work.
There we go.
So, we're on the ground.
We jump and it goes to a jump.
And as soon as we hit the ground, we're back to the ground sprite.
So far, I think it's looking pretty good.
But there is something there that you might have thought about or might have noticed, especially if you're experienced in development at all.
And that's that we're getting this sprite renderer component a lot.
And we could probably cache that too in awake.
While we're caching things, if we're going to get a component and it's something that we're going to get often when the update frame is every single frame of our game, so that's pretty often, then we should just cache that component.
So let's do that.
Let's take line 31 and I'm going to copy the entire line here.
Copy.
I'm going to put it up here on line 16 and paste.
I'm going to hit the home key to go to the beginning of the line and then delete out the sprite renderer by holding shift delete.
Oops, no, wrong key.
Sorry, Z.
Control delete.
I hit shift delete is the line.
Control delete is the word.
So, I got rid of that uppercase sprite renderer.
And then I'm going to add a underscore to the beginning of this.
So add shift and the minus to get my underscore.
I'll generate a field for it by hitting alt enter.
It's going to give us a nice field right up at the top right by the sprite.
And then we'll just start using this sprite renderer instead of all these get component sprite renderer calls.
So I'm going to copy sprite renderer onto my clipboard.
We'll take this line right here and this part right here on line 19, the git component call, and paste in the sprite renderer because we don't need to get it anymore.
We'll just use the one that we've already saved off.
And the reason for this, by the way, is that getting components is an expensive, slow thing to do.
Now, we're going to go down to the update method and just get rid of line 33.
And that's going to expose two errors that we've got the sprite renderer referenced now on line 33.
Oh, sorry, three errors and 38 and 43 that don't exist.
And that's because when I recreated this, I renamed it with an underscore.
So, we just need to add the underscore so that we're using that cached sprite renderer.
So, I'll go add the underscore to all three of them and we're good to go.
Now, if you're looking at this thinking, what about this big blaring on draw gizmos one? Why haven't we changed that? Shouldn't we use the sprite renderer? The answer to that is actually no.
And there's a very important special reason for this.
The way that Unity works, it has an object life cycle.
objects are created, they run their methods and then every frame they run another set of methods.
So they run the awake method, the start method, and some other ones.
They run their update, their gizmos, and a whole bunch of other ones.
And then if they're destroyed, they'll run a destroy method.
In fact, after this section, I recommend that you take a look at the Unity execution order documentation.
It's right here.
I'll make sure that it's linked and maybe even go print it out.
But I have a print out of this available for me pretty much at all times.
So I can look at it, see the order things are getting called in and where they are and get an idea of a lot of the methods that I occasionally forget about.
But it's important to know that this ondraw gizmos one doesn't necessarily mean that the awake has been called.
Even though it's after all of these other things, awake and start don't always get called um in edit mode.
It's kind of inconsistent.
Don't expect them to be there.
And it's okay to do that get component call in an ond draw gizmos.
Just expect to regrab everything in the gizmos most of the time.
All right, let's double check that code one more time and then let's go try this out.
Actually, we've got these private keywords here.
Let's go get rid of those two.
two.
two.
Just talked about those.
Do the batch update or the alt and drag to select and then delete them.
And then let's go look at the code one more time.
Here it all is.
It'll all be on the page as well.
But once it looks good, let's jump over to Unity.
Let's make sure we've saved and then try it out.
We should still have the exact same functionality.
We've just switched that sprite renderer over to be cached.
Assuming that we didn't mess anything up, our character should switch between our jump and grounded or idle front states.
So there he is.
He's grounded.
He's in the air.
And let's see if I can get up.
I don't think I can get up to that platform with my value of five.
Oh, there we go.
Going a little bit on my jump.
I made it.
So there we go.
Let's stop playing.
Go back into plastic.
And let's say that we've added a jump icon or jump graphic, not an icon, jump sprite to the player.
And check in.
Now that our player's jump sprit's working, I want to address something with the direction.
And by the way, if your player's jump sprite isn't working, just make sure that you've actually got it assigned, that you've got the right values assigned, and that you're using the correct collider type.
If you used something else, you're going to see weird results up until the point where we get to the actually switching of those things.
So, make sure that your everything matches and there's code always down below to copy if you need to grab that.
So, let's take a look at what we can do for our player to make them jump and face the right way.
Instead of always facing to the right, if I'm going left, I want them to face to the left.
Let's stop playing and we're going to open up our player script again.
And down here in the update, we're going to do something kind of different.
and interesting.
We're going to refactor and create a new method.
I want to have a method here that just deals with the sprite.
Right now, we have this update method, and it's feeling really, really large.
This is probably looking like a lot of code to some people, and to me, this is just a little bit more than I like to have in a method.
So, my update method shouldn't be this long.
I'd like to shrink it down.
So, what we're going to do is add a new method down here at the bottom.
And that method is going to update our sprite.
But we're going to do that by typing in the bottom of our update method.
So right here at the end of line 57, I'm going to hit enter.
And then I'm going to type update sprite open parenthesis close parenthesis and a semicolon.
I'll hit the home key to go to the beginning of the line so that my cursor is right at the beginning of update sprite.
Hit alt enter and hit generate method.
Now this gave me a private void method right below my update method.
So if I collapse my update method, you can see it's right here down below.
And this is just my own method.
This is a method that I've written that's not going to be called by Unity automatically.
It's not like on draw gizmos update and awake that are all special unity messages.
Notice that this says Unity message.
These are actually methods that are called by Unity from a messaging system that it uses.
So update sprite is not.
It's a method that I've created myself.
And right now, by default, all it does is throw an exception, which really just means put an error message into the log.
At least at least for this use case, that's all it means.
It'll drop an error into the log and do pretty much nothing else.
So, we'll break execution of our program.
But that's not really an important part right here based on where it's at.
So, we want to change this.
We don't want it to throw an exception, write an error, or do anything bad.
We'll delete that out.
And we're going to go into the update method.
and instead we're just going to figure out how we can take this sprite renderer stuff and move it into the update sprite.
So what I want is to check to see well first what I want to do is take these lines 39 and 44 out.
So I'm going to take line 39 I'm going to cut it with controll X and then I'm going to paste it down here into line 64.
I'm going to do the same with line 44 cut it with Ctrl X and paste it down here on line 65.
I know I want this stuff to happen here.
Right now, it doesn't make any sense.
It's going to set it to the first sprite and immediately set it to the second sprite.
We'll work on the logic for that in a moment.
The next thing I want to do is get rid of these braces because now I'm only doing one thing.
I'm going to get rid of these extra lines here to make it more obvious and add a space.
But I'm only doing one thing in my if and one thing in the else.
So, I don't need these braces.
They're just making my code a little bit bigger.
In fact, I'm making it quite a bit bigger.
It's making something that could be four lines into eight lines.
So, let's delete it with shift delete.
Go down to the closing brace there.
Shift delete.
Got to make sure that I get the closing brace.
If I have messed up braces, if I just delete one here, it's going to break everything.
Look, my update now thinks that this is the end of the update and my code is all ruined.
But if I shift delete and get rid of that extra extraneous uh closing brace, everything will work better.
All right, so our collider check is now shrunk back down, got rid of the braces, and our update sprite check or our update sprite method is ready to be worked on some more.
So, what do we want to do in here? Well, if we're jumping or if we're grounded, we want to use the default sprite.
So, we can just say if is grounded.
Look at that.
It autocomp completed for us.
And then we'll go down to the next line on line 62 and say else or 61.
So, now we've got that same logic recreated right here in our update sprite.
And this is starting to shrink down.
It's getting a little bit smaller.
We're not having to add more to it.
Let's hit the line 60 and hit the tab here to just indent that.
and hit the tab here to indent that as well.
Now, it's important to note that indentation and spacing doesn't really matter in C.
It's not like uh some other programming languages where it's very important, but it is important for your sanity and for being able to understand and read the code.
So, I want to make sure that my indentation is always pretty good or perfect ideally.
You don't want to have it wild and crazy like this.
And you got this thing over here that's way way harder to read.
And you can hold down control K and then hold down control and hit D and have it automatically format the entire document for you to fix the formatting up.
So if you have a hard time with that, hold control, hit K D while you're still holding control.
It'll fix that all up.
Now our update sprite method works and we've refactored and moved that code out.
But we still haven't adjusted the sprite to face the correct direction.
Now to change the direction, we need to use that flip X property.
Let's go back to Unity and take a real quick look at it.
Remember, we've got the flip X that switches the sprites, and it's kind of uh not showing us much because our front sprite doesn't have a much of a difference, but you can see the dots are switching which side they're on.
Our jump sprite, though, will be totally different.
So, we're going to want to modify that flip X.
Now, let's go down to the bottom of our update sprite.
And here, what we want to do is flip the sprite if they're moving off to the um left.
So if they're moving to the left, that means that the horizontal value is something negative.
Remember zero is if we're not touching it at all.
To the left is negative point whatever to negative one.
And to the right is positive all the way up to positive one.
So we want to check to see if the input is going negative.
And if so, we want to flip the sprite.
Otherwise, we want to maybe if the input's positive, we want to make sure that it's set to the right.
So how are we going to do that? Well, we could reread this input here, this axis stuff, or we could just kind of hold on to it, which I think is probably a better idea.
We just store this horizontal as a variable instead of trying to read it again.
So, to do that, we're going to delete this var keyword in front of horizontal and we're going to turn this into a field.
So, I'll hit alt enter and we'll hit generate field.
That's going to give us a field up top.
We'll hit F12.
And remember that in the way that I like to make my fields, I like to add an underscore to the front of it.
And this one doesn't have an underscore.
So I'm actually going to use a hotkey here.
Control-r, which just the same key twice.
Hit control R twice.
So control and hit R two times.
It'll bring up the rename.
F2 might be your hotkey as well.
Or you can right click and find the rename if it's something different.
But I'm in the rename mode.
I'm going to hit home and go add an underscore right to the beginning of it.
If I hit enter now, it's going to rename all instances of that horizontal that were down here that didn't have an underscore to have an underscore.
If that didn't work for you, you can always go through and manually do that.
Just adjust each one.
Now, what are we doing? We're setting the horizontal value right here.
We're logging it out and then we're using it here in the um in our velocity setting.
Now, this horizontal is going to have our speed calculation in there.
And that's totally fine with me.
It doesn't matter.
We just want to check if it's greater than zero or less than zero.
So, we're going to go down to our update sprite method and add our if statement.
We'll say if and we want to check horizontal.
If it's greater than zero, so if we're pushing to the right, then our sprite render, let's go to a new line.
Sprite renderer.flip x should be equal to false.
We don't want it to be flipped.
If we're pushing to the right, now the alternative is that we're pushing to the left.
So, we'll say else, but we don't want to just say else.
If we want to say else if horizontal is less than zero then sprite renderer.flip x is equal to true.
Look at that.
It autocomp completed for me.
Now why can't we just say else? The reason for that is if we let go and we're not pushing anything.
Horizontal would be zero.
And we don't want to have a default direction.
It would if we did that with just the else, it would just instantly flip to the left as soon as we weren't pushing any direction.
That's not the behavior we want.
We want to face the last direction that I was pressing.
So let's save with control S.
Get rid of the little star there.
We'll take a look at the entire script one more time.
So there it is.
We've got everything here.
We've got our update sprite method.
Update sprites being called right here at the end of the update method.
And we'll go back into Unity and try it out.
So now when I jump, we should be able to see that I'm jumping to the left or to the right at least slightly more visually than we were able to before.
And this is going to work for our moving and all of our other sprites that come along after this.
So once we start running.
So there we go.
I can go left and right.
Look at that.
It's looking pretty good.
So let's stop playing.
Go back into plastic.
Make sure that we've saved our scene and say that we've added um jump or let's say added sprite directions.
Added sprite direction based on movement inputs.
and we'll check in our change.
Now, we're going to talk about animation in Unity.
Our current setup requires us to swap out the sprite based on what's happening.
And while that works fine for a single sprite swap like we've got here, having it to do it for running and climbing and swimming and all kinds of things wouldn't really be feasible.
In fact, having to do it just for walking alone would mean that we'd have to constantly switch out the sprite every frame or every couple frames at whatever speed we wanted.
There's an easier way to do that and there's a built-in system for doing it using the animation system.
So, I'm going to stop playing and we're going to create some new animations for our character.
To do that, I'm going to rightclick on my assets folder.
So, first down in my project view, go to the assets root folder.
I'm going to rightclick and I'm going to create a new folder.
And I'm going to call this animation.
This is just where I want to store my animations.
I'm going to now go over to the animation window.
So go to window and look for animation and animation or you can hit control 6 or command 6 is probably your hotkey for it.
So you hit that button and you'll get a new animation window.
It's going to look like this and not be super useful by default.
That's okay.
We're going to take it.
We're going to drag it down here and dock it onto the bottom of our animations or our bottom of our our bottom window.
So, it's locked in with our game view, the plastic window, the console, and the project.
Now, I'm going to go select my alien.
And notice that this create button appeared because it knows that, hey, there's some stuff on here.
I could create an animation for this.
Before I create an animation for my player, though, I'm going to rename him.
So, instead of having this be Alien Blue Front and having a bunch of animations that are named after Alien Blue Front, I'm going to rename him to player.
So, hit the click the left click on him and type in player.
Or again, you can go up here into the inspector and just type in player.
Then, we'll hit the create button down here with him selected.
And we're going to get some new animations for our player.
We'll go to the animation folder to save it in.
And the first one is going to just be a walk animation.
So, I'll just replace the text down here with walk with a capital W.
In fact, I'm going to put player walk so that I've got a nice player specific animation name.
I've got my player walk animation.
And look at this.
I've now got this weird little timeline with nothing in it that does nothing when I drag.
What I want to animate is the sprite renderers sprite.
So to do that, I've got a couple different options.
I can either go in here, hit record, and then change out the sprite partway through, or I can take the shortcut, which is to take it the sprite files from our project view.
So, if I go select my sprite, let's go to the project view first.
I go to project view, click on my sprite renderer, the sprite right here, to go select it and find it.
And I can see I've got my walk one and walk two.
I'm going to turn this into a list view.
I've got my walk one and walk two.
And then I'm going to put this side by side with the animation window.
So, to do that, I'll just take my animation window, drag it right over here.
So, it's kind of side by side.
And I'm going to take walk one, click on it.
Take walk two, hold shift and click so that they're both selected.
And then I'm going to drag them right over here to the right onto the animation window.
And then we'll hit sprite renderer.
And that's going to create an animation for the sprite renderer.
Now, if you're wondering why it had a popup there to say player, that's actually something kind of new.
And it'll allow me to animate the jump sprite of the player.
It was looking for a sprite that it could animate, and it saw that, too.
So, it gave us two options, but what we wanted to choose was sprite renderer, which is what I did.
And you can see now the sprite has changed to alien blue walk one.
Let's zoom in a little bit by holding the control key.
Oh, and zoom in.
And zooming just a little bit with the mouse wheel.
You can see I've got this two frame animation.
It's not very useful.
If I click here, I can drag back and forth between the two frames.
And I can hit the play button and watch them go very, very fast.
That's way too fast of an animation, though.
So, I'm going to zoom out here and look at this timeline.
When I get to the 1 col 0 0, that's 1 second.
So, if I take the second dot here, just drag it out.
Let's see if I can get it.
Oh, Z.
Let's take the line here and drag it out to 1 second.
Now, it's going to switch frames once per second.
But notice that at the end of the frame, it goes right back to the first walk state.
So, let's let's stop playing.
Drag this out.
See, right here, it's on walk one.
When it gets over to here, it goes to walk two, and then it instantly bounces back to walk one.
So, I want to make it go through all of these.
I want it to go to this one, then to this one, and stay on this one for a little while before it switches back.
So, I'll drag this over to about the 02 area.
Then, I'll select this first pixel right here, this first little dot.
Go select it and hit Ctrl + C.
Go over to the 04 area and hit Ctrl +V.
That's going to give me another key frame that's of walk one.
So, notice this one selected.
It's on walk one.
If I go over to here, it's on walk two.
It goes walk one, walk two.
And if I hit play now, I've got an animation that switches between the two.
If I want to speed this animation up, I select all of these key frames, grab this little line right here at the end to just scale it down.
Now, it's a faster walk at half the speed or or half the time and double the speed.
It's a little bit less than half.
I think I went over a tiny bit further than intended.
There we go.
So, now I've got my walk animation on here.
Let's press play and see what this looks like in game.
I should expect to see my character walking and animating pretty much all the time.
There we go.
He's animating.
He's walking.
I run back and forth.
And now when I jump, look at that.
My sprite is no longer in a jump sprite.
It's being overridden by this animation system.
So, we're going to have to do something with that.
But so far, it's kind of good, right? Like, we're walking.
We're getting the sprite kind of showing.
I think that this is probably too fast for us.
It's not really the speed that I want to be at.
I think I want to scale that back up.
So, let's zoom out.
I've got the character selected.
Go select the player.
Go to the animation.
If you don't see the animation, make sure you select it right there.
Zoom out with the mouse wheel and drag this out to about that point four.
Let's see.
We walk.
Now, that's kind of closer.
Let's go to the three right there.
Yeah, that looks that's probably about where I want it for now.
So, now that I've got it at a level that I think I like, I'll stop playing and let's examine what's happening here.
How is this all working? How is this animation playing? And why is it taking over? The animation is playing automatically because of this animator component that was added to the player.
When we added the animation and created it on here, it automatically added this animator component.
It created this player animation controller and it assigned the player walk animation to it.
If I double click on this controller, it pops up the animator window.
And this is where some people tend to get confused in Unity with animations and the animator.
Really, what's going on is the animations are individual animations.
So, think of like a jump movement or a running movement or a shooting movement.
Those are the individual movements.
The animator is the thing that ties them together and controls which one is playing at any specific time.
The animator here is just playing this play or walk animation.
I can zoom out on the animator and zoom in with my mouse wheel.
I can use the left mouse to pan around and I can click and drag to move things around and select them.
Right here you can see that on entry.
So, when this animation or animator starts up, the first thing it does is go right into the player walk animation, and then that thing just sits there and plays over and over and over.
It never switches out of the player walk state.
So, we're going to have to figure out a way to modify the state, change it, and switch between different animations, whether it's an idle animation, a climbing, a running, a swimming, a jumping, or anything else.
But for now, we need to know that this is here, and this is what's starting it.
So, let's save, go into plastic, commit our animation and our new animator controller, and then start to think about what we can do to tie into this animation system to make our player a little bit cooler.
So, we'll go to the plastic SCM folder, make sure that we've saved that we added walk animation to the player and commit or check in.
Now that we have access to this animator and its cool system, let's see what it can do and see if it can maybe handle our jumping and some other things for us.
So, we're going to go back to the animator window.
If you don't remember how to find that, just go select your player, find the animator, and then go double click on the controller.
That'll bring up the animator window, which allows us to modify an animator controller.
And what we want to do is add a jump animation into this canvas and a way to switch back and forth between it.
Now, if we go look at our jump, let's go select the player and then click on the sprite so that our project view shows us all of our sprites.
There's only one sprite for jump.
So, it's not much of an animation, but we could theoretically have a player that's a 3D character or a 2D character with better animations that has some jumping going on or better animations, but actually like moving jumping animations.
We're not going to have one for this character, but we're going to create an animation anyway.
To do that, we're going to select our character with our animation window open here.
We're going to click the drop down here that says player walk and choose create new clip.
We want to create a jump animation and I want to do that in my jump folder.
So, I'll go up to the assets folder.
Oops, I can click right and then go to my animation folder and I'm going to call this player jump.
Now, in this player jump, we're going to add a single frame.
That's going to be my alien blue jump.
I'll click and drag that over to my animator right at the beginning and choose sprite renderer.
And now I've got an animation that just plays a single frame.
You haven't seen it yet, but we're going to see it in action in just a moment.
Also notice up here in the animator controller, we have a player jump option.
This has appeared automatically as soon as we created the animation because it knows that this is an animation for our character.
I'm going to click on it and drag it so that it's directly below the player walk just so that it's nicely lined up.
position doesn't really matter, but having it nice and clean, I think, is important.
And then we're going to go over to this layers and parameters section, and we're going to click on parameters, and we're going to add in a new parameter.
What we want to do is switch between these states depending on whether or not our player is grounded, just like we were doing in our code, but we're going to do it in the animator instead.
We'll click on the plus and choose that we want a boolean parameter or a bool, and we'll name it is grounded.
exactly the same way that we did in code with a capital I and a capital G, no spaces.
So, we've got an is grounded parameter and then we're going to want to use that parameter to switch back and forth between these two states.
So, to do that, we'll go to the player walk.
We're going to right click on it and hit make transition.
That's going to give us an arrow that we can drag around and snap onto anything here.
Well, really the only options are exit and player jump that we could snap to, but if we had more things, we could snap to them.
We're going to go to player jump and click.
We'll get a nice line going straight down to play or jump.
Then we're going to click on that.
This is called a transition and it transitions between one trans one one animation to another.
So we're going to click on it and we're going to add a condition here.
If I hit the preview here, you kind of see it.
It doesn't really show very well, but you can kind of see what it's doing.
It goes into this animation for this part of the transition.
It tries to kind of blur them.
So we don't want that blur really happening.
We want it to be instant.
So we're going to uncheck has exit time.
And then we're going to check the condition because we only want this to happen when is grounded is well not true but when it's false.
So we'll click the false.
Click the dropown and choose false.
So when we're not grounded we'll go into the player jump animation.
Now we also want to be able to go back into the walk animation when we are grounded.
So we're going to go to the player jump animation right here.
Right click, hit make transition, drag this arrow, and of course you probably guessed put it right onto the player walk.
Then we'll click on the transition for going up to player walk.
This not not this one but this one over here to the right.
And we're going to add a condition for this as well.
Is grounded is equal to true.
It kind of default got it because that was our only option.
Also uncheck the has exit time.
If you don't do that, you're going to see a delay between your animations.
It's going to feel weird and laggy like it's not working.
All right, we'll save.
Go into our code now and start hooking this up.
So, well, actually, before we go into our code, let's take our animator and let's drag it down here next to the animation window so that we can see it.
And I'll use the right mouse or middle mouse button to pan this around.
And then let's press the play button.
Let's just kind of manually control this for a moment before we tell Code to do something with it.
So, we'll play and we should be able to if our player is selected see this animation kind of in progress or see the animator and get a kind of a preview of what it's doing.
So, you can see it's playing the player jump animation constantly.
If I jump, then it's not switching.
So, what's going on here? The transition out isn't working.
Why is the transition out of player jump not working? Oh, because it's ground.
It's never changing.
Ah, so that was the problem.
I I forgot this is exactly what we're looking at.
So is grounded changing will switch between our two different animations either constantly in player jump or in player walk if they're grounded.
So how are we going to set this from code? Well, let's go back over to our player script.
So select the player, open up the script, and in our update sprite, instead of changing the sprite between our default sprite and our jump sprite, let's delete that code.
We'll take lines 60 through line 63.
Hit delete and we'll say get component and we'll get our animator and we're going to set a parameter on it, a boolean parameter specifically.
So we'll do set bool and we need our open parenthesis.
Then we have to give it the name of the boolean which is is grounded capital I and capital G.
And then we got to go to the end of that quotation mark, add a comma, and pass in the value which is either going to be true or false, which is our is grounded.
Now that alone with the semicolon at the end will control passing in that is grounded state to check or to match whatever our game state is or our player state is and have our animation update.
Let's go try it out.
So I've saved, got rid of the star.
We'll jump back in.
We're going to leave the animator window showing here and the game window over here on the left.
And then when we jump, you should see that is grounded becomes unchecked.
It switches animations and when we land, it switches back.
Let's try that out.
Looking good.
So, we've got two animation types.
We're going from jump to walk.
And so far, I think this is looking pretty pretty nice.
All right, let's stop playing and let's add in one more state.
Let's say we want to have an idle state where we're not moving at all.
We're going to go to our animation in our project view again.
We're going to create one more animation.
So, first I'll go find our idle sprite, which is the alien blue front, and go to project view.
Click on this sprite right here.
So, it gets selected.
And then we'll go create a new animation.
So, honor animation again with the player selected.
Hit create new clip.
We'll choose player idle as the name.
And I want to make sure that I put this into my animations folder as well.
And save.
So, we've got a player idle animation.
We'll take the idle sprite or the front sprite.
Where is that at? And drag it right out onto here.
So, we have a single instance or a single sprite animation.
Drop that to sprite renderer.
Then, we'll go back to our animator controller.
And look at that.
We've got the player idle option.
I'm going to take this and drag it up.
Um, let's say right over to the let's let's go over here to the left.
just to the left of player jump and player walk.
And what I want to do now is make a transition between player walk and player idle based on how fast my player is moving or whether or not my player is moving.
So, we're going to need another parameter like a is moving or a speed.
What I'd like to add is a horizontal speed.
So, let's add a new float.
So, we'll hit plus and call this horizontal speed or horizontal velocity.
We could call it either one, but we need to be consistent with it.
I'm going to call it horizontal speed.
We're going to make a transition from player walk.
Right click, make transition down to player idle.
And then we'll make a condition on that.
So, select that transition here.
And we'll add a condition that the speed is greater than or less, sorry, less than 0.1.
So, if it's less than 0.1, then we're probably not moving.
We're going to stop.
If we get that value greater than 0.1 or greater than zero though, I want to move back into walking.
So, we're going to add another transition from idle or right click, hit make transition, go back to player walk, click on that transition, and add the condition that the horizontal speed is greater than zero.
So, just choose horizontal speed and greater than zero is the default.
I'm going to uncheck has exit time on both of these transitions.
I don't want any blending happening.
and then we'll save our scene off.
The last thing we need to do is modify this horizontal speed from code.
Now, if you remember what our code looks like, this should seem relatively simple, but let's go take a look and maybe we'll have this be a little challenge.
So, in our update sprite method, what should we do to keep that speed or get that speed into here? I want you to think about it for a moment.
See if you can figure it out and then go ahead and write the code.
If you can't figure it out, don't worry.
I'm going to show you in just a second.
So, go ahead and see if you can figure that out.
out.
out.
And let's go through the results.
So, it's actually relatively simple.
What we need to do is set a float on the animator.
I'm going to take line 60.
I'm going to duplicate it with command or control D.
We're going to change set bool to set float.
We'll change the variable name to horizontal speed.
And we'll change the value that we pass in to be r underscore horizontal.
This should work alone.
Now, we might want to cache our animator.
We probably should.
We'll talk about that in a little bit, but for now, this is good enough.
And this should work.
It should update our animator.
Let's go try it out.
Jump back into Unity.
I expect now that when we're not moving, we stand still.
And when we are moving, we start to play our walk animation.
Let's check.
So, there we are.
When we're not moving, we don't play an animation.
We're moving.
We play an animation.
Oh, but only when we're moving to the right.
So, if we move to the left, it doesn't work.
Look at that.
So, how are we going to fix this? Well, there's one thing that we can do.
And well, first, let's talk about why this is happening.
Look at that horizontal speed variable.
It's -3.G3 is less than 0.1.
So, it's probably not going to work.
Now, there are a couple ways that we could change this.
We could go in here and modify the um the condition.
We could add in a way to maybe add in some condition.
Well, we really can't even add in a condition.
Say like it's greater than three and less than zero or something weird.
But really what we want to do is just have it be not negative in here so that we never get a negative value.
We always get the positive representation of that or the absolute value of our number which is just the number without the negative sign.
So to do that, we can make a one simple simple code change.
We'll go back to our player script and right here where we pass in the horizontal, we'll pass in math.ABS and then add in an open parenthesis and then add a closing parenthesis at the end of the horizontal.
So what this is going to do is give us the absolute value of the horizontal and pass that in.
It's essentially saying if there's a minus in front of it, remove the minus and just use that value to pass in.
That's all the absolute value is really doing.
So, math.ABS or math.absolute is what it's doing.
All right, let's jump back into Unity.
We should now be able to see our animation working.
If we go left, right, jump, or well, just about anything else.
Let's see.
So, we play, we go to the left, we're animating.
We go to the right, we're animating.
And if we jump, let's see.
There we go.
But we're animating as well.
Now, one issue that we have is that we don't go from idle into jump.
Notice this.
If we're not moving, we're not walking, we don't make a transition from the idle state into the jump state.
And that's because we only have transitions from walk into jump.
So, we're going to need to add in transitions from idle into jump as well.
So, we'll right click on idle, hit make a transition over to jump, and we want to select this condition.
And notice that it's going through them automatically because we don't have a condition anymore.
We want to add a condition here that is grounded is equal to false.
And then we want to make a transition back out of here into player idle and set the condition that is grounded is equal to true and horizontal speed is less than 0.1.
So we only want to go back to idle if we're not moving.
So let's try that out.
Now I can jump.
I can walk.
And I can jump and walk.
And it's for the most part looking pretty good.
There's one little issue when I switch states where the speed I think gets a little bit weird that I don't like.
But we'll talk about how we're going to address that in a moment where you kind of get that like quick face to the front for a quarter or tenth of a second or so.
But this is looking good.
And notice that we were able to modify our animator when we were playing.
I to show that specifically because the animator is not in our scene.
The animator is part of the project.
If I go down here and select the controller, it's actually this asset down here that we've modified.
And while you can't modify scene assets or scene placed things at runtime and have that stay, you can do that with project level things, which can be confusing and sometimes cause problems because sometimes people think that it's not going to save because it's a on something they got to through the scene view and pulled up, but it's actually a project level thing.
So, the animator changes did save even though we did them while we were playing.
So, let's go back into plastic SCM and say that we've added animator controls for uh walking walking idle.
Yeah.
Well, it's really jump and idle and check in.
Oh, and if you get this error, just like I said before, just hit check in again.
It happens.
It pops up every now and then.
Now, we're going to do some modification to our animator.
Let's drag the animator up and make it a little bit bigger.
I want to show you some more of the power that we have here.
Right now, we're doing some animation transitions between our walk and jump and our idle and our walk and our idle.
And it's a little bit confusing.
I feel like when you start to build up these animators, it can be very easy to just get confused and make things that don't make a lot of sense.
And that's exactly what happens here relatively quick.
So, what we're going to do now is delete out our player idol.
So, we're going to select the player idle and delete it completely.
Get rid of all of those transitions that we just created.
Don't worry, we're going to do something even cooler.
Now, we're going to go into our player walk.
We're going to rightclick on it and hit create new blend tree and state.
This is going to allow us to create something that will blend between or mix between different animations based on a variable.
Kind of like our transitions here, but a little bit different.
Now, it might look like nothing has happened, but if I click on this and double click it, you'll see that we now have this weird blend tree thing.
It doesn't make any sense.
If I click on it, it doesn't do anything.
Just has a slider here.
It's a little bit confusing, but what we need to do is click the blend tree and add some motions to it.
We're going to hit plus, add a motion field, and plus and add another motion field.
We're going to add our two animations, our walking animation and our idle animation.
To do that, we'll hit the little search box here and find player idle for the first one.
And then hit the search button again and find our player walk for the second one.
Now, what this will do is it's going to blend between the two animations based on what our horizontal value is.
So, if our horizontal is greater than zero, it's going to go to that one.
If it's lower than zero, it's going to go to the other one.
What does this mean for us? It means that we don't need to have all of those confusing transitions out here.
We just need to have this one player walk with a blend tree in it that will blend between our player locomotion stuff and our jump.
And that also means that I want to select this node right here in our animator controller.
And I want to rename it.
Instead of player walk, I'm going to call this player motion.
This is going to be the one that handles idle and walk.
So that's what I'll give it a more generic name.
And then we've got our jump down here that we transition into out of there.
We don't have so many states.
Let's hit play and try that out.
We should see the exact same behavior.
See? So, I run, I stop, and I run, and I stop.
And if I run and I do the switch back and forth now, though, notice that we don't get that weird mixed up frame in the middle.
And our animator controller is drastically simpler.
I can still jump while I'm running.
I can still jump while I'm standing still.
And the correct animation is applied when I land.
either the idle animation if I'm not moving or the running animation if I am moving.
So things are looking quite a bit better.
There's another change I'd like to make though to our player code.
Let's go into the player script and let's take a look at this area where we do our update sprite.
I mentioned in the last section that we could cache that animator and that's what I'd like to do, but I'd like to present that again as a small little challenge.
See if you can figure out how to cache that animator.
Go ahead and try it on your own.
pause the video and then resume on and I'll show you the steps in case you got lost or had any questions.
All right, let's go through it.
So, to finish our animator or to cache our animator, we need to take this get component animator call and we're just going to cut it.
So, I'm going to hit crl x.
Select that, hit crl x.
We're going to add in the word underscorean animator and then hit escape and then I'm going to hit alt enter and we're going to generate well it wants me to generate a field or a readon field.
We want to go with a generate field.
So we're going to create a new field and it's not going to know the type.
So this is where things get weird, right? Let's hit F12.
Make sure that you're on the word animator and go up to the top.
And here you'll see that we have a private object animator.
What this is is well a little bit confusing.
What's actually happened is the code editor didn't know what type of object we want to create.
We were getting an animator before, but I deleted that code before I put this variable in here.
and it doesn't know that just because it's called animator there's a thing that matches that.
So it just uses the most generic object type that it can.
And in C that's object which actually means that everything in C is an object.
Um it's not a specific type of thing though.
So it's not very useful.
We need to give it the type over here.
We need to replace object with what we want which is our animator.
So we'll just replace that with animator with a capital A.
And now we have our animator reference that we can use down here.
But we haven't saved it off yet.
So we need to save off our animator.
And we're going to do that in the awake.
So in awake where we get our sprite renderer, we'll just add a new line above it.
Say, "Oh, look at that.
It already knows what I want.
Underscorean animator equals get component animator." Got to love the AI that's coming in the code editors.
Now it's making things quite a bit easier.
It already is predicting exactly what I'm going to type in there.
Now I also want to get rid of my private keywords up here because I don't need them.
So, I'll go select them, double click them, hit delete, and delete to get rid of that extra space.
I'll do the same for the one on awake.
Now, we've got our animator cached, and we're using it down here in the update sprite, but you might have noticed that we're not using it on the second line in update sprite on line 63.
So, I'm going to copy it, replace the get animator part all the way up to the end of the parenthesis, and paste with ctrl +v.
Save with control s.
Remember, control shiftb will do a build, and it will show me any errors.
It will highlight anything that's errored or causing a problem.
We don't have anything like that yet.
So, let's jump into Unity and see if it still works.
Should still work.
Ideally, when we make these changes, we haven't broken anything.
That's why we want to test it, though, just to make sure because if you add an extra brace, typo, a name, or something else, it's very easy to make a small error that breaks stuff.
So, we got to test relatively regularly.
All right, we jump.
Looks good.
I can run around, run back and forth.
Everything is looking yep, exactly as I expect.
Let's stop playing, go into our plastic SCM, and say that we modified our animator and cached the modified and cached our animator.
Maybe cleaned up and cached our animator.
Make sure our scene saved.
It is saved.
Yep.
And oh, need to go into file and save project.
We've got to up.
If we don't save project, this is a very important part.
If we don't save our project, our animator player or our player controller won't get updated.
The project level files, the stuff down here doesn't get saved when we hit file save.
That just saves our local scene.
We have to go to save project to save all of the changes to our project and have this update.
Now, there are other times where that just kind of happens automatically, but before we commit, we want to make sure that we do a save project.
So, we've cleaned up our animator controller with a blend tree or a blend state and cached animator in the player and then we'll check in our changes.
In this section, we're going to dive deeper into the Unity physics system.
We're going to take a look at some interesting bugs that you may have already noticed and make it so that our character's jump and movement feels nice and fluid.
The first thing that I want to show you is an issue that you might have run into where your character can kind of hang from one of these platforms.
You can see it represented right here.
I can't actually jump.
I'm just kind of stuck hanging from that platform.
And if I go to the scene view, you can kind of see what's going on here.
If you look at our character, he's got this little green collider showing up and it's landing on top of this box right here.
Let me turn off the sprite renderers for both of those so you can see it better.
Here's our player and you can see that he is just barely touching right here on this little line.
It's not actually touching, but the physics system is counting it as close enough and counting it as a touch.
So, that's causing a big problem for me because our player doesn't really slide off of there.
And our player can't jump because this center line here isn't in the ground.
Let's turn those sprite renderers back on.
You can see it a little bit better.
And now go back over to my game view.
And if I try to jump, remember, nothing happens.
I can still kind of move off to the the right and fall down a little bit, but I don't like the way that that feels.
And I don't like that I can easily get stuck on there.
So, we're going to make a couple of minor changes to fix this.
The first thing that I want to do is go to the scene view.
Double click on the player to select them.
And we're going to replace this polygon collider.
The polygon collider will match up exactly with your sprite so that it lines up and outlines your exact sprite and gives you a very perfect collider, but that's not usually what we use with a player.
Most of the time with a player, we want to use something a little bit smoother that moves quite a bit more fluidly.
And in our case, in this specific scenario, we're going to want to go with a capsule collider 2D.
So, I'm going to hit add component with the player selected, go to physics 2D, and choose a capsule collider 2D.
By default, this is going to be way too large because of the sprite that I'm using.
If I go select my sprite here and go click on it, remember that it's a fulls size sprite.
It's going all the way up to there.
There's lots of extra transparent edge, so it's not properly calculating that top part of the sprite.
We can modify that, though.
And you need to do this almost every time you set up a collider anyway.
We can do that by going to our colliders properties.
Let's collapse everything else.
Find the capsule collider and look right here at the size value.
The size right now is a two.
If I change this to a one, you see it goes to about half the size.
And I think the value I want is more like a 1.2.
A 1.2 there.
Grab the Y and just drag it down so that it lines up.
And I think that the correct value here is going to be a0.4.
This gives me a nice capsule where the very bottom of it lines up exactly with my feet and it's going to be good for nice fluid movement.
Now, if I just save like this though and go back and play, we're going to run into an issue.
Let's save and see what that issue is.
So, I save.
I press play.
Remember, we moved removed the polygon collider, added that capsule collider.
No other changes yet.
Now, I can run around still.
Looks good.
Okay, let's jump up on a platform.
Okay, that looks good.
And it feels kind of smooth.
and I can kind of fall down off the edge there.
But watch what happens if I try to jump multiple times.
I keep jumping in the air like that.
I've got unlimited jumps.
Now, the reason for this, if we go look at our player, is that that grounded variable that is grounded is always true.
And the reason that that is grounded is always true is well, let's let's jump and watch this.
I'm going to jump and then click pause while I'm falling.
Go over to my scene view, double click on the player, and just take a quick peek at them.
So, what's actually happening, and I just wanted that so that I could see the player kind of up in the air, not actually on the ground.
What's actually happening here is that this ray is technically intersecting this circle or this collider because it lines up exactly with the collider.
So, we have a couple of options.
We could um maybe move the collider up a little bit so that the ray isn't there.
Maybe go to like a 39 and then the ray is right below it.
But that's not really the best option.
The other option that the one that I think we should use is to add a layer mask.
And we're going to dive into how to use layers in Unity and how you can use a layer mask to make it so that this collision check right here, this grounding check ignores a player.
To do that, we're going to need to stop playing.
We're going to go to the player and then we'll go to the layer section in the inspector.
By default, you should have a default layer, transparent effects, ignore raycast, water, and UI.
These haven't really changed the defaults, but we need to add in our own layer.
And to do that, we're going to hit the add layer button.
This will bring up the tags and layers inspector, which allows us to create up to, well, 31 layers, not counting the couple built-in ones.
I'm going to use layer 6, and we're going to name this player with a capital P.
This is going to be a layer for our players.
And we're going to talk a lot about layers in a little bit, but you're going to see how these work.
For now, just remember that we need to create a player one and then go rightclick on the player because look, his layer is still set to default.
When you create a new layer, it doesn't automatically assign that layer.
So, you need to go click the character and then reassign the layer.
This happens every time you make a new layer.
Remember that it doesn't actually assign that one because brings up that menu and then you have to pick which one you're modifying.
Okay, so we've added our player layer to the player.
And if I save now and just press play, nothing is going to be different.
All I've really done is tell the physics system, hey, this player, um, treat them separate se separately if I tell you to, or just know that it's on a specific layer.
So, if I want to avoid collisions with things with my player, or I want to just check specific things, I can ignore that player or only check against players.
Let's dive into the actual code, though, because I think it'll make a lot more sense once we put the code together.
So to write our code, we're going to open up the player script and we're going to add a new serialized field here.
Right after our jump sprite, we're going to add a serialized field and it's going to be a layer mask.
That's a capital L and a capital M and we'll name it underscore layer mask.
So we've got a layer mask here named underscore layer mask.
Now we're going to take this layer mask.
I'm going to copy the underscore layer mask.
And in the part where we do our ray casting right here on line 39, we assign a hit or we get back the first thing that that little ray is hitting.
Remember we have the red visualization of the ray.
What we can do here is go to the end of our raycast call.
So after the one f and right before that parenthesis and we can actually add in another comma.
And the reason for this is that our raycast has eight different overloads.
Um, we're only seeing, and when I say eight different overloads, it's eight different ways that this thing can be called.
And I wish it wasn't cut off right there.
But if you hit the arrow right here, you can actually bounce through all of the different ways that it can be called.
And the reason that it can be called different ways is sometimes you want to pass in different parameters.
You want to have different special conditions or um sometimes you want to get back out multiple results.
You want the array to go through multiple things and give you all of those back.
But the one that we're going to use, I hit the comma and add a space, is that we can add a layer mask as the fourth parameter.
So I do underscore layer mask.
And what this is going to do is make it so that our raycast will now only work against the layers that we have selected in this layer mask.
Let's go take a look at what that looks like in the inspector, though.
It'll probably make a whole lot more sense.
Minimize.
Go select our player.
And in the player script, we should get a nice layer mask for our jump or for Yeah, there we go.
Layer mask.
And we'll choose everything except for player.
So, I'm going to choose everything.
And then uncheck player.
Press play.
And this should resolve our jumping problem.
So now our ray is no longer going to look at the player.
There we go.
I can't jump multiple times.
I can jump once, but no more jumps after that.
So, it is working.
Our array is checking properly.
If I look at the player here and I watch the is grounded variable, you see that it's changing properly.
If I change this mask back to player though at runtime, watch.
I stay grounded forever.
So, now I can jump indefinitely.
Luckily, if I stop playing because I changed that at runtime, it'll go away and reset back to the correct value.
So, let's save this off and do a quick commit because we've added a new layer, added the player layer.
We've assigned the player to it, and we've swapped out the capsule collider or the polygon collider with a capsule collider.
So, say swapped polygon collider with capsule collider.
And the final change that we did was add a layer mask check to the player.
Added layer mask check to player.
And I'm going to split these all into new lines in my commit.
So I've got three lines of messages for my check-in and hit the check-in button.
Now we're going to take a look at another jump issue, which is that we can get kind of stuck on these ledges and still not be able to jump.
And if we go look at our player again, let's go to the scene view.
Double click on the player.
Remember that our ray cast is happening from the center of our body.
This little red imaginary line that we shoot down to see if we're on the ground.
And since we're not hitting the ground here, our center of our body is kind of hanging off.
Our character is not marked as grounded.
So, they can't jump.
We can't even click it to do it because it'll get set to false.
So, what we need to do is modify our code a little bit.
Instead of just checking at the center point, we want to check underneath each of the feet.
And we'll do that in addition to checking in the center point just so that if we ever end up on a little tiny ledge where both of our feet are off the edge but the center's on, we can still jump.
So we want to keep doing this raycast at the center but add some additional ones to each of these feet.
And before I do that, I want to do the visualization for it.
I want to make sure that I can see what I'm doing, see where that's going to be, and that it all kind of makes sense.
It makes it a lot easier for me to track down things, debug it, and understand what I'm what I'm writing and how it's working.
So, let's open up the player script and in our ond draw gizmos, let's make some minor modifications.
The first thing I want to do is take line 31 and just move it up.
So, I'm going to actually select that entire line.
So, I go to the end of it and I hold shift, hit the home key on my keyboard, and still holding shift I just hit delete.
Go up, enter, up, enter, controlV to paste.
Or if you're using the correct editor, if you're using Jet Brains Writer, you can actually select a line, do control altshift, and just do the up arrow and down arrow.
You can't do that in here.
Although, there may be a way to rebind hotkeys and make that possible.
Let's save though.
I've moved that line up.
And let's talk about what I want to do next.
So, line 31 and 33, let's add a little spacing here.
Line 32 and 33 are responsible for determining where the line starts and ends.
and that or or really determining where the line starts and then line 33 does the drawing and determines where it ends.
So I want to just have it start in three places instead of doing one line in the center.
I do one line in the center, one on the left and one on the right.
So I'm going to copy lines 33, 32, and 33.
Or actually, let's hit control or command D to just duplicate them.
Go to the beginning of this new line here, which is kind of in the end middle of line 33, and hit enter.
So we get a fresh line.
And the first thing I'm going to call out is that we now have an error here.
It says a local variable fun or function named origin is already defined in this scope.
What's happening here is that on line 32, we have vector 2 origin defining origin.
Not assigning it, but defining it and then assigning it to be equal to this value.
Then on line 34, we're trying to redefine origin.
So imagine we had this as a vector 2 up here and then we tried to change it to a vector 3 or some other thing.
The game engine is going to be all kinds of confused and not know what to do with this.
So we can't do that.
We can't reassign an object.
In fact, we can't even reassign it with or redeclare it with the specific type.
We just have to delete that declaration and then we can reassign the value without redeclaring the variable.
So we only have one origin value.
It's just getting changed here on line 32.
So, it's set to this position.
On line 35, it's set to this position, which is actually the exact same position, but we're going to make a small modification to it.
So, on line 35, instead of using the default origin, we're going to use the default origin plus some little offset to the left.
So, let's say minus and let's add in a variable here and call this underscore foot offset.
This is going to be a floating point variable that we can adjust in the inspector so that we can determine how far out we want our feet to be kind of at runtime in the editor and not have to guess in code.
So, this is going to give us a foot offset and we'll generate a serialized field for it by hitting alt enter and choosing generate field.
Oh, it didn't give me the serialize option.
That's okay.
We'll generate a field.
Hit F12 and then go add the serialized field attribute.
I'm going to do that over the private keyword.
So double click the private keyword, hit the square brace, type in serialize field, just enter and close brace.
I want to move this line up.
So I'm going to cut it and put it right here below the layer mask.
I'll add in an extra line here, too, so we have some space and clean that up a little bit.
All right, I think we're also going to delete out this default sprite on line 18.
While we're up here, let's hit control X or shift delete and get rid of that line because we're no longer using it.
Remember, our animator is controlling that.
That also means that we need to get rid of line 26 that was assigning that.
It's always good to delete extra code when you're not using it so that it doesn't confuse you later.
And it's important to note that when it was grayed out like that, this light gray, it means it's not used.
So, we can probably delete it.
Most code editors will catch Unity stuff and tell you whether or not it's used now.
And that was a good usage for it.
Okay.
So, we've got our foot offset now created.
We need to give it a default value.
I'm going to give it a 0.5.
So half a meter out each way seems like a a good value.
And then we're going to go back down to our draw gizmos and let's do the right foot.
So this should draw our left foot.
In fact, let's add a comment here.
Right after or before line 36, we'll do a double forward slashdraw left foot.
And then I'm going to select all of line 36 through 38.
And again control or command D.
Hit the left arrow and enter.
Enter again.
And this will be draw right foot.
So draw right foot is going to be exactly the same as draw left foot, but instead of subtracting our foot offset, we will add to our foot offset.
And that's because the bottom left or the left side of the screen is like 0 0 and the right side, the numbers go up.
As you go to the right of the screen, the numbers go up.
As you go to the left, they go down into the the negatives and so on.
So we've got draw right foot and draw left foot.
Let's save, go to Unity, and see if our feet are now drawing.
We should expect to see three red lines, one in the center, one off to the left, and one off to the right along with a variable here that we can modify for the foot offset.
So, I go to my player and take a look at that.
I've got three feet or three lines drawing and a variable.
I can drag this variable in and get it to oh, what's a good val value? It's a little hard to do dragging.
How about a point three somewhere right around there so it's just outside the feet.
Give myself a little bit of extra room.
And I think we're so far doing so good.
Right now we're not using these values though, but let's save and uh run around and just make sure that it looks okay.
Then I think in the next section we'll start using these in our raycast.
So we run around.
Looks good so far.
I'm going to put my game view down here, dock it, and go double click on my player.
And then let's just I just want to see what they look like when we're animating.
Seems good.
Okay, so far I think it's pretty good.
Let's stop and pause right here.
go to the player because I got myself kind of hung there.
And you can see right here, I would not be able to jump.
My player's not grounded.
So, I'm thinking maybe I need to pull out this foot offset just a little bit more.
Maybe like a 0.35 and then I would be able to jump.
So, then I can jump when I'm still pretty pretty far down.
But remember, our check isn't actually doing that right now.
So, let's stop playing.
I'm going to save off that value of a 35 for our foot offset.
Save our scene.
go to our plastic window, say we added gizmos for left and right foot grounding, and we'll check in our changes.
Now that our raycast gizmos are drawing for the left and right foot, we need to hook them up so that they're actually used in our code because drawing them in gizmos is just for visualization and debugging.
It doesn't actually affect gameplay.
To do that, we're going to open up our player script again.
We're going to go find the part where we do our grounding, which is actually right at the beginning of update.
We have lines 48 through 53 that do all of the grounding checks.
And the first thing that I want to do, and this is, I think, a very important step and a very important phase of development, is refactor or extract this little bit of code.
If you look at our update method, right now, we do a lot of grounding stuff.
We do some input stuff, and then down here at the bottom, we do the sprite stuff.
And we've already extracted out that update sprite method that handles all of our sprite stuff.
So why not do the same for our grounding? Let's take our bit of grounding code and we'll extract this out into a new method that we'll call update grounding.
So I'm going to select all of the code from 48 to 53.
Hit alt enter and choose extract method.
And then we'll name this method update grounding.
Now if you had a hard time doing that, you can also just copy and paste all of that code.
Cut it all.
Make a method named void update grounding.
You don't need the private keyword.
And then paste the code inside of there.
Just like this.
And then call the update grounding with a semicolon right here at the beginning of the update.
Now I don't have to look at this entire update method.
I just have to look at this update grounding method for our ground updates.
It makes it a lot easier for me to kind of comprehend what I'm looking at all of the code and to reason about it without having to see all of the extra stuff.
In fact, I can even collapse down this update sprite.
And I'm going to get rid of that private keyword while we're at it.
So, in our update grounding method, right now, we do a check from the center.
That's we get our origin.
We use our position X, which is the center of our character's X position, and then we get the bottom part of our character's Y, by using the center, and then subtracting the extents of the sprite renderer.
So, basically half the height of the sprite renderer to give us the bottom of our character.
So, we need to now get a position that's off to the left and the right by foot position and check those as well.
So, to do that, we're going to make a couple minor minor changes to well, I guess they're not that minor of changes.
The first thing that we're going to do is remove this else statement.
We're going to kind of do three if checks.
And we don't want to do else if, else if, else.
It'll get very confusing.
So, we're going to delete out line 72 and we're going to cut line 73.
Take line 73, put it on the clipboard, shift delete or control X, move it right up to the top on line 68.
So now at the beginning of every frame, we're going to set is grounded to false.
Don't worry though, because before anything else can process it.
If we are grounded, we'll set it right back to true.
Nothing will even know that it was changed.
So on line 68, we'll set is grounded to false.
And then we'll check to see if everything is good in the center.
I'm going to save this off.
And we're just going to make sure that nothing has broken, everything still works.
We should have changed zero functionality yet and everything should be the same.
It's always important when you refactor to test things, make sure that it all still works before you actually dive in and um start making changes.
So, we want to make sure that it works with the refactor first.
All right.
So, we jump in.
I want to make sure that my layers still correct.
My player is set to the correct layer.
The layer mask is still correct.
Missing the player.
And I should be able to jump but still not see those two left and right feet.
Let's make sure that that works.
Well, I can see them but not use the left and right feet to jump.
So, I can jump.
Looks good.
And then if I jump up on this other platform, I can't keep jumping.
Yep, looks all right.
Seems okay.
And I can't double or triple jump or anything like that.
Okay.
So, we'll stop playing.
Let's go back into the code and now hook it up.
Hook up our new part.
So, instead of just checking the center, we want to check the left and the right as well.
Let's add a comment here on line 70.
Check center.
And then let's do the same down here.
We'll go check left on line 76.
And I'm going to copy lines 71 all the way through 74.
Then we'll paste them after 76.
And then we've got a couple of issues.
We've got two errors here.
Now, if you remember what the cause of these errors is, awesome.
Please just go ahead and fix it right now before I even tell you how to fix it.
If you don't remember, don't worry.
I'm going to explain it again.
So what happens here is that origin is defined on line 71.
So we can't redefine the origin variable.
We can however reassign it by just getting rid of that part that's defining it or the class type or the basically the type that you wanted to define it as.
The part that was in that nice little light blue.
We get rid of that and it'll the error will go away.
The same is true for line 78.
And by the way, we're here we're using a word var.
This could also say raycast hit 2D.
It's exactly the same.
Var is just shorter and it autocompleted.
But it's still going to be an issue because we can't redefine it.
We have to just remove that completely.
And we could put raycast 2D up here if we wanted to.
Raycast hit 2D like that.
So that'll give us a another copy of our check, but it doesn't actually check against the left position.
Remember in our gizmos, we're just subtracting the foot offset to get a left position.
So I just take this minus foot offset, hit Ctrl + C, go down to the end of our position X, and paste it in.
So now we're going to have a check that's off to the left of our foot offset or subtracted our foot offset, which is like 35 to the left.
Now select this checked left part from line 76 all the way to the end of 80.
Again, control or command D.
Hit the left arrow, enter, enter.
Get some new lines.
And let's replace the word left here with right.
And then let's make it actually check the right by instead of going to the left or subtracting our foot offset, we will add our foot offset.
So we'll hit plus.
And now we should be checking in the center right here.
That's this position right here.
Transform position X.
Off to the left, which is our position X minus.35 or I think it's 0.35 that we have.
And then to the right, which is plus.35.
If any of those returns back a hit, we will say that they're grounded.
Now, there are a couple of things going on here that are not the most inefficient.
For instance, if we hit in the center, we probably don't need to check the left and the right.
We could probably bail out early and probably a couple other little optimizations that we could do.
But for now, I think that this is plenty fine.
We're not going to have any actual performance issues.
There's no real big benefit in updating it or modifying it or making it any faster.
So, we're going to leave it and make sure that it actually works because that's the important part.
minimize our code editor, jump back into Unity, and press play.
And I expect that now, if I can get my scene view up over that platform a little bit, I should be able to jump up and have my foot kind of hanging off and then continue jumping.
This is going to be a much better feeling and more realistic character controller for a game.
So, I can jump up and there we go.
I can now jump even when I'm kind of like hanging off the edge there.
Still got plenty of room to jump.
Things are looking a bit better.
And I think I I like that feeling quite a bit more.
Now, you can modify that again by going to the player and just dragging in and out that foot offset, but I think that 0.35 is where I want to leave it for now.
So, now that I've got that done, I'm going to save, go to file, and make sure I've saved my project to.
Remember, file, save project.
Make sure that the main reason for that is we want to make sure that our tags have been updated and saved in in the uh update, which they should have been in the last one, but if you missed them, and make sure that you do that.
So here we've added raycasts for left and right foot and we're checking our changes.
Now we're going to add one of the most commonly requested features and that's double jumping.
It's actually a very simple thing to set up if you do it right.
Let me show you the process of figuring out when a player can jump and how many jumps they have left.
The first thing that we want to do is go to our player and open up our player script.
And we're going to start with a player that can jump two times.
And that's it.
We'll make it so you can adjust it later, but you'll see it's very simple to have any number of jumps that we want to have.
And the first thing that we want to do is when we're on the ground and actually landed, we want to just give our player some number of jumps.
So, we're going to want to store an integer or a number, a whole number of jumps that are available.
And I'm going to do that right after this line 86.
I'm going to add two more lines here.
and we'll say if is grounded and we want to make sure that our player is not falling downward.
So we need to do something with the rigid body and look at the velocity.
So we'll say get component and we'll get the rigid body 2D component and we want to check the velocity.yvalue.
We want to make sure that the y value on that velocity is either zero or negative like we're falling down.
It's pushing down.
So we'll say less than or equal to zero.
So if we're on the ground and we're going downwards or we're touching the ground and not moving at all, whatever it is, we're not moving up.
That's the main thing.
If velocity y is positive, it means we're jumping.
Then we want to increase or set our number of jumps available.
So we'll say underscore jumps available equals two.
Or maybe maybe we'll call this jumps remaining.
Let's do that.
We'll generate a field for jumps remaining since it doesn't exist yet.
And this how I generate all of my field variables.
Enter.
And then we'll hit it's alt enter and then enter to generate.
F12 to go to it.
And get rid of that private keyword.
We don't need it.
And it's just kind of extraneous.
We don't need to give it a default value though because it's going to get set in our grounding to two every time we're on the ground and pushing downwards.
The next thing we need to do is in our jump detection.
Instead of checking to see if we're grounded, let's just check to see if we have jumps remaining.
So, we'll replace the is grounded here on line 15 with jumps remaining is greater than zero.
And then the last thing we need to do is just remove a jump from our jumps remaining whenever we use one.
So, if we use a jump, we need to decrement our jumps remaining.
To do that, we're going to modify this little chunk of code here on line 56 and put it inside of braces.
So if they start a jump by pressing fire when they have jumps, we want to do two things of code.
So we'll add some braces around this.
And we'll set the jump end time still for when our jump has to end.
So we have our maximum time.
And then on the next line, we'll say underscore jumps remaining.
And we want to remove one.
So just like plus+ removes or adds one, minus minus removes one.
So that will decrement it or reduce it by one.
So it'll go to two and then it'll go down to one and then it'll go to zero.
So, we'll be able to jump twice in the air.
Let's save.
Get rid of the little star there.
Take a look at our entire script again.
And then go try it out.
We should now be able to jump two times.
And if we change that code that of jumps remaining from two to three, we could jump three times or however many times you want.
Or we could put that in a variable.
But for now, I think two is probably good.
Let's try it out and make sure that it works, though.
So, I come in here, I jump, and I jump again.
Look at that.
jump and jump again.
And I have no more jumps.
Can't jump.
Jump.
Jump.
It's looking good.
You can actually look at our jumps remaining value, too.
You can't see this in the player right now, but let me show you a cool trick so that we can view it and kind of debug it if you're curious or if maybe you're not seeing your jumps remaining, right? So, what we can do is go to this player, click on the three dots, and then choose the properties.
Oh, it's a little bit off screen.
Let me drag it over so it pops up on your screen.
So click here on the three dots and properties right there.
That'll bring up this nice properties window that shows me everything that I was already able to see.
But now I can right click or click up here on this little dot and choose debug and see all of the hidden variables as well.
So I can see my jumps remaining is at two.
When I jump it goes to one and I jump again it goes to zero.
And now what you do with this window is up to you.
I like to just have one of these kind of off to the side that I can see and view and kind of debug stuff without having to go modify my inspector.
Again, remember, you just go to rightclick and choose properties.
It'll bring up a window and then just put that window into debug mode if you want to see the private things on there.
You can see the public things by default, but you can see those in the inspector anyway.
All right, so our double jump is working.
I'm going to make sure that we are saved.
go to the project view or the plastic view and commit that we've added double jump and check in.
Now, we're going to add a little punch to our jump and we're going to do that with audio.
We're going to add a jump effect that plays whenever we jump and change this so that we can tell which jump we're on, if it's our first jump or our last jump.
So, if we've got multiple jumps, you can kind of get a little bit of variation in there.
It's going to be very cool and a lot of fun.
The first thing we're going to need to do though is find a jump sound effect that we can use.
My recommendation is to go to Open Game Art.
And on Open Game Art, there are a whole bunch of different free sound effects that you can use.
The one that I like the best so far was this platformer jumping sounds.
It's got quite a few jumps.
Can hear them.
They play quite differently, but I'm going to go with this first one.
jump one just the first very basic default jump.
Feel free to use whatever jump effect you want, but we are going to do a little bit of pitch variation here.
So, just kind of be ready to play with it and be ready to swap it out.
So, first thing I need to do is download my platformer jumping sound effects.
So, just click on it, download it, and get myself a nice big zip.
The zip of my platformer effects, I believe, is full of different wave files.
There we go.
We've got a jump 01 all the way through a jump 11.
And I should be able to just double click on these and play them in whatever my media player is.
Let's see.
There we go.
It played.
But now I need to get them into my game.
And the best way for me to do this is just select the one or ones that I want.
And right now I just want this first jump.
So I'm going to take this jump01 wave and copy it in my zip file.
You can extract these however you like, but this is the way that I like to do it.
I'll copy it out of there, put it onto my clipboard, and I'll go back into Unity, and I'm going to make an audio folder.
So, I'm in my project view, go to the root assets folder right here, right click in the empty space, create a new folder.
I'll name this audio.
Whoops, I got to go down to it and name it audio.
So, F2 to rename and AUDIO.
I'll hit enter to go into it.
And then rightclick, hit show and explorer, which will bring up the window.
And then I can just hit enter to go into that folder.
Since I've copied that audio file onto my clipboard and I haven't hit control + C again, I should be able to paste it with controlV and have it just extract the file right into that folder.
And then remember when I tab it back into Unity, as soon as I click over here, it should show up.
It'll import the file and pop up.
And now I have a Jumbo 01.
And if I click on it, I can play it.
It'll autoplay.
But when I click the little button in the corner, it'll also allow me to just kind of replay it as many times as I want.
So now I need to add this to my player.
To do that, we'll select the player and then just kind of collapse some of these components down in the inspector.
And I'm going to drag my audio file onto this empty spacer.
So I'll click, hold, don't release the button, drag and release, and we should get an audio source automatically added.
Now, if you're having a hard time with that, you can't get it to work for some reason, try just adding it manually.
You can hit the add component and type in the word audio, and you should see an audio source here down at the end.
It's the one with the little speaker.
Make sure you get the right one.
And then you can drag that clip into there or hit the little search button and find the jump clip.
So now I've got a jump sound effect attached to my player.
In fact, I've got a sound effect and a sound effect player or an audio source that's going to play the sound effect for me.
If I just press play right now, I should hear a jump sound right when the game starts.
And that's because this play on awake button is checked.
Let's check.
Let's press play and check.
and it said button, but it's really a checkbox.
That checkbox is checked.
So, we play and I heard the sound effect.
Now, if you didn't hear a sound effect, you might have your audio muted right here.
See this little box? It's a toggle to mute audio in your game view.
If it's muted, you're not going to hear anything.
So, make sure that you unmute that.
Now, what happens if I check the loop box? Well, nothing right now because it's not playing.
But if I turn my audio off and on like that, you hear that it just kept looping.
I'm going to stop playing though because I don't want either one of those things happening.
I don't want it to play on awake and I don't want it to loop.
So, we'll stop playing.
Uncheck both of those boxes and let's open up our player script.
So, inside of our player script, what we want to do here is when we run our update and we do the jump, as soon as we jump, we just want to play the sound effect.
To do that, we're going to need to reference our audio source and tell our audio source to play sound.
We can get the audio source component just by calling get component and give it the type.
So we do that lesser than which is again shift in the comma.
Give it audio source.
Close that off and do our open close parenthesis.
And we do a dot at the end and say play.
Hit enter.
Open close parenthesis and a semicolon.
What this will do is get the audio source on this same object.
So on the player object and tell it to play.
Let's save and see if that works.
So, Crl S get rid of that star.
Go back into Unity.
I also want to make sure that we save our scene here.
So, we get rid of the star as well.
Crl S any second now.
As soon as it finishes reimpporting, hit Crl S and play.
And now, whenever we jump, we should expect to hear a sound effect.
Let's see if that's the case.
There we go.
I jump and every time I jump, I hear a sound.
If I keep clicking, I don't get anything.
Just when I actually jump.
All right.
So far, that's pretty good.
I I like it.
We've got a sound effect.
It works.
But there are a couple of minor changes that I want to make.
First, I said that I wanted it to sound differently depending on how we um how many jumps we have left.
But I also don't really like having this line right here.
And I want to talk a little bit about this because we've got another one up here.
We have these get component calls that are being made in our update method.
And really, most of the time, we don't want to do this.
Generally, my rule of thumb is don't do get component calls in an update method.
If you're going to get a component and that component is going to be the same component every single time, then you should do it once and save that value off.
So, that's the case for our audio source and our rigid body.
Let's let's take a look at that.
We'll zoom in.
And if we want to get rid of this git component call and just cache our audio source, what I'll do and what I would do is hit controlx.
So, I've selected it all and then type in the word underscore audio source.
Again, the underscore is just a personal preference thing letting me know that it's a member variable, something at the class level and not part of the method.
So, I've got an audio source.play and that gives an error because audio source doesn't exist.
So, I'll hit alt enter and well actually I'm not even going to generate a variable.
What I'm going to do is go up to the awake method.
Watch this.
This is even better.
I'll type underscore audio source equals and then I'm going to paste because we have that get component audio source already on my clipboard and I'll add a semicolon.
Now click on the audio source again and hit alt enter and enter to generate a field.
And now I've got a private audio source named audio source and my error down here is gone because it's correct.
And the reason I didn't generate it from here and I did it from up here is because if I generate it after I've written the code to do the assignment, this get component part, it's going to know to make it an audio source.
If I had done it from the other spot, let me show you.
Don't don't do this.
Just let me show you real quick.
If I had done it from down here and hit generate a field, go to generate field, it's going to give me an object.
And that's just because it doesn't know that I want it to be an audio source.
again on the other part because I'm define defining it and assigning it right here on line 28.
It's able to determine, oh, you're going to assign it to an audio source.
So, it should be defined as an audio source.
So, I'm going to redo that code.
Get that audio source back in there.
Remove that private keyword that I don't need.
I'm also going to add a space in between my public variable and all of my five private variables here.
Now, we'll save.
We'll go back into Unity and make sure that it still works because we've done a little refactor where we moved code around and changed it and make sure that everything's good before we make another change to the pitch.
So, press play.
We should be able to jump twice and hear the exact same sound effects.
Looks good.
And then we'll stop playing.
Let's drag this window back out a little bit.
bit.
bit.
And then we'll go over to plastic and let's do another commit.
First I want to make sure that I've saved and then we'll say that we added basic jump sound to player jumps and check in.
Now we're going to play with the pitch of our jumps and give our player some feedback on how many jumps they have left, but do it audibly.
Let's take a look at our player again.
I've got the player selected and we're in play mode already running.
got the audio source kind of expanded here.
If I jump, I hear my sound effect.
But if I play with this pitch value, listen to how it changes much higher or Oh, that's too low.
Can't go down below zero.
Let's go with like a 0 2.
0 2.
0 2.
You can hear that it changes quite drastically.
So, one is the default.
And what I'd like to do is go to maybe like a 1.1 or a 1.2 two for the second jump so that we jump and then the second jump is a little bit higher saying hey this is your last jump or indicating that so let's stop playing my values should reset on the audio source and we'll open up the player script in the player script when we do the jump right before we play the audio source we need to set the value of the pitch so what we're going to do is start with an if statement we'll say if jumps remaining is greater than zero so if we still have some more jumps left then we're going to set the audio sources pitch equal to one.
I got to spell pitch right, but if I spell pitch correctly, there we go.
That should work.
And we'll say else.
So, if we don't have more than zero jumps remaining, we're going to set the audio source pitch.
And I don't want to set it equal to zero, but I want to set it equal to something slightly higher, like a 1.2.
And I might need to add that F there to indicate that it's a float.
So now when we have more jumps remaining, it'll give us that normal sound until we're on our last jump.
That'll be slightly higher pitched.
Let's go try that out.
Make sure that we saved and let it reload our code and we'll play.
And watch that pitch value in here, too, because that's going to change.
You're going to notice the pitch value visually changing as we hear the effect when we jump.
So we click So you guys can hear that, right? Sounds good.
You've got an actual pitch modification.
And this should be enough to really give your players some good indication of what's going on.
Now, I want to show you something else very cool, though.
This is something not really related to audio, but something related to if and else statements.
You're going to find that this is a scenario that you're doing often where you need to write some code that does one thing if a if a certain condition is met and then does something else if that condition is not met.
It's very very common where you have a true or a false value.
So if we have extra jumps remaining, we're using a one.
If we don't have extra jumps remaining, we're setting the pitch to a 1.2.
Now, the way to do this in a shorter, slightly easier to use syntax is to convert it into what we call a turnary assignment.
And I believe I can alt enter.
Yep.
Turn it into a conditional expression.
That's what that's what I was thinking.
A turnary assign conditional expression.
We hit enter.
And then we get a pitch is equal to and then we've got a statement here.
So, let's take a look at what this is doing.
Says audio source.pitch pitch is equal to and then it's not assigning it to jumps remaining greater than zero.
That's not what's happening.
What's happening is this bit of code is getting checked.
So it's saying we're going to assign this pitch to some a value of something.
First do a check on this is jumps remaining greater than zero because if jumps remaining let's put this in some parenthesis real quick.
Make it even more explicit.
If the part in parenthesis is true then you use the first value after the question mark.
Otherwise, use the value after the colon.
That's essentially what this means.
It's a shortened down way to write out all of that if statement into a single oneliner.
So, it'll check this statement here.
Doesn't have to be in parenthesis, but it can be.
I put it in parenthesis just to make it easier to read.
So, if jumps remaining is greater than zero, it'll use a one.
Otherwise, it'll use the value after the colon or a 1.2.
Very common way to write code.
You're going to see this very often.
So, it's important that you understand it, see it, and just start writing it.
If you start to see a lot of else if statements in your code, look to see if you can turn them into conditional assignments like this.
It'll clean things up.
It be a little bit easier to understand most of the time, and it'll make it so that when you see this in the wild, it's easier for you to kind of grab right away.
You're not you're not thinking about it.
All right.
So, with that done, I'm going to save.
We're going to jump back into Unity.
make sure that we haven't broken anything, that the assignment wasn't backwards and we're not starting with a high pitch and then going to a low pitch or anything.
And if that's good, then we'll do our commit.
So, let's go check it out.
We press play.
And any second now, we should get our game view and jump.
Sounding good.
Let's try going on a platform.
And now let's try jumping without a double jump.
All right, sounds good.
Looks good.
Let's go commit.
So go into plastic SCM and we'll say that we um added pitch change to double jump and check in.
It's time for us to add more props and grow our level.
and we're going to add some props that allow us to keep working with the physics system and do some really cool stuff and then bring in some interesting new requirements like being able to see a much bigger world.
So, let's start by taking a look at some of the props that we have available.
If you look inside of our items folder and our Yeah, it looks like the items folder has a couple of them.
We've got some flags and some keys and some other things, but there's also one, I believe, in tiles.
We've got some locks.
We've got some lava, some ladders, some switches, and other things.
And the one that we're going to start with today is the spring.
So, we're going to take the spring object.
Just search for spring.
It should be under art and tiles.
Or go to the project view and search for the word spring.
SP R.
There we go.
Iing.
There's also a spring.
Don't use that.
That's the one that's already popped up.
The popped up version of the spring.
We're going to use the spring.
So, for the spring, what we're going to do is well, first just drag it out into our scene.
Uh, before I even do that though, I do want to double check that my pixels per unit is correct.
So, it's set to 128 pixels per unit here.
I'm using the fullsized version of it.
It goes all the way up to the top and it matches at that 128.
So, I should be able to just drag this in and see a nice looking spring.
Now, I'm going to add a collider to it.
Let's start by trying adding a box collider 2D and see what that does.
So add a box collider 2D.
And notice that this collider is kind of big.
It goes all the way up to the top above the size of our sprite.
And that's again because our sprite is bigger than the actual image.
It's taking up that full space so that it's the full 128x 128.
If we want to use a collider on here, we've got two options.
We can either shrink this in half and then move it down about 0.25, a negative 0.25.
That'll give me a pretty good box collider.
Or I could alternatively add a polygon collider 2D and that would give me a good collider that matches up perfectly too.
I'm going to go with removing the polygon collider and just having a box collider.
So I've got a nice square collider that matches and it's pretty good.
I don't need a polygon collider to to recreate this shape.
I think that that is just about close enough for me.
So we've got a spring in here.
And if I press play, I should be able to run into it and jump on top of it.
Let's go see.
All right.
Any second now, it should finish building and we'll be able to run over there.
Let's see it.
There we go.
Our player runs over.
I can run into it.
You can see I just kind of run into it and keep running.
And I can jump on it and walk on it just like a normal object.
Collider looks good.
So far, it seems okay.
I can even jump off of it.
That's perfect.
But I want to modify this now and make it so that when I land on this spring, my character bounces up really, really high.
To do that, we're going to add in a physics material.
We don't have to do any special code or anything like that.
We're just going to use the physics m system in the way that it's meant to be used and take advantage of some of the cool properties and and things that it can do.
So, I'm going to go to the assets folder of the project window, go to the root assets folder, rightclick, and create a new folder here.
and we're going to call this one physics.
This is going to store some physics related assets or data, specifically some physics materials.
I'll hit enter to go into it and then rightclick again in this physics material f or this physics folder.
And we'll choose 2D and we're going to find a physics material 2D.
I'm going to name this spring.
I could also name it bouncy, but I feel like naming it the thing that I'm going to put it on makes a little bit more sense.
And over here in the inspector, notice that we've got two fields, a friction and a bounciness.
You can probably guess which value we're going to crank up and which value we're going to turn down.
We're going to turn bounciness up to one, which is the same as 100%.
You can't go higher than one.
It won't matter.
And we're turn friction down to zero, which is obviously 0%.
Let's save.
And then let's attach this to our spring.
So I'll go to the spring.
I I saved a little too early.
And then we'll drag the physics material 2D into this material section of the box collider.
Make sure it's on the box collider or you can hit the little search and then go select spring.
Now I'll save one more time since I actually assigned the material.
And then press play and let's see if we can jump and bounce on our spring.
All right, look at that.
It bounces and I just kind of bounce.
And if I bounce from a higher spot, I'll bounce back up to that that same height.
So, here we go.
I've got some pretty good bouncing.
I've got a nice little spring here that I can use in some future development.
Now that the spring works, though, let's commit it to plastic.
So, go into plastic and make sure that we've saved our scene and say added spring with bouncy material and check in our changes.
In the last section, we just set up a spring and it bounces our character.
But what if we want to show that sprung version of it so that we can show that the player actually kind of bounced up and add a little bit more fun and feel to it? Well, we're going to need to do something a little bit different.
And in fact, it's time for us to start writing a second script.
So far, we've written all of our game code on the player.
And that's fine when we're starting out and when the game is small, but as things grow, we're going to want to write code for multiple different types of objects.
In fact, we're probably going to want to write multiple scripts just for our player as well.
So, we're going to need to create a new script for our spring that can do some visual swapping that can maybe change the way the sprite looks when the player bounces.
It's relatively simple to do, but we've got to get past that concept of multiple scripts.
So, we're going to need to add a new script to our spring.
We're going to go into our scripts folder first and create it.
So, we'll go to assets, go up to scripts.
I'm going to rightclick and choose create and choose a new C# script or just C# script right here.
We'll name this spring with a capital S.
S P R I N G and hit enter.
This should generate my file and I'll open it up in my code editor.
Just hitting enter should open up the code editor and find it.
If it doesn't, um, what I recommend is usually go back to Unity and then do it again.
most of the time the second time through it will find the actual file.
All right, so we've got our file right here, our spring class.
And if yours doesn't match, just remember that the class name right here has to match the file name here.
Make sure that they match.
If you messed it up, changed it, just make sure that they match afterwards, including the casing.
Get that exactly right.
So in our spring, we want to be able to change out the sprite on our sprite renderer.
So, what we're going to do is get a reference to our sprite renderer.
Check when we're colliding with a player, and when we are, we'll swap the sprite, and then when we're no longer colliding with a player, we'll swap the sprite back.
So, first, we're going to get rid of our start and update methods because we're not going to use either one of these in this class at all.
And there's really no benefit to having them here.
The well, the key benefit is that they're here automatically when we create a new script.
So, we have like a good starting point.
we know where to put things if we're new to Unity or we're just kind of getting started, not sure what to do.
But if we know what we're going to do, and here I do know what we're going to do, we can take all of that code right there and just hit delete and have a nice empty public class with no extra stuff in it.
So, what are we going to put in here? Well, we're going to start with some collision methods.
In Unity, we can get callbacks or method calls whenever an object collides with another object.
In this case, we want to check when anything collides with our spring.
and we're gonna want to know if it's the player.
And if it's the player, we're going to want to do some fancy flashy graphics things.
Well, there's semi flashy and fancy.
Let's take a look at what that looks like.
We're going to start with the on collision enter 2D method.
So, I'll begin by typing on collision enter and just let it autocomplete.
I didn't worry about the casing because I know autocomplete's going to find it.
I'm going to choose on collision enter 2D and hit enter.
I'll get this nice method private void on collision enter 2D with a collision 2D parameter named collision.
First, I'm going to delete the private keyword just because I don't need it.
And then I'm going to go down into our method on line 9.
And what we want to do is check the collider of this collision 2D object.
This thing is just some data that tells us what the collision was and gives us more information about the collision, like what hit it, what object it hit, what angle it hit at, and what point in the world, and so on.
But all we really care about is what hit it.
So, we're going to say if collision collider compare tag, and then we want to put in the word player.
So, if the collider has a tag of player, and we're going to talk about that in a moment, then we want to show our sprung version.
So, we're going to need to modify our sprite renderer and show a sprung sprite.
We'll do get component and get the sprite renderer.
And then we're going to set the sprite on that sprite render.
So, we'll say the sprite renderers.
equal to.
And here we're going to assign like a sprung sprite.
So let's say underscore sprung.
Now we're going to need to generate a field for our sprung sprite.
So I hit alt enter and generate a field.
And then we're going to make this a serialized field so that it shows up in the inspector.
If I do it just like this, sprung will be null or nothing or not assigned.
And this is just going to empty out our sprite.
That's not what we want.
We want a serialized field so that we can then assign a sprite to it.
Let's save, get rid of the star, go into Unity, and test this out and see what we've got so far, how it works, and then make a couple modifications.
So, we've got our spring class here.
We're going to need to attach it to the spring object.
Let's go select the spring.
I'll minimize my box collider and drag the spring script over here, and that will attach it here.
If you had a hard time with that, remember, you can hit add component and just start typing the word spring, and you'll find it as well.
Just make sure you only have one.
You don't want two.
Now, on our spring, we have a spot for the sprite.
And I told you I wanted the sprung sprite.
So, I'm going to hit the little search box and search for the word sprung.
Spr U N G.
And then go select it.
I can also remember use control and the mouse wheel to zoom in and see the the graphics of these.
But I'm going to choose sprung.
I will save and then play with control P because I don't want to click the mouse right now.
And then we'll go over there and touch that thing and see if the graphic changes.
You should expect to see though that the spring graphic on that sprite renderer right here is going to change to sprung and the visual will look different.
Well, not yet.
So, why didn't it look different? What happened? Why isn't it changing? Let's take a look at our code one more time.
We're comparing and checking for this player tag.
And we haven't talked about tags yet.
So, where are tags? Why is that tag not assigned? And what does it mean? Let's go look at our player.
Notice this untagged keyword up here.
This is the default tag that's on every game object when you create when you create an object.
It has no tags assigned just like it has the default layer.
It comes with untagged.
I'm going to go back to the player now.
Click the drop down and choose the player tag.
That tag exists by default.
It's one of the most common things people need to use.
So, it's just there.
You can, however, create your own tags.
If you go to add tag and then hit plus, you can start putting in your own special tags like environment or whatever.
And then when you go select your character, you'll see that tag show up.
Now, I'm going to go delete that tag because that's not a tag I actually want.
We will go through and do some tagging later.
For now, I'm going to clear out my tags, go back to the player, and make sure that he has the player tag assigned.
We'll save.
Press play again.
And now only when I collide with the player should I get that visualization change.
If I collide with another object or something, I shouldn't expect to see that that change on the spring.
So, let's run over.
Look at that.
As soon as I hit it, it changed.
Now, that's a problem, though, cuz it's staying permanently like that.
And that's not really what I want.
I want this to modify a little bit and uh just like change and then switch back when I leave the collision.
So, as soon as I'm no longer touching it, I want to kind of like bounce back down.
Let's go back to the spring code.
And just like we have an on collision enter 2D, you might have guessed there's an on collision exit 2D.
So I'll just go down here and type on collision exit.
And so I just typed on NC and I could find exit 2D right there.
I'll hit enter.
Delete that private keyword again.
And then here, let's just take lines 11 and 12, copy them, Ctrl + C, and go down to 17 and paste with Ctrl +V.
Now, I don't actually want to do that.
I don't want to set the sprite back to sprung if I leave.
I want to set it to the default sprite or the normal sprite.
And I got a couple ways that I can do that.
I could add another serialized field here and have like the default sprite.
But then I'm kind of setting it twice.
I'm setting it in here.
Let's take a look at what that would look like.
If I said default sprite and I saved, I would come over to Unity and then I would have two sprites down here and one up here that I have to assign.
Got to assign the one that's there and then I've got to assign the one that gets kind of reassigned or reapplied when I exit.
So there's the the one when we start, the one when we spring, and any second now, yeah, the default.
And I don't like that.
Instead, I want to take this value and have my spring just know about it and kind of fill in this default instead of having it be serialized.
So, let's go back to the spring.
I'm going to remove the serialized field from my default sprite.
And then I'm going to add an awake method.
An awake method is where we do a lot of our setup and initialization just like in the player.
And we're going to do that for our spring as well.
So, I'll type in awake.
I'll get rid of my private keyword.
Control and delete.
By the way, get rid of that whole word if I'm at the beginning of it.
And in our awake, we're going to say underscore default sprite equals.
And here I want to do something.
Get it from the sprite renderer.
And you might have noticed I've got get component sprite render.
Get component sprite render.
And I'm just about to write another get component sprite render, let's see, renderer, and get the sprite from there.
But that's not what I want to do.
I want to just save this sprite renderer off so I don't have to make this call multiple times.
So, I'm just going to take this get component part, cut it, add a new line, say underscore sprite renderer equals, and I'll paste in my git component call.
Hit home, alt enter, and generate a field.
And now I've got a cached sprite renderer in my spring class.
Delete that private keyword.
Just double click it, and hit delete a couple times.
And then let's take that sprite render, copy it, control C, the underscore sprite renderer, paste it right before the sprite.
So now we've got the sprite renderer, we've cached the default sprite right here.
And then in our other two parts where we call get component, let's just replace those with underscore sprite renderer so we don't have to make that semi-expensive call more than once.
The last thing that we need to do is reuse our default sprite.
So on collision exit, instead of going to the sprung sprite, we'll go to the default sprite.
We'll just paste that in.
So copy it from here and paste with crl +v.
And we'll jump back into Unity and jump around.
And let's see our spring bounce up and down.
At least that's what we should expect to see.
And this default sprite field could completely disappear.
All right, it should start playing.
And we jump over there.
Boing.
And you can see it bouncing.
And now we're getting that effect.
All right.
So, that is exactly what I wanted.
I'm going to stop playing, go into plastic, and commit that we've added a sprung effect.
Actually, first, let's make sure we've saved.
Go to file, save project as well.
Make sure that our tag manager and everything are in there.
Say added spring visualization.
And we'll check in our changes.
Now that we've got a spring, we have a little bit of a problem that our player can get pretty far offcreen.
If I take my spring and I drag it up here onto one of these higher platforms, and then I go jump onto that, you'll see just how far off screen I end up.
So, we're going to need to do something to address this.
Let's go reproduce it, though.
Make sure that it all makes sense, and then we'll dive into some possible solutions.
So, here we go.
I jump up.
I jump up and I jump on that spring.
And yeah, my character's way off the screen.
You can see that I'm just flying way up here outside of this camera view.
Remember, this white box is showing us the camera.
If you don't see it, you can turn the gizmos on and off right here with the little world looking icon.
And we need to make it so that our camera now shows our player all the time because what's the point of showing a game where we can't see our own player? Need to be able to see our own player.
And to show our player, we've got a couple of options.
The first option is actually really, really simple.
If we have our player kind of where we want them to be in the world all the time, like they want to we want them maybe centered.
Let's move them over to a zero.
And right at about that height, we can take the main camera, drag it down to be a child of the player by dragging it and dropping it on top of the player, and then press play.
And now the camera will move along with the player.
This is somewhat effective.
Let's go try it out.
So, we're in and any second now.
There we go.
I can run around and yep, you can see I can definitely see my character all the time.
I can't really see the bottom of the world and it's not a perfect camera setup, but it's a definitely a little bit better than what I was seeing before.
There is a better solution though, and we're going to dive into that now.
So, let's take the main camera, drag it out, and then we're going to go to the window menu and choose package manager.
The package manager window should pop up and it should look something like this.
In the top left, you've got a couple options.
There's in project, there's my assets, and then there's a Unity registry option.
Choose the Unity registry option from the drop down.
And then scroll all the way down.
So, you've got all these options up here, features, these big packs full of stuff, and all of these packages.
You can see some are already installed.
The green check mark means that that package is already installed in this project.
And you see we've got a lot of the 2D ones already there cuz we're building a 2D game and they came with our 2D template.
So we need to scroll down until you find Cinem Machine.
If you don't find it, you can always search for it here.
Cinem Machine.
And currently it's on version 2.9.
There is a version 3 that's just about to release, but it's still in a beta.
So I'm not going to jump into it yet.
But just know that it simplifies things a little bit when you get into the deeper Cinem machine controls and makes it easier to write code with it, but it still has all of the same functionality.
So, we're going to choose the install button and install the Cinem Machine package.
This is a camera management system to do super advanced or super basic or whatever type of cameras you want.
You can do cameras where you're following multiple players, where it's transitioning and fading between them, where it's, you know, doing cinematics, all kinds of interesting, cool stuff.
But we're going to start with something very basic that gives us still a lot of just nice feel and a really good look for our game.
So, we've got our Cinem Machine package.
It just finished importing.
And I'm going to go save my scene.
And then go to window.
No, game object.
I lied.
I'm going to go to my player, right click, and I'm going to choose camera, Cinem Machine, and 2D camera right here.
So, I'll go to Cinem Machine, 2D camera, and it's just going to create a child object that's a camera of our player.
And it's going to have a follow field on it, a look at field, and a bunch of other stuff.
I'm going to now take my player and drag that into this follow field.
Look at that.
My player is now centered right in the middle.
And if I press play, this alone is going to give me a decent camera control.
I'll be able to see my player and move around.
Let's go check it out.
All right, there we go.
As you can see, I can jump around and there's a little bit of smoothing there.
It's not just instantly super tight with my character.
Feels quite a bit better and it flows, I think, quite a bit better.
But I don't like how high up I am.
So, I'm going to make a little modification.
I'm going to expand out the body section.
And now I can see where my character is moving around and where it's kind of locking in and see where the center of the screen is.
And we're going to modify this tracked object offsets Y value.
I'm going to put a value of about 1.5.
And now my character is down kind of closer to the bottom of the screen.
I think that that looks pretty good.
I'm going to stop playing now.
Read my 1.5 because I was in play mode.
So my changes didn't save.
Go select my player so that I stopped seeing the preview.
Save.
Press play.
And try one more time.
and see what my character looks like and feels like kind of moving around with the new camera control setup on.
There we go.
I can run, jump, jump, jump, and bounce and start to bounce higher and higher and higher and so on.
Look at that.
Now I can bounce up super high to the sky and still fall down and see the ground as I'm falling.
With that, I'm going to save my scene again and do another commit and say that we added cinem machine camera control or camera system.
Say that and we'll check in our changes.
In this lesson, I want to present a small challenge to you.
The challenge is pretty simple.
Take the spring and make it so that when our player jumps on the spring or bounces on the spring, remember they're not actually doing a jump.
We hear a sound effect.
This sounds kind of like our jump, but much deeper.
See if you can figure out the code and the setup process to do that.
You shouldn't need to import any new files, but you're welcome to if you want to.
And then come back when you're done and I'll show you the process on kind of my way to do it and see how well it lined up.
Also, if you get caught, you have any problems, get stuck, or any questions, feel free to just press play and follow through.
All right, let's dive into the solution.
The first thing I want to do is select my spring.
We want to add an audio source so it can play some sound effects when it's hit.
And I'm going to do that by just choosing the add component, typing in audio source.
Go choose audio source at the bottom.
And then we've got to put in an audio clip here.
So I'll hit the search box and go find my one audio clip that's in my game right now, the jump 01.
I'm going to uncheck play on awake because I don't want this to make a sound from the start.
And I'm going to turn the pitch down to something like 0.5.
Now, I should be able to hear this thing sound super deep when I land on it.
We haven't written the code to make that happen yet, though.
So, let's open up the spring and do that.
In the spring code, when we get a collision, we'll just get a hold of our audio listen or our audio source and tell it to play.
So, we can add in some braces here after line 19 and before 23.
And then after we've set the sprite, we can get our audio source.
So get component.
See if I can spell get component.
Get component.
Audio source.
And we'll tell it to play.
This should do it.
This should make our spring start playing whenever we jump on it and land on it if it's a player.
Let's go see if that's the case.
So we jump back into Unity.
I want to make sure that I've saved my code and my scene.
gotten rid of both of those little stars there.
Soon as it finishes recompiling and then press play, it should be able to bounce off that spring and then hear a nice deep boing or something similar to that.
Let's go check it out.
All right, we run over.
Jump.
Jump.
Whoops, missed my jump.
Let's do a bigger jump.
Jump.
There we go.
And I can of course modify this by turning the pitch down even more if I want.
Go to like I think I kind of like that better.
025.
So I'm going to stop playing, change this to a 0.25.
Save my scene and then go back and make one other change because we've been caching a lot of components lately.
We did it right up here.
We cached the sprite renderer, but we didn't do it for this audio source.
So, let's cache our audio source as well.
Even though we're only calling it on collision enter, I feel like it's a little bit cleaner to just cache this in awake since we're caching our sprite renderer too.
So, we'll take the get component call, select it all, hit Ctrl X, go right up above, right at the end of line 12, and hit enter and say underscore audio source using that camel case again.
So, source is capitalized equals and then paste and semicolon.
Hit click on the audio source part here.
Hit alt enter, generate that field.
Should give us a nice private field that we can double click the word private and delete.
And then put the audio source by double clicking it, copying it, and pasting it right before the play.
So now we have the audio source gets cached in awake and saved.
So we can just reuse it instead of having to tell the Unity system to give it to us every time we need it.
We'll save, go back in, test it one more time, make sure that it works before we commit because we don't want to commit it if we accidentally had a typo or broke something.
Any second now it should finish and we'll play.
Oh, I probably should add some more springs and start bouncing around between them.
But for now, let's just play jump up and make sure that it sounds right and jump.
All right, so that looks good.
and sounds good.
The last thing I want to do is just move this spring.
I don't like the position of it.
So, I'll go to the scene view.
Select the spring.
I'm going to drag it down here.
Holding control.
Let's get it to a negative 4.5 and a negative what? Three.
No.
Whoops.
I put I hit the wrong key there.
-3.
Let's zoom in a little bit.
I think it might be negative 3.5 that I want to go to.
So, I'll hold control and drag with the mouse right here.
Remember, this is W to get into move mode.
W here.
E for rotation, W for move.
And you can see this is pretty perfect here.
So I've got a negative 4.5, negative 3.5, and then in my game it looks like it's nice and flat on the ground.
So we'll save.
We'll go into plastic and say added sound effects to the spring and checking our changes.
Now we're going to do some level building.
We'll start by pulling in a background, tiling it out, and then add some platforms, some things to kill our player, and try to make this kind of fun so that we've got some challenges and we can start tuning things.
Let's start by going to the art and backgrounds folder.
And then in here, we've got, I believe, eight different backgrounds to choose from.
I'm going to go with colored grass.
I think the one with the giant mushroom looking things.
And drag it right out into my hierarchy.
I'm going to drag it right here into the center or this empty area so it gets positioned at 0 0.
Now I'm going to switch it over to be tiled instead of simple on that draw mode.
Remember that's on the sprite renderer.
And here I'm going to change the tile size from being eight on the width to maybe like an 80 so that it's nice and wide.
If I go to my scene view, I can zoom out and see, okay, I've got lots of room to work with.
If I want to make this bigger though, I want to make my level giant, I can of course just continue to crank that number up.
I can make it 800 or something else.
And yeah, look at that.
That's just way too big.
So, I'll drop it back down to 80 for now.
It's easy to adjust, though.
It does say that the thing might not appear correctly because it's not set to full wct mode.
You can tell that it does appear correctly, but I'm still going to go back over and set all of these over to full wctck mode anyway.
So, I'll go from tight on the mesh type to full wctck, which is just going to make it pull in the entire thing and not try to crop anything.
There's nothing for it to crop.
So, it shouldn't have an issue.
It shouldn't get any weird stuff, but I just like to set it up so that the error goes away at the very least.
Now, we don't have that warning there.
And if something changes with that background, we'll know about it at least.
All right.
So, we've got a background here.
And what happens if your background is showing up in front of stuff? Cuz it's very possible that you drag it out and your background is showing up in front of one of your platforms or in front of your player or something else.
Well, look down here at this additional settings section of the sprite renderer.
Here, I'm still on the colored grass.
Got additional settings expanded, and I've got an order in layer.
If this value is set to something like one, it's going to appear in front of everything else that shares the sorting layer with it.
If it's set to zero, it's going to be kind of random.
Everything that shares the sorting layer with it will be placed there, and you don't really have a lot of control.
You're not really controlling what's on top of another thing.
Some things may be on top of others.
Some things may be below others.
We can also set it to a negative one.
Get rid of that zero.
Just put in a negative one.
That would force it to be back behind anything that was a zero or higher in the order and layer.
Let's set this back to a zero real quick and take a look at one of the other objects like this platform here.
So, if I go select my platform, you see that it has an order and layer of zero as well.
So, it's showing up just kind of randomly in front.
If yours isn't showing up in front, you can go set this to a one and then it would show up in front.
If I set this to a negative one, again, look, it disappears, but my other platforms and everything else are still in front.
Now, this is not the way that we want to do it.
We don't want to go through order and layer for all of the sprites and set them to the correct layer or anything.
Instead, what we want to do is add in a new sorting layer.
So, when we click on the sorting layer option, we've got default and add sorting layer.
I'm going to choose add sorting layer.
And don't worry that I'm on grass mid right now.
I'm just going to hit add sorting layer and it's going to pop up my dropdown.
And do you remember how we added a player here? This was for physics.
So the physics layers are called layers, which is a little bit confusing.
It'd be nice if they were just called physics layers probably.
But since there weren't sorting layers before, they were the only type of layers.
So our player is not what we want.
We'll minimize that again.
And we're going to go to our sorting layers again.
Sorting layers are the layers that we use for ordering sprites and determining what's on top of another.
You can see we've got a default one in here kind by default, but we can hit plus and type in a new name for our new one.
I'm going to call this background.
And then we're going to assign it to our background.
So, let's go find the background, the colored grass, and then we'll go to the sorting layer and choose background.
And notice that it popped up right in front of everything.
And that's because our background layer is set to draw on top of our foreground layer.
Let's go back to the sorting layer menu again.
I'll just hit add sorting layer.
And this gives us our tags and layers window.
And here we can just take layer 1 and drag it up here so that background is now layer zero and layer 1 becomes the the default.
And now background will draw and then default.
And I I'm going to definitely want to add more layers here, but we'll do that as we add things that need to be on layers.
For now, we're going to save our scene.
make sure that we've saved our project as well so that our layered file gets saved.
You can see that this got marked as checked out and then we'll go into plastic SCM and we've got all of our backgrounds that have changed to full wreck the level the tag manager and ready for a commit message.
So say we added a tiled background to level one and checking our changes with the background in.
You'll probably notice some weirdness at the bottom and top of our level.
Let's go check it out.
If I run around, you see that uh right at the top of my tiled level, I've got this big blue area.
And then down below my level, I've also got this big blue area.
Let's stop playing, look at the scene view real quick, and see what we've got here.
So, that blue area isn't something that's being drawn.
You can tell that's just the background or the default.
That's why you don't see anything here.
But what could we do to fix this? The first thought might be to go to our colored grass background and just tile the background.
Maybe we go 80 and 80.
But you can see that well that doesn't look right at all.
Even if we went with a value that got that center in the middle for us, I think what like a 75ish maybe or somewhere, it's still not going to look right because we've got more ground up above and more ground down below.
So let's set that back to an eight and look for another solution.
Now the background that we're seeing right here, this blue, is actually being drawn by our camera.
So, if we select that camera in our hierarchy, we can actually modify it.
Look down here on the right.
We've got our camera.
We've got projection rendering stack.
And right here, environment.
If this is collapsed, just expand it out.
And look at the background type.
We've got a couple options here.
Skybox, solid color, or uninitialized, which means don't do any background.
We don't want solid or skybox or uninitialized.
We do want a solid color.
And the solid color we want is going to be something that matches with the top of our sky.
So, we want to go with a color that kind of matches the top there.
To do that, I'm going to click the little eyropper and then put my mouse right over here so that I get a color.
You can see it kind of previewing in the background section and click.
And now I've got that matching color as my background.
You can see it's showing up in the preview here on the bottom.
I'm going to save my scene with Ctrl S.
Press play.
And then let's go jump around and see how that looks.
If we've got some cool looking sky.
Oh, we've got sky down below.
Not quite what we want, but up above.
I think that's looking pretty good.
We've got a nice big big blue open sky.
And if I go to my scene view, or I guess you can't really see it in the scene view, but in the game view, you know that we have it pretty much going on indefinitely.
The ground, however, is unimpressive.
I don't want the sky down below me.
I mean, you might want the sky down below you depending on your game, but in my game, I don't want that.
So, I'm going to add some ground down below as well.
Let's do that by finding our ground tiles.
First, we'll select the grass mid and go click on the sprite to find it.
It finds my art ground and grass folder.
And if we scroll and zoom in, remember control and the mouse wheel.
Look for this grass center.
This is a perfectly set up tiled sprite to allow us to do big ground pieces kind of underneath the grass.
Says grass center.
It kind of looks like dirt, but you get the idea.
Let's drag this into our scene view.
I'm going to drag it right about here and see where it drops into.
And notice that it's not going to be at some even value on our position.
The x and y are this 9.55604 and 5.73.
And these are negative values as well.
So I'm going to just kind of round these off.
I'll take nine and go to 9.5.
Ah, that looks about right.
And take change this 5.72.
Let's go with maybeg -6.
No, 5.5.
So that it comes up a little bit.
Now that this is in place, I'll switch it over to be a tiled sprite.
And then let's maybe adjust the width here.
So, what's the width on our tiled sprite here? This grass mid 20.
I'm going to change this one to be 20 as well.
It's going to move though.
Watch this.
So, I go 20 and oh, it's no longer centered to where I want it to be.
So, I can just hit W, click on it, hit W, and then hold control and drag it over here.
This will allow it to move and snap by quarter unit increments.
You can adjust that snap setting right here.
in the where's it at? One of these ones has grid and snap settings allow you to modify it, but I want to leave it all just at the defaults for now.
So, we've got our ground here underneath.
And if I go to my game view, you can see that it looks better.
But if I fall down, let's hit play and see if I fall down or jump a little bit.
I'm still going to see underneath that.
So, I'm probably going to want more.
But I I want to show you.
There you go.
See the camera drops.
We still see some ground there.
So, let's stop playing.
Go back to the scene view.
Select this bottom ground piece.
this grass center.
Hit T.
And then I'm going to hold control and grab on the bottom here.
This is going to allow me to adjust the tiling.
Watch the height here as I drag it.
The height and the position really because the position is going to change along with the height so that it keeps tiling and staying at the same locked spot so that it doesn't move.
So there we go.
I've got it to Let's go to Oh, I'm going to I've got it at a five.
I think I'll go to a height of like 10 so that it goes down nice and deep.
That way, if I want to add some water or some lava or other stuff down below, I can do that and it'll it'll still look cool.
All right, so there we go.
I've got ground and deep or deep ground here along with my grass.
I want to add one more thing, though.
Well, first I want to change this sprite tiling issue.
So, I'm going to select all of the sprites in my ground grass folder.
Let's go to list view here so that I can see them all.
Make sure they're all collapsed because if they're expanded, it won't work.
I'll hit control A, select all, and then we're going to change this mesh type to full wreck, and hit apply.
That way, I'll get rid of that warning that was popping up here.
Now, I'm going to save my scene one more time, and then I'm going to go to plastic SCM and say that we've added deep ground and commit.
Oh, get rid of that extra letter there.
And commit.
Now that we've added some deep ground, let's add an obstacle for our player to jump over.
Let's add some water right here to the edge.
We'll go back to our project view and we're going to find our water.
We've got that in here somewhere.
I can kind of scroll through and look for it.
I think it might be under tiles.
Let's see.
Is it in tiles? Yep, there we go.
In tiles.
And I've got a water, a water top high, and a water top low.
Let's zoom in so we can get a better look at these.
The water is that solid view kind of like we've got for the ground for deeper water.
The water top high is a full water that goes all the way up to the top and low is obviously a low one.
We're going to start with water top high.
Drag it out here right next to the grass that I've got.
So I'll drag it out and kind of snap it into place.
Again, I'm going to just even out these positions.
So I've got a position of 1049045.
So, I'll change that to 10.5 so that it's snapped perfectly into place.
Watch what happens when I do that, too.
Look at the position right there.
Change that to a 4.5.
And now it's perfectly lined up.
And I'm going to change this to be -4.5 -4.5 -4.5 so that it's perfectly lined up as well.
Now, we're going to tile it.
To do that, we've got to switch over to tiled mode, of course, and then drag it out.
So, when it's in tiled mode, actually, you know what? This time, let's not drag it out.
Let's do it the other way.
Let's set this to a value of maybe eight.
Not eight, not 58, but eight.
I'll select eight there.
And then I'm gonna hit W.
Well, click over here on the water.
Hit W, hold control, and drag it over here.
So now I've got this water that I think is probably about the width that I want it to be.
I'm going to add some water down below it by clicking on the water here and dragging that down.
Let's just drop it right about here.
Find the correct tiled snapped position.
So we've got a 10.5 here.
It looks like we've got some extra ones.
So, we'll just get rid of those and go to 10.5.
And here on the Y position, we'll go to 5.5.
And again, I just look for the closest value that's within my snapping.
I want to snap by.5s or whole numbers.
So, I try to find the closest number in there that makes sense.
And if I guess wrong, I go the opposite direction.
All right.
So, I've got that in.
I want to tile this sprite as well.
I'm going to change the draw mode over to tiled.
Click on it and hit T, which is going to put us into our rect tool mode so I can hold down control and drag and snap it.
So, first I'm going to go to the right, click and drag and let it tile out.
Then I'm going to go downward.
Before I go down though, I'm going to hold the middle mouse and just kind of scroll down a little bit.
There we go.
And now click, left click, controll, and drag.
And let's go a little bit more.
I'm going to zoom out and do the same.
Controll leftclick and drag until it lines up.
Now I've got some beautiful water there.
Let's save.
Press play.
Go run into the water and see what happens and and how that all works.
So we run run.
Come on.
Come on character.
There he goes.
He goes running running and falls down.
So we're going to need to make a little change to our water.
Add something to allow him to bounce or float or something so that he's just not falling down through the ground.
The first thing that we're going to do is add a collider.
We'll start with a simple polygon collider.
A polygon collider 2D.
If I zoom in, this is again on the water top.
We don't need this on the bottom part.
If I zoom in, you can see that we've got this collider here, but it doesn't line up with our entire object because we haven't checked the autotiling box.
If I check autotiling, now I've got a collider that lines up with my sprite renderer kind of pretty closely and will allow me to run on this thing.
Let's try that.
Let's go turn on the sprite renderer.
Hit play.
Run over there and make sure that we can run across the water.
That's what we should kind of expect to see now.
So, we go over here.
We get onto the water.
And there we go.
We can run on it.
It's a little bit bouncy.
That's pretty good, but not quite what we want.
We want this water to be bouncy like actual water.
So, to do that, we're going to add in another component.
This is a built-in component part of Unity that makes this really, really easy to do.
We're gonna first well first let's go to the water the water top high and the water top low and change all three of these to be full wrecked and hit apply.
So that way our warning here goes away.
When I select the water top high we no longer have that warning there.
Now I'm going to collapse the sprite renderer and we're going to add another component.
We're going to add anector and we want to add a buoyancyector specifically.
So I'm going to clear this out.
Hit just hit the backspace there to remove the search.
Go to physics 2D and we're going to look for buoyancy 2D.
This is anector or a special component that you can add on to a collider that will make it allow you to well it makes it act like buoyant water that will bounce objects back up that fall in it.
So let's click the buoyancyector 2D and take a look at what it says here.
So we've got a use collider mask check box that's checked and a collider mask checked everything.
Okay.
We've also got this warning here.
It says the aector will not function until there's at least one enabled 2D collider with used byector checked on this game object.
What that means is that for this aector to work, it has to know which collider to use.
And you can have multiple colliders on a game object.
So we have to check the used byector box on the collider that we want to use for our water or our buoyancy.
So, I just check this box, used byector, and then we should be able to press play and run over and have our character bounce along in the water.
Let's go try it out.
Notice that we've also got a density and a surface level.
Those are variables that you can adjust to determine how buoyant it is and how high up the character sits.
Now, there's one issue still going on here, and it's that I haven't checked the is trigger box.
If I check his trigger, like that, my character starts to fall down and everything is looking pretty close to how I want except for my character kind of shows up in front of the grass or in front of the water.
I can jump out of here.
Everything looks pretty good.
Let's jump out and then let's figure out how we can fix this.
But also, don't forget the is trigger checkbox when I stop playing is going to get unchecked.
So, first let's recheck the as trigger checkbox.
And then let's figure out how we can move this water to the front so that it's in front of our player.
Remember our sprite layers.
Let's go to the sprite renderer.
Let's go to the sorting layer and hit add sorting layer.
We'll hit the plus.
We'll add a water layer.
And then let's even add a player layer.
Let's take the water layer and make it draw after the player layer.
And then we'll go select both of our water objects here.
change them over to be on the water layer.
And then we'll find our player and let's change our player to be on the player sorting layer.
Save again.
Crl S.
So again, we've got our water, both waters on that water sorting layer.
Let's go hit the add sorting layer again.
Take one more look.
Background default player and then water.
Hit that plus button to add them.
And then we've got our player set to the player sorting layer.
If I press play now, I expect that my player will kind of disappear behind the water.
Let's see if that's the case.
So, I run over here, get to the water, and look at that.
I'm kind of back behind the water.
I can run around and bounce around and eventually fall off the edge of the world because that's as far as I've gone.
Let's now save and go into plastic and say that we've added water to our game.
So, added water to level one and check in our changes.
Now that we've got bouncy water, let's make it a little more interactive and add some sound effects to it as well.
To do that, we're going to need to download some sounds.
And I like this effect set right here, this 40 CC0 water splash and slime effects.
So, I'm going to download this slime effects sound pack.
It's really for the splashes.
And then we'll open up that zip file.
I'm going to look in here, and I think what I'd like to grab is splash number 11 or 12.
I think I'll go with number 12.
So, I'm going to rightclick on it and choose copy or hit control or command C.
Now, I'm going to go back into Unity.
So, I'm going to minimize all of my windows.
Go down to my assets folder and then go to audio, rightclick, choose show in explorer to get this window open and go to the audio folder, rightclick, and paste.
Of course, if you don't see this or you have a different way that you like to do these, um, feel free.
But I'm going to choose paste right there.
If you have a better way that that you like to get files out of zips.
Feel free to do it however you like.
You just need to get it into your audio folder.
Once you do that, you jump back over to Unity.
You should see the sound effect here and be able to click the button here to play it.
There we go.
Now, I want to add this to my water.
I've got a bunch of different ways to do that.
I've got my water here.
I could go down to the bottom and hit the add component option.
I could drag the splash onto it right over here.
I can also drag it onto the scene view here and drop it right on top of this.
I want to show you that, but just be wary when you do this because if you drop it onto another object or there's something in front of it, it's very easy to pop it onto the wrong thing.
But since there's nothing in front of this, I knew it was going to be okay.
And my audio source went down right on the object I expected.
Now, if I hit play, all I'm going to hear is that sound effect play once when we start because play on awake is checked.
Let's hear that.
Cool.
But not what I want.
So, we're going to uncheck play on awake, minimize our audio source, and we're going to need to add a new script, something that plays an audio clip whenever we enter the trigger.
To do that, we'll go to our scripts folder.
So, go up to assets, go to scripts, going to rightclick, choose create, make a new C script, and let's just call this water with a capital W and name it for what it is.
If it becomes something more generic later, we can always rename it.
That's one of the cool things about code.
you can easily or usually pretty easily rename and adjust things to match the new context as stuff changes.
So, we've got our water script created.
I want to attach it to the water top high object.
So, I've got water top high.
I'm going to hit add component.
And look at that.
I've already searched for water, but if I search again, water should show up.
I've got my water script now added on.
And I'm going to save my scene.
Last thing I want to do is open up my code editor.
I'll do that by double clicking the water script.
I can do that right here or down here.
Let's just do it in this spot.
And I should get my code file just like this.
Again, if it doesn't open up the first time, just go back to Unity, double click it again, and it should find it.
Sometimes it doesn't get to the file initially or immediately when you double click on it the first time.
Seen it happen quite more than once at least.
All right, so now we've got our water script.
And our water script by default comes with this start method and this update method.
We don't want to use either one of them.
So, we're going to begin with something that I do often when I'm creating new scripts, which is deleting the start and update method.
So, we're going to select here from the beginning of line seven.
So, I'll hold down the left mouse button, drag all the way down to the end of line 17 so that it's all selected, everything except for those braces, and hit the delete key.
Now, we have a nice empty tiny little class.
We've got a class that does absolutely nothing, but it's ready for us to start writing some code in it.
And the code we want to write is a trigger enter check.
So, we'll say on trigger enter 2D.
And I'm not going to type in the casing because I know it's going to allow me to autocomplete.
But we do need to have capital O N capital T R I G E R and then capital E for enter.
And then 2D with a capital D.
You also have to have the collider 2D part and the collision parameter here.
I'm going to delete the private keyword here.
And then we're going to deal with our trigger enter.
So this code will get called whenever our water's trigger area, that buoyancy area is entered by any object.
So the first thing that we want to do is make sure that we only splash for the player.
Actually, do we want to only splash for the player? No, let's splash for anything.
Let's just make it so that whenever anything enters our trigger, we'll play a sound effect.
So to do that, we'll get our audio source.
We'll say get component audio source.play.
Save that off.
And now if we jump back over to Unity, I think that's really all we needed.
We could add a lot more.
We could make it more complicated, but as it is now, if anything lands in our water, I want to play a sound effect.
So, let's hit play.
We've got a sound effect gizmo on there.
Remember, if you don't see the gizmos, the little button was up there.
Let's run over here, though, and jump in the water and see if we get a sound.
Pretty cool, right? And if anything lands in the water, it's going to get the sound effect as well.
So, let's stop playing, make sure that we've saved our scene, go into plastic SEM, and say that we've added splash sound to water and check that in.
Now that we've got water and a little bit of an obstacle and some ways to jump, let's set up a little level where we can jump across the water and try to get to the end.
So, I want to do that by making some more platforms.
And I've got a couple of platforms here.
I've got my grass mid, grass mid 2 that I've duplicated.
And I could just hit control or command D, duplicate another one, hold control and drag this platform over.
Hold control and hit D again, make another one, and make another one.
And so on until I've got platforms kind of going across the top.
Okay, now let's add some on the ground.
I'm going to take my grass mid and I'm going to take the select it and hit control or command D.
Hold down control and drag it over till it snaps right over here to the right side of the water.
And then I'm going to do the same for the bottom, the grass center here.
I'll hit control D with it selected.
Hold down control, drag it over, and you can see the position looks like -28 and then -10.
So now I've got this nice, beautiful level with a couple platforms I can save.
I should be able to now run across and get all the way from one side to the other.
Let's see.
So, I come over here.
I jump.
Jump up.
Jump.
Jump.
Jump.
Jump.
Oh, almost didn't make that one.
Let's see.
Can I make all these jumps? That's pretty easy.
And I land down here on the other side.
So, this is working.
Okay.
And I can also kind of wiggle through the center.
And I could keep building out my level like this for as long as I want, but it's going to get very problematic very soon.
As you can see, my scene hierarchy is already starting to fill up.
If I start to make a whole bunch more of these grass objects and just keep dragging them out here.
Don't don't copy this part, by the way.
And dragging out more of these platforms and duplicating them and duplicating them.
See that this part's going to get really filled up really quickly.
We're going to have a ton of stuff in our hierarchy.
it's going to get hard to manage and maintain, but we're also going to run into some other issues the second we want to do some updates to our game or change anything in it.
So, we're going to make a couple of minor changes to our workflow.
Now, first thing I'm going to do is delete out a couple of these extra platforms that I've just made.
I'm going to leave this grass center and we'll we'll leave those pieces here for now.
And in our scene hierarchy, we're going to rightclick in the empty area and we're going to choose create empty.
What we're going to do is create an empty game object that's going to work like a folder for our environment.
I'm going to name this thing environment, not game object.
And then we're going to reset the transform.
So go to the transform, rightclick, and choose reset, which should zero out the position, rotation, and set the scale back to one.
So now that I've got this environment object, I'm going to take all of my sprites that are part of my environment.
So that's all of my grasses all the way.
All of my waters and my grass center and the colored grass.
So click here on the bottom one, hold shift and click on colored grass up here.
If you have other things in the way, it's okay.
You can hold control andclick them.
Now I've got all of these selected.
I'm going to drag them and make them children of the environment by dropping them on the environment.
The second they become children of the environment, you'll see that there's an arrow here.
They're expandable.
And now I only see them when I expand out the environment.
I'm going to take these other grass pieces and drop them on environment.
Make sure that you don't drop them on the wrong thing.
If I drop it on colored grass or something, it's going to be not where I want it.
So, I'll click and drag it up to environment.
Drop it onto environment.
I want to make sure that they're all just children of this environment object.
So, now everything except for my player, my spring, and my main camera are children of this environment.
And we're going to do this going forward.
You'll find this a lot of the time in game development projects where especially in Unity.
The game objects are used as folders for organizing your scene hierarchy.
You could have, you know, a thousand things in this list view and if you have to scroll through everything, it's going to make it very difficult to find anything and make it kind of useless.
You'd have to use the search box every time to find anything.
If you have a thousand objects in there, unless you've got a hierarchy that kind of allows you to drill down and expand and find the specific things you want.
So, I know that all of my environment things, the the background and world are going to be in this environment folder.
The spring I've left out because it's more interactive and it's a little bit different.
I want to make sure that that's in its own section.
Now that I've got my environment section, I'm going to save my scene.
We'll go into plastic SCM and then we'll say that we added environment folder and more platforms plus ground.
and we'll check that in.
Now, we're going to continue building, but we're going to dive into one of the most important Unity system.
That's the prefab system.
We're going to start by replacing some of our platforms and creating some platform prefabs.
Let's start by clicking on this platform over here, the one that's directly over my player.
Looks like it's named grass mid one.
Right now, what I'd like to do is add some rounded corners to it so our player can jump up and have it look a little bit better and feel a little bit better.
Have that kind of curve on there.
First thing I want to do is adjust the tile size of this thing.
I want to shrink it down.
I'm thinking I'm going to make it four wide total, including the two blocks in the middle.
So, I'm going to adjust this width from three to two.
And then I'm going to go find the sprites for the edges.
So to do that, I'll click on the sprite here, this grass mid, and it should pop up in the project view down below.
I'll take my grass right that's next to it, and I'm going to drag it on to be a child of this grass mid, the one that I have selected.
This should place it right up here at the top, which is not really where I want it to be.
So I'm going to hold control, grab the little blue bar here, the little blue box, and drag it down where I want it, which should be at a 1.5 on the X and a zero on the Y.
I'm going to do the same for the grass left.
drag it onto this grass mid object so that it becomes a child of that object.
And here I'll go over and type the values.
And I'm going to put it at a negative 1.5.
Move it over that other half a meter because the center of this object is right here.
So it's one meter over and then another half for the center.
And then we'll set that Y to a zero.
That should not two zeros, just one zero is enough.
That should give me a nice pretty platform.
Now I'm going to go to my grass mid and I'm going to rename it.
I'm going to click one more time, hit F2, and I want to call this grass platform 4 because it's four units wide.
Now, let's turn this into a prefab.
We're going to go to the assets folder.
We're going to rightclick on the empty space, choose create, and choose folder.
We're going to name this prefabs.
And you're going to see this a lot in Unity projects.
There are very often prefab folders.
Sometimes it's off the root of the project.
Sometimes there are prefab folders in subfolders, but we've got a prefabs folder.
Now we're going to hit enter to just go into that folder or double click on it and then take the grass platform 4 and drag it in and watch what happens to it.
It turns blue.
It turns blue because now it is referencing a prefab.
And if we go click on this platform, you'll see over here that in the inspector, we now see the prefab that we're referencing.
We have an overrides option, a select option, and an open option.
And I can click on this to kind of go find it in there.
I can click select to find the object and select it in the inspector or find the prefab.
Or I can hit open to go into prefab edit mode.
If you find yourself in here, don't know how to get out, just hit the back arrow right over here in the hierarchy.
Knock you out of prefab edit mode.
We'll talk more about prefab edit mode later, though.
For now, we want to modify our other game objects or our other platforms.
We want to make them be objects that are just like this grass platform.
And to do that, well, I could maybe go in and select all of them and then delete them and then maybe duplicate and put this object in those places, but that's probably not the best way, especially since now I can just have them all selected.
Rightclick, choose prefab, and hit replace.
This will pop up a dialogue that shows me all of my prefabs available, and I can choose the grass platform 4 right there.
Double click it.
And now I've got platforms all the way.
Let's save, press play, and go see if we've got any weird issues or problems, though.
So, we're in play mode.
We run over here.
We jump.
And oh, look at that.
There's no collider on that edge piece.
And that's the same for all of these.
The collider is missing there.
So, let's stop playing and think about how we can fix this.
The best way to do this, well, there are actually a couple ways to do it, and they're all kind of the same, but one of the most interesting and newest ways to show you to do this is to just go to our prefab and doubleclick on it.
If we double click on it, this will show us our prefab edit mode.
This is the one I was just telling you about.
We can expand out the prefab here and see the left and right child.
I can also zoom out and notice that there's nothing around here.
This is just a view to show me just this prefab with nothing else.
So the left and right objects don't have colliders.
All we need to do is select them both.
So I'll select grass left and right.
And I'm going to do them both at the same time so I don't have to do it twice.
And I'll choose add component.
And oh look, I've already got a polygon collider selected.
If you don't have that there, just type in p.
And you'll see polygon collider 2D pop up.
Click on that.
You should get polygons popping up around there.
You can kind of see them.
If I turn off the sprite renderer, you can see them very well.
I'll turn the sprite renderer back on.
And now I'm going to hit the back arrow.
As soon as I do that, it's going to pop up and say, "Hey, do you want to save the changes that you made to this prefab?" If I messed up, then I would hit discard changes.
But since I didn't mess up and it looks right, I'm going to hit save.
And then let's go look at our platforms that are out here in the world.
So now our platform, look at the child object here, the left and right, they all have polygon colliders.
If I go select another one, they have polygon colliders as well.
Let's press play and try this out.
Make sure that it's rounded off.
and our character can jump on these awesome new platforms.
There we go.
Look at that.
It works.
We've got a working pretty cool prefab.
So, let's stop playing and go commit our prefab into plastic.
Say we've added a grass platform prefab to level one.
And we'll check it in.
Now, we're going to look into making more prefabs, some different versions or different sizes of our existing prefabs.
and then eventually some totally different looking versions of our prefabs.
So, let's start by making a larger version of our platform.
Right now, we've got one that's four wide.
And let's say that I want to have a platform that's also five wide.
I don't just want to have them all four wide.
Maybe I want them two, four, six, whatever.
Let's say I want one that's slightly bigger.
Let's make a change to grass platform 4 here.
This second one.
And let's just modify it.
First thing I want to do is just rename it to grass platform five.
So I know that's the one that I'm changing to be five wide.
Then we'll adjust our tile size to be three instead of two.
And notice that it's kind of there, but it's just kind of back behind the ground.
You can't really see our new tiling.
If I go over to the view wall, you can kind of see it breaks the tiling.
Looks weird, but it doesn't look right.
So we need to go back to grass platform 5.
And I'm sure you've probably guessed we need to move these two children, the grass right and left over about another half meter.
So if I grab and control drag, I can snap it over or I can go select it and then choose a value of -2.
So now I've got one that is five units wide.
1 2 3 4 5 units.
So I want to make this into a prefab as well.
I've got a couple of different options here.
First thing I could do is I could hit overrides and hit apply all.
But if I do that, what's going to happen is all of my platforms are going to change to be five wide.
That's not what I want to do.
So I'm going to hit control Z or command Z, whatever your hotkey is, and we're going to instead create a new prefab.
We'll take our grass platform and drag it down here.
And we get a couple options.
We can either do an original prefab or a prefab variant, which might sound kind of tempting, but I'm going to tell you to just avoid that temptation for now.
We're going to look at prefab variants later, but we're going to use them slightly different.
We don't want to use them for the sizes.
We'll use them for our visuals instead.
So, we're going to choose an original prefab.
And now we've got a grass platform 5 and a grass platform 4.
Okay.
Let's say we want one that's six wide.
Here's a quick challenge.
Go ahead and try to make one that's six wide.
I'll let you pause, make that platform, and then resume and I'll show you.
We'll make one that's six and then another one that's two.
In fact, if you want to make the one that's too wide, go ahead and try that as well.
All right, I'll assume that you've already done them.
Let's go through the process.
So, I've got my grass platform 4 here.
I'm going to just rename this and hit F2.
We'll name this grass platform 6.
I'm going to hit F over the scene view to go focus that object and zoom out.
We'll adjust the tile size to be four because I want this to be six wide, which is four plus the two on the edges.
So, I'll adjust that to be a four.
Expand out the children.
Change this child value to be at 2.5 on the right.
And on the left, we'll make it be um negative - 2.5.
Now, I'll go to my grass platform, drag it down, and make this again an original prefab.
Now, for the second platform or the two wide platform, I'm going to do it totally differently.
Instead, I'm going to double click on my or I'm going to single click on my grass platform.
I'm going to duplicate it with control or command D.
This is down here in the project view.
Now, I have a grass platform 7.
I'm going to rename this though to grass platform 2.
We're going to double click on it to open it and view it in prefabedit mode.
This time I want to modify it slightly differently.
We'll do it in prefabedit mode.
Now, to have one that's too wide, I actually don't need anything in the center.
I just need the these two edge pieces.
So, I'm going to disable the sprite renderer and disable the box collider.
I'm going to take the grass right and I'm going to change the value to be 0.5.
And I'll change the grass left to be a value of negative.5.
Now, we've got two little boxes right next to each other.
We have these other components here.
I've left them on just in case we decide we need them later.
But as it is right now, we don't need them.
So, they're kind of extra just sitting there just in case we decide, hey, we're going to go do something with them.
Probably though, what we'll really do is just remove them later.
But for now, we'll just leave them disabled because I want you to see that it's going to work exactly the same.
Now, we're going to go back out of prefab edit mode by hitting the back arrow here and hit save.
And now, we don't have any of those two wide grass platforms in our scene yet.
So, let's go add one.
In fact, let's go select this one.
I'll take this grass platform 4 and let's go replace it.
We'll right click on it, choose prefab, and choose select or no, replace, not select asset, and we'll choose the platform 2 right here.
We can also go to list view if you want to see them by name, but I can tell that this is the two wide one because it it's quite a bit narrower or less wide.
And I can see the name down below.
So, I'll just double click on it.
And now I've got my two wide platform there.
I'm going to save my scene, press play, and run around on these platforms just to make sure that everything is still working kind of as I expect.
So, here we go.
go.
go.
Oops.
Jump and run and jump.
Jump.
This is that two- wide platform.
Yep, seems good.
And so far, I mean, it seems like everything is working pretty good.
Let's go check out our water one more time.
All right.
So, we'll stop playing and we're going to go into plastic SEM and say that we've well make sure we've saved our scene.
We've added three more grass platforms.
Added three new grass platforms.
Or is it three or four? Yeah, three.
And then we'll check in our changes.
Now that we've gone through the process of making prefabs a little, let's do it again.
Let's make a couple more prefabs out of some of our existing objects.
For example, let's take our spring and make that into a prefab so that we can place multiple springs and have them work the same way.
And then if we want to make any changes to them later, we can.
Or if we want to use them across different scenes or levels like we will do, we'll be able to do that as well.
So, first thing we're going to do is rename our spring.
I'm going to go select it, rename it with F2.
Go up here and type S with a capital or capital S.
Just replacing that lowercase S with a capital one.
Then I'll take the spring and drag it down into my prefabs folder.
Now I've got my spring here as a prefab and I've got it down here in the prefabs folder available to drag out here.
So I'm going to drag a spring oh let's say right up here.
Maybe drop it right on top of this platform here.
I'm going to even out or level out my position to a three.
I just like to go in and type out the exact position.
And then here, I think I'm going to go to like a 7.5 and go a little bit to the left there so that it's perfectly lined up with the edge.
And I've got a spring there on the edge.
I'm going to move some of these platforms around so I've got a little bit more space.
I'll hold control and just drag that guy over here.
And I think I'm going to drag this one maybe way over to the right.
I'm going to also increase the size of my background.
I mentioned that we could just adjust this tiling size.
So, let's double it.
And then instead of figuring out the number that's double, which is 160, I'm going to type in the formula for it.
In fact, let's triple the size instead just to make it a little bit harder.
To do that, we'll go to the end of the width here, which is 80.
I'm going to put a star, which is the key for multiplication or the character for multiplication, and then a three.
And then look at that.
It already got wider.
If I hit enter, it'll calculate it out and give me a 240.
Just a cool little thing that you can do in any of the calculated fields.
For small numbers like that, it maybe isn't as useful to you, but for bigger stuff, I found that it can be pretty handy if I need to especially divide things by pi or whatever, you know, some other weird stuff like that.
So, here we go.
I've got my nice wide background.
And now I want to add a little bit more water and maybe some more obstacles.
But I don't want to just duplicate this water.
Again, I kind of want to have um a prefab for this.
And here I've got some options.
I've got to decide, do I make the water on the bottom be part of the prefab or do I just have the top part be the prefab? And in this situation, my general thought is that I want to take my water that's the bottom of this object and make it kind of all be one thing.
I don't like having multiple objects that I have to place.
If I need to do them differently and modify them, I can modify this prefab once it's placed or hide this part or something.
But generally, I'm going to have visible water below my top water.
So, I'm going to make this be a child of the top water.
So, that might sound a little bit confusing, but all you really need to do is click on this water.
Let's rename this to water bottom with a capital W and a capital B because we want to have nice clean names.
And let's go to the top part and name this water.
This is the water.
That's the top.
It's the top part is now just named water.
We're going to take water bottom, make it a child of water.
In fact, let's rename water to be uh no, let's not rename it to be water top.
We'll just name it, we'll leave it as water.
So, now we've got water with water bottom and we're going to turn this water object with its child into a prefab.
To do that, we'll take the water, drag it into our prefabs folder again into the empty space, and tada, we've got another water prefab or another prefab.
Now, we're going to duplicate this water.
And we're going to see something really cool that prefabs allow us to do.
We're going to take this water, gonna duplicate it.
Control D.
So, I selected it.
Control or command D.
I have two water objects.
If I hold control and drag with the red arrow, I can see my second water was just stacked right on top of the other one.
I'm going to drag it right over here so that it snaps right in line with my ground.
Now, if your ground isn't snapping in line, then make sure that this is at a like snapped position, you know, not a decimal point there or at a 0.5 maybe.
And then you have your values, right? Like this.
You've got a solid number here or whole number there.
All right.
So, let's go take a look at it.
If I unselect, you see that I've got my water here, but I still have this ugly line here where I'm not seeing any grass.
Like, I don't see that background view at all.
And I think it looks pretty terrible.
Let's hit play and see what it looks like in game, though.
So, I'm going to make sure that I'm not crazy and it actually looks terrible.
But, we should be getting kind of that uh Yeah, we get the sky blue there.
That doesn't make any sense.
Kind of ruins the water effect.
Makes it look messed up.
So, I want to fix that.
Let's stop playing again and go select our original water, the one that we had here, and let's fix the problem.
To fix it, I want to add something in the background that kind of matches our background of our level.
And we've got really a couple of ways that we could do this.
I could add a sprite onto here.
In fact, this is what we will do.
We'll go to 2D object, go to sprites, and go to square.
And now I've got a background square object.
Look at this a little bit better.
You can see that I've got this square kind of sitting back there behind the water.
Now, if I change the color of this with the eyropper and go pick the same color as my background, now it just kind of blends in.
And I could, of course, just adjust the size of this by hitting tiled mode and then changing the tiling out to be the same size as my water.
Now I've got a background that shows up and kind of looks a little bit better, but there are a couple of issues.
First, let's rename the square to grass.
Background.
I'll call this grass background.
And let's um change this.
Oh, actually, we don't want to do anything with the full rect mode.
We just want to save.
So, now let's go look at our other water.
Ah, look at that.
Our other water does not have this grass background.
We don't see that.
And it's, you know, we've got it here.
It looks like it's probably going to be okay.
But on the other one, it looks like it's going to be messed up.
In fact, let's go play.
Make sure that it looks right before we try to get this to apply to all of our ground or all of our waters.
So, we come over here and it looks okay.
Look at that.
I can kind of bounce in front of it.
Looking good.
And I can jump over here.
And you can see this one's still messed up.
So, let's stop playing and see how we can fix this.
So, since I've made changes to this water prefab, you notice that there's a little green plus here.
This green plus means I've added something to the prefab on this version of it or this object that's placed.
This water down here, the one that doesn't have that, notice it doesn't have the green plus.
Doesn't have this other gray part either, the grass background.
And also notice that this part is gray.
That's because it's not part of the prefab, this grass background here.
So what we need to do is go to the override section of our water.
So I select the water here, the one that we've added the new background to.
Let's just go double click it again.
Go to overrides.
And here you can see we've got the same little highlight, the plus saying that we've added a grass background.
That's what the plus means.
And then we just hit the apply all.
And this is going to apply the changes to our water prefab.
Watch what happens.
I hit apply all and look at the other water here.
It now has a grass background.
And if I zoom out, you'll see that it's got this background showing up.
Now, I'm gonna save my scene and press play again.
I want to run around and just make sure that everything looks okay.
And then I want to show you one more minor thing that I'd like to change before we commit.
So, run over here and look at that.
We can kind of bounce around.
Everything looks okay.
Let's go to the next one.
It looks good.
Okay, cool.
But now there's one issue that you might have run into and I want to show it to you because if you have, it could be a little bit confusing.
If you're looking at your grass background, your sorting layer could be set to water right now.
And if it is set to water, look what happens to your player.
Your character shows up behind the grass and it looks very, very strange.
We don't really want it set to water.
If it's set to default, it'll show up okay because that's behind the player.
But really, we want this grass to be in the background.
We want to set that to the background layer.
So, I'm going to stop playing and we're going to make this change to our object again.
This time, we'll do it on the second water object.
Instead of the first water, let's go to the grass background of the second object.
We'll change the sorting layer to be background.
And then, we'll go to the root object of it, this water, the parent, and go to overrides.
Here you'll see that it now says we have a change.
It doesn't say we have a plus, just a change.
And it's saying that something is modified in our sprite renderer.
If I click the little I there, I'll get a popup that shows me exactly what.
Let's see if I can drag this over and give you a nice preview of that.
So, click the I and we can get a preview showing what has changed.
And it's still a little bit off screen.
So, we're gonna drag this way over.
We'll hit overrides and hit this.
So, what we're seeing here is the original version of the prefab and then what we've done to change it.
And you can see what's changed.
And it doesn't do a great job of calling out everything that's changed, but you can tell right here with the bold text.
It's just the bold text isn't very bold.
So, it's not the most obvious thing.
But, we changed the sorting layer.
That's why this is bolded.
And everything else is that default.
Now I just need to hit the apply button and hit apply to prefab water.
Drag my window back out so you can see it again.
And then let's go check out our other water.
Our other grass background is also set to background layer.
Now I'm going to go to plastic SCM.
And now I'm going to say that we've added a spring and water prefabs.
And we'll check in our changes.
Oh, we got to make sure we Let's hit cancel.
Save the scene.
And now check in our changes.
So far, our prefabs have been somewhat complex, but I've been guiding you through them.
Now, I want to give you a little challenge to build a prefab on your own.
But first, I'm going to give you some functionality for that prefab.
We're going to create a spike that kills the player whenever they touch it.
And your job will be to turn that into a prefab that we can use to reuse throughout our game.
So, to find our spike, we're going to go to the art and tiles folder.
Then down somewhere near the bottom, let's see if we can find them.
We've got a spikes object.
I'm going to zoom in on the scene view a bit.
Let's go over here to the big part between my two waters.
And I'm going to drag a spikes over to our scene.
Now, if it's not set to the right scale, make sure I've selected it and the pixels per unit is 128 and matching the scale here.
I'm gonna go select my spikes and then I'm going to reset the position to let's about a 26 and a negative 3.5 to be just on the ground.
We'll add a polygon collider 2D.
So I'll search for poly 2D and then we'll um I'll set it to tileable mode.
Now that it's in tileable mode, I'll set it to be too wide and then make sure that the autotiling checkbox is on.
The final thing I need to do is make it kill my player when they touch it.
So, I'm going to create a new script that kills the player when you touch something.
I'm going to go into my scripts folder and I'm going to rightclick, create a new car script, and I'm going to call this spikes cuz that's what it is.
It's a set of spikes.
So, we'll create our spikes script.
We'll go to the spikes object and drag the spike script onto it as soon as it finishes recompiling.
Got to give it a second.
that happens when we create a new script.
So, I've got my spikes script there attached to my spikes object.
I'm going to capitalize the S here because I want my naming to be nice and clean.
And then we'll go open up the spikes script.
Inside the spike script, we're going to do the same thing that we did with the other script that we created.
We're going to delete our start and update method.
So, I'll select at the beginning of line seven all the way to 17 at the end of 17 and then press delete or backspace on the keyboard.
Now, we're going to check for a collision enter.
Remember in our water, we checked for a trigger enter to see if we went into the water.
Spikes aren't going to be triggers.
They're going to be actual colliders that things could land on.
And if a player lands on it, well, it'll kill the player.
So, let's go back to our spikes and instead of adding an on trigger enter, let's add an on collision enter.
So, I'll type O N C L and find that on collision enter 2D.
We got to make sure it's the 2D version.
I'm going to delete my private keyword because I just don't need it.
It's private by default.
And then we're going to check if our collision 2D was a player.
So we'll say if collision dot and here we need to get the collider.
We don't we're not able to do a compare tag because collision 2D isn't the same as a collider 2D.
A 2D collider is the object that you're colliding with.
A collision 2D is like this data object that has that collider, but it also has some extra info like how you how the object collided, where they collided, like what the specific points were.
In a trigger, we don't get that info.
So, you get back the simpler object of just the collider 2D.
In fact, if I go look at the water, you see that we get this collider 2D.
But in the spikes, that's not what we're getting.
We're getting the collision 2D that has a collider on it.
again because we've got more information on a collision than we have with a trigger.
So if the collision collider compare tag because we can get the tag from the collider here and we pass in player.
So this is going to tell us if the collider has the player tag on them.
Then what we want to do is kill the player.
And to kill the player, the easiest thing we can do, the the kind of default starting thing we can do is just reload our current level.
So to do that, we'll say scene manager.load load scene and then we just pass in a zero.
It's going to reload the first scene in our scene index.
And we'll talk about our scene index and our build indexes and all that stuff in just a moment.
First though, let's save.
Make sure that everything looks good.
We'll go back over to Unity and then we're going to run over and touch those spikes and see what happens.
So, we'll save our level here.
We need to make sure that we've saved our scene.
Press play.
We run over to our spikes and go touch them and we reload into our level.
Now, if you're not reloading into the level, what you're going to need to do is go to file and build settings.
And you may have something else in your scenes and build.
If you're loading into some other scene, you're seeing, you know, something weird, some demo scene or something else, it's because you have something else in your scenes to build.
Perhaps you have the old sample scene.
So, what you need to do now is while you have this window open, and even if you haven't had no problem and yours looks just like this, hit the add open scenes button.
And then let's make sure that this first entry here is deleted.
So, I'm going to go select it and hit delete.
We want our scenes and build to just contain scenes level one.
And that's it.
Then we'll close it.
We don't need to do a build or anything else.
We're going to go to file and save project.
That should in plastic SEM update our editor build settings.
We should have our level one saved or our level one showing up there and our spikes.
Let's do a commit.
Say we added spikes and level one to build settings.
And we'll check in our changes.
And now your job is to turn your spikes into a prefab that you can reuse so that you can have it scale all the way across here or be a tiny little spike up here that you place however you want.
So go ahead and give that a try.
I'll let you pause right now and then continue on and I'll show you how to do that.
All right, I'll assume that you're done.
Let's go through the process.
So, let's go back to our project view.
Let's go to the assets folder and go to our prefabs folder.
I'm going to go select my spikes.
And the first thing I'm actually going to do here is adjust the tiling.
I'm going to set the tiling down to one because I don't want the default to be two tiled wide.
I want to start with a very small one on my prefab and then just allow my user or my designer or myself to scale it up to whatever I want.
So, I'm going to take my spikes now.
I'm going to drag this into the prefabs folder.
And tada, I'm pretty much done.
Now, I can take this spike object.
I can drag it up here on top of this platform if I want.
Then fix up the position.
So, we're looking at like a 24.5 and a three.
And then just adjust this scaling here by modifying the the tile size.
So maybe I want to set this to a four like that.
Now I've got one that fits all the way across a 4x4 platform.
I don't need to make another prefab for it because it just fits.
This is kind of the benefit of a prefab.
I don't have to make an object for every size.
I can override and modify the specific parts that I want.
Now when it came to our platforms, this not such that not so much the case because we had those two edge pieces.
But with the spikes, we don't have that problem.
We can just make it whatever size we want and place it wherever we want and then scale it up without having to create multiple different prefabs.
I like this.
So, I'm going to save my scene, go into plastic SCM, say that we've created our spike prefab, and check it in.
In this section, we're going to learn how to use source control to see what we've done, review what we've learned, and kind of get a good overview of what our project looks like.
The first thing I want to do is go to our plastic SCM window.
And right now, we've got pending changes open.
I want to go to the change sets tab.
It's kind of hard to tell that these are tabs, but that's what they are.
And if you look in here, you'll see that you've got quite a few change sets.
Your count might be slightly different from mine.
I've got 40.
I've probably added a couple extra that you haven't seen.
I'll show you what those look like in a moment.
But overall, you should have just about the same number with probably very similar commit messages.
You can scroll all the way through all the way down to the bottom and see even the first commit message which was at zero which kind of happened automatically.
And number one, added packages and project settings.
This happened automatically too.
So the first commit that we did was our art imported and level one.
And if I click on that commit here, you'll see that it shows that we added 457 files.
This was our biggest commit when we pulled in the entire art package from Open Game Art.
Remember, you can also go to Kenny Enl's page.
She's got a whole bunch of great art available there.
You can download lots of cool stuff and pull it in later, but for now, this is the one that you need.
So you've got this one in and we pulled this in in pack number or in in commit number two.
We also went on to add in a player script.
And here you can see this is where I actually have more commits than you do because I added my player script and then I moved it to the correct folder.
So I had to delete it and then read it and I had some extra commits that I didn't put on camera and I forgot to delete beforehand.
So let's take a look at our first commit where we've added a player.
So, you've got the one where you say added player script and attached it in level one or something similar.
You should see over here to the right you've got added and you've got a scripts and a plus meta and then you've got player.cs plus meta.
So, when you find this part and it's probably a commit message looking something like this.
It's one of our first ones.
Right click on it and hit the diff button.
Not diff meta but just diff.
This is going to pop up a source control diff tool that'll show us the difference between our previous version which didn't exist and our first version or the version that we've clicked on which was version right here.
Mine was at number five.
And here you can see that we added the line that logs updated at the current time which remember time is the current time the game has been running in seconds.
So at 0 seconds in, it's zero.
At 1 second in, it's one.
At 10 seconds in, it's 10.
And so on.
But there's usually some long decimal there.
So this was our first version.
There was nothing to compare.
Let's close this.
Let's go up a little bit further.
Let's go find the part where we added jump velocity and duration variables to our player.
And then let's right click on the player and hit diff.
This will show us the difference between the part where we added these variables and the part the version of it that we had before we added the variables.
So this is when we added our two serialized fields for jump velocity and jump duration.
This allowed our player to jump up higher or further.
Well, really it allowed us to do that to control that through the inspector.
So we could control how high they jump without having to hardcode it.
Come back in here and change the values.
Let's go take a look at what that commit was like.
Let's say we want to go vi revisit that commit.
I'm going to go right click on commit number nine and I'm going to hit switch workspace to this change set.
I hit switch and that's going to change my local version of the game.
I'll hit reload over to exactly what we had on commit number nine.
Don't worry though, everything's still available.
I can get back to my previous one.
I'll show you how to do that in just a moment.
Let me hit play though and go check it out.
Make sure that we've got those jump variables working.
That's what we added in this version, right? So, I could jump and I could go left and right.
But remember, there's unlimited jumps when we started out.
So, those are available.
And if I go over here and select my alien, I can see, let's see, where are my fields? Right here.
Jump duration and jump velocity.
Yep.
So, that that seems about right.
I could change this to like a 15.
And oh, yeah, he goes flying.
So, that's cool.
Now I remember that's what those fields were.
And I if I want I can even double click on the player script, allow my code editor to reload it and go see that version of the code right here, go modify it or maybe share it with somebody or whatever it is I need to do with it.
I now need to just go back to Unity though and see something slightly newer.
Let's go back to my change sets.
Any second now, we should be able to click on change sets.
There we go.
And let's scroll through and find another commit.
So there was the part where we added our walk animation to the player.
In this commit, we can see that we added our animation folder.
We added that controller and we added the walk animation that we recorded it.
Let's go take a look at it.
Let's switch our workspace to that.
Or at least I'll switch mine.
We'll reload and we'll go take a look at that player and the animator controller that we added to the player.
So, we've got the player here.
The player has underneath it the animator and it has the controller on it.
The player's animator controller has this player walk animation.
And at first, remember, it just looped.
It just played over and over.
If I press play, remember it just continued to go and go and go.
Let's see what that looked like.
Oh, remember no matter what I did, it just constantly walked.
Do you remember how we fixed that or how we changed it? Let's go back into plastic and take a look.
We'll go back to our change sets.
Let's go find one slightly newer.
We can find the one that we're on.
It's bolded here, line 16.
Let's say that we want to go to the next one where we've added animator controls to jump for jump and idle.
So here we'll switch the workspace to that change set.
And let's also do a diff on the player.cs file and see how we modified the way that we interacted with the controller.
So I've got to go back to change sets.
It is kind of annoying how it bounces over like that.
But I go back to change sets, reselect my change set here where we added animator controls.
And I'll hit diff again.
We'll pull up the script and then we'll go look at it.
So here remember in our update sprite method we actually just called into our animator and we told it to set a boolean of whether we are grounded or not.
So we set is grounded to true or false and then we set the float for our horizontal speed to the absolute value of our horizontal speed which as you remember just removes the negative sign if there is one.
Let's go take a look at what that was like in game or in our editor I guess really cuz what we care about is the animator.
Remember the animator has our grounded check and our horizontal speed parameter.
We added those by hitting the plus button and choosing the parameter type and then naming them.
And then we've got transitions.
We start by going into player walk.
If we're not walking, so if our horizontal speed is less than 0.1, we go into idle without has exit time on so that we can skip past and go instantly.
We don't want to blend.
If we start walking, our horizontal speed gets greater than zero.
We go back into walk.
And then for our walk to jump, we just check to see if we're not grounded.
And if we are grounded, we go back into walk.
And then from idle to uh to jump, it's the same except when we leave jump, if our speed is less than 0.1, we go into idle instead of to walk.
And we've got, of course, the has exit time.
Oh, has exit time is actually checked on these.
Probably shouldn't be.
And if it is in our latest version, we should uncheck that.
So let's see how we get back to our latest version of the code.
or the our project.
We go up to our top commit here, rightclick, and hit switch workspace to this change set.
And of course, tada, we're going to be at the latest version.
So, oh, we've got to let it reload.
Let it reload here.
Our level one will reappear.
Our scene view should show us everything.
It might It's reinstalling the Cinem Machine package.
So, it takes a second to do that.
Bounce between.
And remember, we added our Cinem Machine package, too, to control our camera and have it follow our player around.
Now, I want you to just go ahead and take a look at a couple of your other commits.
Maybe go check them out.
Go switch your workspace to them and take a a quick peek at them.
Whatever you do, don't go delete them.
You can't do that from in here.
You have to do it from the plastic SEM tools, the external one.
Don't go modifying and deleting them.
But inside of Unity right here, just go switch to them.
See what you want.
Don't hit the revert button.
Just hit switch or hit diff and see what you can kind of glean from it.
Even if you don't completely understand what it's showing you or what you're seeing at at all, just play with it a little bit and see kind of what comes from it.
I think that you'll start to understand it more and it's going to become a very important skill long term for you.
And then in the next section, we're going to dive into a lot more of the code and talk through some of that some more.
I'm back on the latest version of our project and now I want to talk through the code a bit.
I want to make sure that everything kind of makes sense or maybe totally makes sense and hopefully answer some questions that might have been bouncing around in your head.
So, we're going to take a look at our four scripts that we have and see what we can learn that maybe we haven't learned already or what we can kind of figure out from these just reviewing them.
We're going to start with the water script.
We'll start right at the bottom and work our way up to the top.
So, our water script was very basic.
It doesn't have a lot to it.
It's got a couple lines up at the top that we haven't really talked about at all.
It's got the definition of the class, the public class water, and that colon and the mono behavior, which if you remember before I told you is the thing that we need to make it be possible to have it as a component.
If I don't have the word mono behavior in there, this water just won't work as a component.
I won't be able to put it onto my objects.
In fact, let's see what that looks like.
Let's delete out the colon and mono behavior.
I'm going to save.
And look at this.
I've already got an error.
It says get component doesn't exist in the current context.
And that's because git component is part of the mono behavior.
So, let's let's just comment this out, too.
I'll just put two forward slashes.
And I'll save again to make it so that I can compile.
We don't have an error at least.
And go back over to Unity.
If I go into here now and I select my water, I'm going to see that my water component has disappeared.
Oh, it says, yep, there's now a no missing or a missing script.
I guess it didn't completely disappear.
It says the associated script could not be loaded.
Please fix any compile errors.
If I remove this component because it's no longer working and I try to read add the water by dragging it over, it's going to tell me that I can't add the script water.
The script needs to derive from MonoBehavior, which means that it needs that colon MonoBehavior.
So, I'm going to reopen it.
Actually, let's go into source control and I'm going to undo my change in plastic SCM.
So, I'm going to go to plastic SCM, find my pending change, rightclick on the water, and hit undo changes.
That's going to revert or undo my water deletion or my my water line model behavior part deletion.
If I go back to the water script, let's go find that water script.
Here you can see it's reattached and the code is back.
So, we've got the colon mono behavior which again tells it that it's a component that can be added to a game object.
And then inside of here inside of the braces, which is inside of our class, this brace is the start of our class.
This braces the end of our class.
We have one method, the on trigger enter 2D method.
Again, if we build a 3D game, we'll use 3D components.
So, we'll use a rigid body and on trigger enter and a collider.
In 2D, we always have to use the 2D ones.
We have the ontrigger enter 2D that passes in a collision or an object named collision.
That's actually a collider 2D.
And a collider 2D is any of these colliders, a polygon collider 2D or if you look at our player, a capsule collider 2D, anything that's a collider 2D like that will could be an object that's passed in.
And that's because all of these classes, these capsule collider, polygon collider, etc., they all also inherit or derive from a collider 2D class.
Now, you can't see that.
Well, you can if you try to dig into it, but you don't need to see that.
It's not something that's visible.
But they essentially look like something collider 2D colon collider 2D in their code.
So, it's going to pass that collider in and then we just play the audio because we don't care what hits the water.
So, we get the audio source component and then we tell that audio source component to play.
Now, what happens if we don't have an audio source component here? Think about this for a moment.
If we don't have an audio source component attached to our water, what's going to happen on line 9? Well, if you think about it for a moment, what's actually going to happen is get component for audio source is going to return back nothing.
It's going to return back null or no object or nothing at all.
And then it's going to try to play on nothing and that's just not going to work.
You're going to get an error saying there's a null reference exception.
It's the most common error that you're ever going to see.
So, it's something that you're going to want to address.
So, why don't we just make a quick change here and make sure that we have an audio source.
And to do that, we can add a question mark and save.
What that will do, and this is a cool little trick, is check to make sure that the thing to the left of the question mark is not null or does exist so that we actually get one back.
and it will only run this play method if we have an object here.
So, if we got something back.
So, I guess cool little review and a little tip or trick.
Something that you should probably understand and we're going to be using quite a bit throughout our game development.
And if you've never seen that question mark there and you've only seen the dot, hopefully this clarifies it quite a bit.
It just checks to make sure that the component or the thing doesn't necessarily have to be a Unity component exists before calling the method on it.
Let's save that off and then go commit our change to plastic.
So, we've added a null check to our water script.
That's what we're going to say.
Go to plastic SCM.
Say added a null check to the water script when playing audio on trigger.
Enter.
And check that in.
So, let's go on to our next script.
We'll go back to the project view and take a look at our spring.
Our spring was a little bit different.
Our spring doesn't get the audio source every time we touch it.
In fact, we cache our audio source, which is something we might want to consider doing for our water.
It also caches our sprite renderer and our default sprite right here in this awake method.
So right at the beginning of our execution or our life cycle of our spring object, we save off all of these different components.
And we do that well for ease of coding in case we want to use it multiple times, but primarily for performance.
Calling this get component every single time will eventually cause performance issues.
It's not going to cause performance issues for our game even if we did it every single time.
But it's a very important habit to get into just caching this because if we build anything bigger, we start to scale up or we want to start to target smaller devices, lighter platforms, and we really need to get into the per the habit of optimizing this performance.
And it's very easy to do.
We're going to talk a lot more about performance later on.
So we cache all three of these things in awake.
And one of those things is not a component.
It's actually the current value of our sprite renderers sprite.
So our sprite renders the component and we get the current sprite and use that as the default.
Remember that's the unsprung version of our sprite.
And then we use the on collision enter 2D methods instead of on trigger enter because we have these set up as actual colliders and they're colliders that are set up to be bouncy.
So when we land on it, it bounces our player.
And remember how we do that in just a moment.
We'll go take a look at it.
But when we hit the object, we actually check to see if the thing that hit was the player by using the compare tag method.
And if so, we swap the sprite and then ch play play an audio boing sound.
And then when we leave the collision, so when our player bounces off away from the spring, we set the sprite back to its default value.
So that's why we cached the default sprite.
Let's go take a look at that spring again.
We go look at our spring.
We've got our box collider and its material.
Remember we created a physics 2D material is set to spring and that value has a bounciness of one and a friction of zero.
Let's go look at that spring one more time.
See what other components we've got.
So we've got our box collider.
We've got our spring with that sprung sprite on it.
And then we've got the audio source.
That's pretty much all we needed for the spring.
It's nice.
It's pretty tight.
It's a simple little script.
So, let's jump over to one more script.
We'll take a look at our spikes.
Our spikes are very simple.
They also use the on collision enter 2D.
And here we check to see if a player hit again using that compare tag.
And if so, we load scene zero, which is again just loading the first scene in our build index.
Let's go take a look at both of those things.
First, let's see our player.
And remember that we've got this player tag in the tag section.
Remember that's different from layers.
Layers are used for collisions and physics.
And tags are used for game logic.
We can also access layers for game logic if we want, but usually tags are kind of the default for that.
At least the player tag.
That's very common tag to have.
So we've got our player tag here.
And then we've got our file file file build settings and our scenes to build.
This is where we got that load scene zero.
Notice the zero right here.
That's the build index.
So level zero was this one.
We could also load it by calling the name saying load scene and then passing in quotes level one.
But we're going to do more level loading in our next setup set of sections.
So, for now, we're just going to close that out.
And I think we'll wrap it here and then continue on to the player script in the next section.
All right, it's time for the big script, the player, the one that's doing most of the work in our game.
Let's open up the player script and start at the top.
So, up at the top, we've got these using statements.
And I've mentioned them a couple times.
We've kind of ignored them, but I want to briefly talk about what they are.
These statements allow your code, all of the code below them, to use specific libraries or systems.
They allow your code to use things that it might need to use that you wouldn't want to have to write yourself.
Things like lists of objects or random number generators or Unity components, which is why we have the Unity engine one here.
If we didn't have this using Unity engine statement here, if I just deleted it, the MonoBehavior reference is going to disappear.
Serialized field, sprite, layer mask, all of these things, the game is no longer going to know about them because they're all in that library.
They're all in the Unity engine library.
So, I'm going to undo that, bring that using statement back in, and make sure that my code knows about all of these things.
And you might see these two gray ones here and wonder, why are they light gray? That's because these ones just aren't being used right now.
So, I can actually delete them just by holding shift and hitting delete and shift delete and removing them.
The reason that they were there though is that those are very common ones that are often used in game development and writing code.
So, it just puts them there kind of by default.
We can remove them though because we're not using them right now.
So, let's get rid of them.
Let's take a look at the next line.
We've got line four, our public class player inherits from MonoBehavior.
I think we've talked a little bit about that.
Probably don't need to talk more about it.
And then we've got a private float jump end time.
Now, one thing I'm noticing is that this float is surrounded or kind of like followed by some serialized fields.
And then there's more floats and other private variables down here.
So, I'm inclined right now to just move this line down here to line 21.
So, I'm going to hit shift delete and move it down to line 21 so that it kind of lines up and is in in line with my other jump private fields.
Then I'll delete line six here.
I like to keep my code nice and clean and organized so that it's easier for me to find things.
So now on line six, I have a starting block of serialized fields.
And remember this attribute here with the square braces makes it so that our variable will show up in the inspector.
If I save, go over to the inspector, I should see horizontal velocity, jump velocity, jump duration, jump sprite, layer mask, and foot offset all in that order on my player.
Let's go double check.
make sure that I'm not crazy and we're seeing the same things.
So, we go look at our player.
We expand out the player script and there we go.
We've got all of those fields in the same order and we have is grounded.
So, let's go back to our code down here.
We've got that is grounded right afterwards.
And remember that this is public which also shows up as or in the inspector just like the serialized field.
Now, the reason that this is public, well, we haven't talked about that yet.
We're not going to talk about it right now.
We we'll talk about public and private stuff a little bit later, but for now, we're going to continue on.
And just know that when we have something that's public, it can be accessed by other code outside of the player.
And when we have something that's private, it cannot be accessed by other code outside of the class.
And that matters, well, it matters for this because some things are going to want to know if the player is grounded.
But nothing else shouldn't need to know about our foot offset or our jump duration or jump sprite or anything else.
Some objects might need to know if we're on the ground though, so we make that publicly available.
All right, next up we have our private field.
Starting on line 15, we've got a sprite renderer that we're caching in our awake.
We've got an audio source that we're caching in our awake.
And we've got an animator that we're caching in our awake.
I'd like to keep all three of these components in the same kind of order or next to each other.
So, I'm going to move this animator right up here and then delete out line 19 just to keep them kind of in order.
And in fact, since they're components, I'm even going to add a space to separate them.
This is something I highly recommend you do with your code.
Keep it clean, keep it organized, and just go through and when you just need a break from thinking too much, just start cleaning up your code.
Just reorganize things.
Just make sure that it works and that you've got source control so if you accidentally delete the wrong thing, you can go back and undo it and fix your problem.
All right.
So, we've got our three components that we cache in our awake.
And then we've got our horizontal value for where we're p pushing left and right, our jumps remaining, and our jump end time.
So, this is when our jump is going to end and how many jumps we have left.
We've already talked about awake enough that I don't think we need to explain what caching looks like or what we're doing there.
So, we're going to minimize that and look at the gizmos.
Remember, gizmos only show up if you have that little world popped on, and they don't interact with the world at all.
They're just for the scene view.
And in our onraw gizmos, we do a couple of things.
First, we get the sprite renderer.
And I guess it's kind of important to note that we can't just use the sprite renderer from awake because awake isn't necessarily called every time when on draw gizmos is.
If we are not running, we're just in the editor, awake's not going to be called.
So, we need to actually get the sprite renderer.
Then we set the color of our gizmos to whatever color we want to draw in.
Whatever color is set is the color that the next gizmos draw line will be in or gizmos draw anything.
Then we've got our origin right below that on line 35.
We declare an origin and we use our current position minus our bottom or our extents of our our bottom there.
So we get the position right at the bottom in the center and we draw a little line from our origin downwards 0.1 m.
We do the same for the left and the right foot just by subtracting and adding the foot offset.
Then we've got our update method.
Remember this is where all of the magic kind of happens.
This is the core of our game logic right now.
We've got an update grounding method that updates whether or not we're on the ground.
If we look at it, it has the is grounded value getting set to false.
And then we do a raycast downward just like we did with the gizmos, but we're doing a raycast instead where we get back a raycast hit.
If we hit something, anything at all right now, then we set is grounded to true.
Otherwise, we just leave is grounded to false.
So, first we check in the center, then we check in the left by com just doing that same ray cast, and then we check on the right.
Now, theoretically, if we've hit once, we probably don't need to check all the other ones.
If we hit in the center, we don't need to check the left and the right.
It's somewhat inefficient, but for now, we're not worrying about speeding that up and optimizing it.
It is something that we'll be addressing soon, though.
And then on line 97, we just check to see if we are grounded and we're not um we're not flying upwards, then then then yes, if our or so if our velocity is less than or equal to zero.
So, we're either at zero or falling downwards.
So, not flying upwards.
Then we set our jumps remaining to two so that we can jump again.
Now, let's go back up to our update.
And the next thing that we do is read our horizontal input.
And again, we're using the old input system, but we're very soon going to switch to the new input system.
And it's going to look a little bit different.
So, we've got the old input systeming using get input or input.get get access horizontal which gives us the left and right value which is the arrow keys A and D or remember it also is the thumb pad or the thumb stick here the left thumb stick on a normal controller.
So it gives us a value of negative 1 to positive one depending on if we're pushing all the way to the left or all the way to the right.
We log that value out which we probably don't need to keep doing really.
It's kind of obnoxious.
So I'm going to delete that line right here.
Line 53.
And then we'll go down to line 54 where we get the rigid body component.
And then we set the ver or we get the current y velocity of our rigid body and set that in vertical.
But don't we already cache the rigid body up in our awake? Let's go take a look.
So we don't cache our rigid body in awake.
And that's something that we should probably do as well.
So we're going to make that change now.
We're actually going to go up to the top and we'll replace this code here and say underscore rigid body.
Actually, let's do RB since that's what we've done before.
RB equals get component.
And we'll put in a rigid body.
But we don't want a rigid body.
We want a rigid body.
2D.
Very important that we get the 2D one.
I'm going to generate a field for it.
And then we'll add another space.
We'll get rid of that private keyword.
And then we'll scroll down.
So now we've got a cached rigid body.
And we'll delete line 56 and add an underscore to our vertical.
Look at that.
I already feel better about our code.
You'll see down here on line 72, we've got an error.
We'll talk about that in a moment or we'll fix it in just a moment.
So, we get our vertical velocity from the rigid body, our current vertical.
So, if we're going up, we know that value.
If we're falling down, we know what that value is.
And then we check to see if the player has pressed the fire one button because we're using that to jump.
That's our left click or left control.
And they have some jumps remaining more than zero.
So if the value is greater than zero and they've pressed the jump button and remember get button down in the old input system is the frame when they've pushed the button.
So it's not if they're holding the button but if they push the button this frame then we set their jump end time to the current time plus the duration of a jump.
So if it's 1 second jump then we would set it to the current time plus 1 second.
So that way we know hey that at 2 seconds in the game if we start did this at 1 second we add another second at 2 seconds in their jump needs to end and we'll use that later on in our code remember then we decrement their jumps remaining by using the minus minus which just removes removes one or reduces it by one.
We set the pitch of our audio source so we can get that cool effect based on how many jumps we have.
And here we're using that conditional operator.
So if jumps remaining is greater than zero we set the pitch to one.
If it's less than zero, so it's not greater than zero or equal to zero, then we set it to 1.2.
And then we make the audio source play.
We could probably delete that space on line 64.
I'm going to do that.
Line 67, we check to see if they're still holding down the fire button.
Remember, this is the frame that they clicked it.
This is the button any every frame that they're holding it down.
Get button will return true.
And it's still an okay time.
and we determine it's an okay time by saying that the end time is sometime greater than the current time.
So if we haven't gotten to the end time, they're still holding the button down, we let them keep going up.
So we keep setting their vertical value to jump velocity.
And imagine that their vertical value is like a positive three.
So they're going up 3 m/s.
As long as they're holding the button, they're going up 3 m/s.
Otherwise, they're going to start falling down based on the rigid body.
It's going to start pulling it down with gravity and falling on its own.
And so it'll be three, then it'll be like 2.9, 2.8, 2.7, and so on till it starts to get to negative values and falling down.
Then on line 71 where we've got our error, we set the velocity of the rigid body to our newly calculated value.
Let's uh add an underscore there.
Oh, and talk about line 70 where we multiply our left and right speed by our horizontal velocity value.
And remember that was a serialized field controls essentially how fast we run.
I'm going to go back and then take a look at the last bit of code here.
Line 72, we call update sprite.
If I hit F12, you see that it actually updates our animator and our sprite.
So, it probably needs a rename, but we're not going to do that yet.
The animator gets a boolean set for whether or not it's grounded to modify its jump sprite mode.
So whether or not which shows a jump sprite and then it gets a float for its horizontal speed which passes in that absolute value of the horizontal speed which is just that value without the minus sign.
Then if they're going to the right we flip or we set flip X to false so that the sprite's not flipped and it's at the normal mode.
And if they're going to the left we set flip X to true so that it flips over.
And if they're not going anywhere, they're not pushing left or right, then we don't flip it.
So they stay whatever direction they were facing.
That is the entirety of our player script.
So hopefully we now understand everything that's in here because we've got a lot more code to write, a lot more really cool stuff to do, and things are going to get a lot more, I think, interesting and fun.
All right, let's save this off.
We'll go back into Unity into the plastic SCM window.
We should have a couple of changes here to commit.
So I want to get this window open.
We'll do a diff now since we've been doing those.
We'll right click on this player and hit diff so we can see our changes before we commit them.
The minor modifications we've added, we moved the jump time down so that it was in a better space.
We removed some unused using statements.
So this is showing us that those were removed.
They used to be there.
Now they're not.
It's showing us that our animator kind of got moved around.
It got deleted and then readded down here.
And let's see, our rigid body component is now being cached.
If we scroll down further, we'll see that we're using the cache rigid body in both of those places.
And that's pretty much all of our changes.
So, I'm going to close this window.
We'll go add in a commit message that we cleaned up the player class a little.
And we'll check that in.
Before we add more complexity to our game, we're going to add a service to make things easier.
Specifically, we're going to make it easier for us to share our game with friends, family, or other students.
and we're going to do that by automating our build process.
To start, we need to go to the services window and we're going to hit explore.
This should bring up the packages manager with all of our services available.
It's going to go to this services tab and I want to find the cloud build package that's inside the DevOps section and then choose install.
This is going to install the build system that allows me to automatically get a build whenever I do a commit with plastic.
So, I'll do a commit or a checkin and a build will happen automatically that I can share with other people without me having to go through a manual process, upload a file or anything like that.
So, once I've started and I've imported it, I'm going to get this link Unity project option.
I'm going to need to go to my project settings and set up my project with my Unity account.
So, let's do that now.
I'll hit the project settings button and I'm going to choose new link.
I'll select an organization.
I'll use my organization that I have and hit create project ID.
This is going to give me a project named Alien Blaster.
And it's going to ask me right down at the bottom whether or not this is targeted at children under age 13.
I'm just going to say no because it is definitely not.
It's not really targeted at anybody.
And then we'll hit the save button.
Now I'm going to go to my cloud build section.
So now notice that we have a cloud build option underneath project settings.
And right up here in the top right corner you can see that it's not turned on yet.
So I need to check it and enable cloud build.
Once it's enabled, it'll update in here and it's going to give me the option to upload a build, add a target, or add or look at my build history.
But what I really want to do is I need to add a target.
And I want to do that well here.
Let's just hit the add target button.
It'll open up my dashboard.
Say I want to do it through the dashboard.
But that's what it's going to do.
It's going to open up my dashboard.
So I'll open up the dashboard.
It's going to have me sign in.
And if yours initially looks like this, it's fine.
Just hit that take me home button and it should look like this.
And if you see this section right here, it says latest builds, no builds, and you've got a cloud build section.
I can just click on this, go back to my build section, and then I need to set up a build target.
It says no build available yet.
So I'll hit set up a build target.
And then I do have source control.
So I'm just going to hit get started.
And then we need to choose our source control type which is going to be plastic SCM right up at the top.
And next we need to put in our source control provider URL.
And you put the mouse over you see that it wants your organization atcloud and mine is gamecourses atcloud.
Yours is going to be different though.
If you're not sure what yours is, make sure that you go to your project and look down here at the bottom right.
Mine's alien blaster at gamecourses atcloud.
Yours is going to be something else.
Whatever you set up the name of your organization as, that's what it's going to be.
So, it could be Alien Blaster if you use that, but only one person could have that.
So, I'm sure it's something else.
So, make sure that you put in the correct organization there.
And so, your organization name at cloud.
We'll leave authenticate with Unity ID on everything else default.
And hit the save button.
This should create or link up our source control.
There we go.
says, "Our settings have been successfully saved.
Now, I'm going to go over to the configurations window.
I'm going to hit the quick target setup and we're going to choose a WebGL setup.
What we're going to do is have this build us a WebGL version of our game so we can play it in a web browser and then just share that with other people very easily without even having to send them an executable.
Now, it's got the option here.
Well, it has a couple options.
First, there's a repository option.
I've got lots of projects.
It knows which one I want, though.
Alien Blaster.
So, we're going to use that.
And then it wants to know which branch to use.
We only have one branch, which is main, and we're going to stick with that.
We don't need a subfolder, and we can allow it to use the latest 2022 or build with the one that we have.
I'm just going to allow it to use the latest.
And then we'll hit next.
And we can let it build from a Mac.
I don't really care what system it's building from.
It's for a WebGL build.
And then we've got some options for scheduling.
Do we want to auto build whenever we get a new repository update? Do we want to auto cancel? Which the answer to that is yes.
So I'm going to check it.
Do we want to auto cancel if we have a build pending and a new build is triggered? Probably.
So if we check in and we check in again, do we want to build all of those versions or we just want the latest? I think just the latest.
And then do we want a recurring or repeating build schedule? So if we don't want one every time, we might want to have like a daily build or every two hours or whatever.
I don't want that though.
I just want every every time I commit to do a new build.
So we'll hit save configuration.
And we are done.
That's all we need to do to set up our build automation.
Now, I want to actually force a build though.
To do that, I'm going to click the build button.
And then we'll choose the latest.
Oh, I don't need to choose a chain set.
We'll just hit the build button.
It'll use the latest.
That's if you want to specify a specific change set to build instead of doing the latest.
So, I'm going to have it kick off a build for the latest version of our game.
And that is going to take a while.
I'll hit build view details.
Just remember that when you do these builds um on the especially on the free version, it's going to take a while for the build to complete.
It's not something that happens instant.
It's not automatic.
It's not nearly as fast as if you run it locally, but it is very easy to share with other people.
Look down here.
We've got an auto share button.
We can hit view settings and we could even start to share this.
I'm going to talk about sharing our project later, though.
For now, we'll let it build and let it finish.
And then we'll take a look at the end results as soon as it's done.
Now that my build is finished, let's take a look at it.
The first thing I want to notice or point out is that this is actually build number four.
And that's because after I started the build, I committed a couple changes and then had more builds kick off and cancel my first build.
So, I hit replay and got a new build of the first version.
Now, I've got a couple options when I open this up, though.
There's a play button right here and a share button.
I can hit play and actually load up our game in a WebGL player.
I can choose the resolution.
I'm going to choose 1920x 1080.
Hit apply.
And then look at our character running around, jumping.
Look at this.
Everything is working just like it is in our editor.
We've got a full working version of it running in a web browser.
Oh, except for the part where we kill our player.
For some reason, that's not in here, but it's probably has something to do with our build settings.
For now though, I want to also show you the share button because if you want to share this with friends, you can just click that share button, get this link right here, and send it off to whoever you want, and then they can go play your game whenever you want.
So, you don't have to keep um sending them new builds and stuff.
You can just send them your link instead.
All right, with that said, I just want to say that this is a very cool system.
It makes it very easy to do builds um and to share them automatically.
It's not completely free though.
There's some free amount that comes with the Unity Cloud system, the Unity Plus and Pro memberships.
I don't remember what that amount is, and it changes relatively regularly.
So, you may or may not want to have builds on for every build.
You may want to go into your build settings, go to the configuration.
In fact, I would probably recommend doing this.
go to your build configuration and go to your auto build and just uncheck that until you're ready to actually start sending out and sharing those builds.
Once you have builds that you want to send out and share, then go back, reenable that, and have it start giving you those builds.
But until you're doing that, you can always just come in here and hit build and do a quick build on demand.
So whenever you're ready to share, you can hit that button, get your link, and then send that out.
So you don't have to do the whole process every single time and add, you know, it it's only a couple cents each time, I think.
And like I said, there's a free amount, but it does add up and there's no reason to add it up if you're not actually using it.
It's time for us to start building enemies.
And we're going to start with a simple one that bounces back and forth.
A basic frog that will jump back and forth over the spike or wherever we want.
And we'll make sure that it's customizable and reusable.
So, we can have the frog bounce across anywhere or maybe even change him out with a grasshopper or something else later on.
So, let's take our frog.
I'm going to go to my assets, art, and enemies folder.
Find the frog graphic.
And I'm just going to drag it right out here into the scene kind of next to my spikes.
I'm going to go click on it.
Just make sure that the pixels per unit matches 128 and 128.
And then I'll zoom in and go select my frog.
My frog's going to need a couple of different components.
I'm going to want a collider on it for hitting things and landing on the ground and stuff.
And I'm also going to want a rigid body for jumping.
And then probably some sort of a frog script for jumping and handling that kind of bouncing around part.
So, first let's add a collider.
We're going to just start with a box collider 2D.
Something relatively simple that we can fit over our character.
We're going to shrink this thing down because it's probably too large.
Let's go check our sprite render.
Let's see.
Where's our box collider? Adjust the size down.
We can see the the white lines right there.
I can I can actually see them with the sprite render on or off.
So, it didn't matter.
I didn't need to turn it off.
So, I'll leave it on.
And let's get a value of about 0.5 on the size of the box collider.
And a value of about 0.25, but negative.25 on the um the Y offset there.
I think that's pretty close.
I think I want this to be a little bit taller, though.
Let's go 5.5.
Or let's go to maybe like a 6 and a.3.
No, 2.
There we go.
22.
Sometimes it's a little bit of just messing around and not a lot of exact perfection.
So, I'm going to go with a 6 and a negative.22 for the offset and the size there.
Now, I've got my frog set up.
I want to add a rigid body to him so he can bounce around and fall.
We'll use the rigid body 2D.
Of course, it was already found there because I had BO on my search and rigid body has a BO in it.
So, it kind of kind of fit and matched.
All right, let's save and press play.
I should expect to see my frog just kind of sit there, not really do anything.
But, he's going to be a little bit far away, so I'm going to have to run over there and go visit my froggy.
Say, "Hey, little frog.
Where you at?" There we go.
Look at that.
My frog is there.
He's ready to start jumping.
So, let's stop playing and go create a frog script that will allow our frog to jump back and forth.
I'll go into my scripts folder.
I'm going to rightclick, choose create, and choose C script.
We're going to name this frog because that's what he is.
And then we're going to attach the frog script to the frog.
Now, when I created the script, it automatically opened up my code editor.
Sometimes that happens.
I'll just minimize it.
Go back over.
Select my frog.
I'm going to rename him to capital frog because I want it to be nice and clean.
Minimize our rigid body.
Drag the frog script over to the frog so it's on him.
Save my scene and then open up the frog script by double clicking on it.
There we go.
We're in our frog script.
So here we're going to need to write some code to do some jumping.
We want our frog to jump and then turn around and jump again and then jump and then turn around and jump again.
And to do that, we're going to need to access the rigid body component and probably the sprite renderer component.
So, let's save those off right at the beginning.
Let's start by deleting out our start and update methods.
So, let's at least delete out our start methods.
Let's leave the update method there.
If you already deleted the update method, just hit control-z.
Let's delete out the start method and we'll add an awake instead.
So, I'm going to say awake and then let it autocomplete.
Get rid of that private keyword.
You can stop it from autogenerating that private keyword.
I'm not going to dive into how to do that yet, though.
So, if you got your awake method here, we're going to need to save off our rigid body.
And remember, we do that by going underscore RB, which is short for rigid body.
Just a little bit easier to type.
It's one of the few that I actually abbreviate.
In fact, it's probably the only one I abbreviate.
Equals.
And if I hit tab, it's going to autocomplete, but it's going to get me the wrong one.
I want the rigid body 2D.
So, I need to add in that 2D.
Then I hit the home key, alt and enter and generate our rigid body field.
Now we need to get the sprite renderer as well.
So we'll say underscore sprite renderer.
And you might be wondering like why don't you abbreviate that? And it's because generally I'm not lazy but with rigid bodies for some reason.
I've stolen the habit of abbreviating them like everybody else does.
So we generate the code to get component for our sprite renderer.
I'll hit alt enter and generate the field for the sprite render.
Remember, we have to click on it first and get rid of these private keywords.
Double click.
Delete.
Delete.
And now, let's look at how we're going to jump.
And let's look through a couple different options.
There are a few different ways that we could do a timed jump.
I've got a frog and I want him to jump every 3 seconds or every 5 seconds or some number of seconds.
I could do that through the update method.
Remember, in our update, we keep track of when the player's jump has to end.
And we could do something similar to keep track of a timer for when the frog should jump again and put put that into our update method.
But there's another way to do something when we need to do something very simple like that on a specific timer.
And I think that this is a perfect time to introduce that.
So we're going to add in a new line here after our sprite renderer caching on 14.
And this is going to be an invoke repeating call.
We'll call in Nv repeating.
There are two versions of invoke.
We want the repeating one.
And here we need to give it the name of a method, the amount of time to wait for the first time that it calls it, and then how long to wait in between each time afterwards.
We're going to give it the name of a method called jump.
And we have to give this in quotation marks.
So put quotes Jump M with a capital J.
We're going to add a comma and put in our first parameter, which is the duration or the delay.
And I'm gonna use a variable here.
I could put in a hard-coded value like maybe three and three, but I want to make this variable.
So I'm going to put underscore jump delay and then we'll put another comma for our repeat rate.
We'll use that jump delay again.
We'll add a ending brace or ending parenthesis and a semicolon.
Then we'll generate the jump delay field.
So I'll hit alt enter and we'll hit generate variable and generate a field.
Don't generate a method.
We want to if you hit just alt enter and generated a method, you're going to get some bad invoke repeating method.
Just hit undo.
Make sure that you go generate variable and choose field.
We've got our field here for our jump delay.
We'll replace the private keyword with the serialized field attribute.
Get that closing square brace.
And I'm going to give it a default value of three.
So we've got a 3se secondond jump delay.
Now this is going to try to call the jump method every 3 seconds.
But we don't have a jump method.
So let's delete our update method and add a jump method instead.
I'll delete out line 19.
I'm just going to hit shift delete and delete that whole line.
And then replace the word update here with jump.
There we go.
I've already got the void, the parentheses, and the braces.
Why recreate them? So, now I've got my method here to do the jumping.
And the jumping just needs to tell my rigid body to go flying off in some direction.
And to do that, we add force.
And we call RC RB add force.
There we go.
I typed it wrong, but autocomplete found it for me.
And then open parenthesis.
And we need to give it a vector for our force.
So we need to tell it how much force to give in what direction.
So we're going to just call this force.
And then we need to figure out what that force variable is.
So our force is going to be some jump force that maybe we should expose to the inspector.
Why don't we do that? Let's instead of calling this force, let's call it underscore jump force and then hit alt enter and generate a field.
We'll make that a serialized field by copying that attribute, pasting it over the private keyword, and saving.
Let's go back over to Unity and see what this looks like.
Now, let's clean up our frog's visuals.
Right now, our frog just kind of bounces back and forth while staring to the left.
And we do have a jump animation.
So, let's use it.
And let's make our frog face the correct direction as well.
We're going to select the frog and we're going to open up the frog script to start.
And when we do a jump, the first thing I want to do is just change our jump direction.
So every time we jump, after we jump, we'll turn our jump around.
And to do that, we're going to add a new line after our add force.
And we're going to say underscore jump force star equals, which is going to multiply it by some number.
And we're going to multiply it by a new vector 2.
And the first value of our vector 2 is going to be a negative one.
So this is going to flip our x of our jump force.
So if we're going to the right, we're going to go to the left.
If we're going to the left, we're going to flip it to the right.
So it's going to go from negative to positive or positive to negative.
The second value we're going to pass in is a one because we don't want to change our y.
Our y should stay the same for every single jump.
If we wanted to change that, we could do that here, but we don't.
We're going to add a semicolon after our parenthesis and then save.
And this should make our character jump back and forth.
Let's go make sure that that's correct before we continue on.
So, we go back in.
We'll press play.
I'm going to take my game view and drag it down here so I can watch the frog without having to run over there because I'm feeling a little bit lazy.
I don't want to run my character over there.
So, we watch our frog and he jumps any second now.
And then I expect him to turn and jump back the other direction.
All right, looking good.
So, he's doing his little bounce.
That looks cool.
But I want him to now face the correct direction as well.
So let's go back to our frog and let's change his sprite renderers flip X value.
Remember we use that to swap the direction that our player was facing.
If we go find our player and look for flip, we should be able to see that we use our flip X value depending on if we're going to the right or the left.
So we're going to go back over to our frog and do the same.
When we jump, we'll say sprite renderer.flip flip x equals.
And here we're just going to do the opposite of what it currently is.
To do that, we use the not sign.
So shift and one, which is the exclamation or not.
It's kind of weird.
It means a whole lot of things, but it means the basically the inverse or the opposite of the value that we're going to give it.
And the value we're going to give it is sprite renderer.flip x.
So we're going to set the value to whatever the opposite of the current value is.
We'll save that off.
Let's go back into Unity and try it again.
We should be able to press play and watch our character kind of do a flip.
Let's see if that's the truth or if if I'm just making things up or if he bounces and looks right.
So, he flips and he looks right.
So, he jumps, notice, and he switches directions at the same time.
So, it actually works out kind of perfect.
The last thing I want to do though is show that sprite.
I want to show the jump sprite because why not use it? We have a cool jump sprite.
We should be showing it while we're in the air.
So, let's add a reference to a jump sprite right here in line 12.
I guess we'll add a serialized field and we'll call this will be a sprite and we'll call this underscore jump sprite.
This is something that we're going to assign.
And then when we're jumping, we'll put that sprite in here.
So, we'll go down to line 25 and we'll say sprite renderer.sprite equals_jump sprite.
So, when we start jumping, we'll put in that sprite.
Let's save that off.
Go back into Unity and assign our jump sprite to our frog.
Now, it should appear here as a field.
And we can hit the little search box, find all of our sprites.
I'm just going to search for Oh, not for a frog.
There we go.
Frog move.
That's the jumping one.
Ah, I clicked too many times.
There we go.
I've got my frog selected.
I should be able to save, press play, and watch my frog switch to a jumping sprite.
Let's see.
see.
see.
Come along, little froggy.
Jump, jump, jump.
There we go.
He jumps.
And okay, it's close.
Except when he lands, he doesn't switch back to the normal sprite.
So, the last thing we need to do is make him switch back to his normal sprite.
And I'm going to leave this as a little challenge for you.
Go ahead and see if you can figure out the code to make your frog switch back to the normal sprite when he lands on the ground.
Don't do anything too complicated.
You shouldn't need to do any ray casts or anything.
Keep it relatively simple.
And then once you're done, or if you get stuck, just unpause, continue on, and I'll show you the solution.
All right, I'll assume that you've gone through it or you got stuck.
No problem either way.
So, what we're going to do is go into our frog and just listen for our collision enter.
If we hit anything, we'll go to the idle mode.
Even if we smack something on our head, it'll be fine.
We'll just switch because we don't really have a sprite for that anyway.
So, we're going to add an on collision enter right in between.
Oh, actually, let's do it after our jump.
Right after our jump, we'll do an on collision enter 2D because we're doing 2D graphics, 2D physics.
We'll delete that private keyword.
And here we're going to set the sprite renderer sprite back to its default sprite.
So say sprite renderer.sprite equals_default sprite.
Now go wait, we don't have a default sprite.
Where did that come from? Oh, we just have to generate it.
So we'll hit alt enter, generate a field for it, and we'll now have a sprite up here.
I'm going to move that to be well, let's delete the private keyword and move it to be up here, right below my sprite renderer, but with a space since it's not a component.
it is a cached property of a component or a cached field of a component.
I want to have it a little bit of spacing there.
Just the way that I like to organize my things.
So now we need to set this default sprite.
And we can do that right here after line 19 on line 20.
Say underscore def Oh, look at that.
It already knew what I want.
Well, it kind of knew what I wanted to do.
We want to say underscore default sprite equals sprite renderer.sprite.
So this is going to get the sprite that we had before.
I'm adding an extra space there.
get the sprite that we start with as the default.
When we land on the ground, we'll switch back to that.
So, we'll save or really when we hit anything, we're going to switch back to it.
But that's good enough for now.
We don't necessarily need to worry.
If we hit a player, we want to kill the player.
If we hit something else, we don't have a really a sprite to deal with that.
And if we're hitting our head on something, we probably placed our frog wrong.
So, let's let the frog jump and see if he does his thing.
There we go.
He bounces to the right.
Looks good.
He bounces to the left.
So far, I'm loving it.
All right, we'll stop playing.
I'm going to save my scene, go to plastic, and say that we've added or up.
How do I want to put this? Frog Frog Frog flips graphics and um I think that's Oh, and sprite.
Yeah.
Ah, frog flips graphics.
That's probably enough.
I I'm not sure what to put for my check in.
So, I'll put that and hit the button.
Now, let's talk about killing players again.
Right now, we've killed our player with the spikes, and our frog should probably be something that kills the player as well, because what's the point of an enemy that isn't a threat? So, we need to add a way for our frog to kill the player.
And we've got a couple of options here.
Just like anything with code, we can go about this multiple different ways.
We could go into our frog and modify our on collision enter so that if we hit a player, we also kill ourselves or we al or kill the player, not ourselves, but kill our player.
The frog will kind of die too cuz the level reloads, but you get the idea.
We don't need to do that though.
There's actually something quite a bit simpler that we could do.
Since we already have a spike script that kills a player on collision enter, we can just go to our frog and drag the spikes on top of it.
Now, our frog has spikes and our frog will kill players when it touches them.
Don't believe me? Hit save, press play, run over, and go touch your frog and see what happens.
Let's go try it out.
I want to see it in action myself.
So, I run over here and I go find my frog.
And any second now.
Oh, look at that.
I touched him and I died.
Now, I didn't actually touch him.
You might have noticed that I got kind of close to him and and it happened.
And that's because his box collider is just too big.
So, I'm going to minimize that.
We'll stop playing.
We'll go select it and we're going to shrink down the width of his box collider.
We could also alternatively just swap him over to use a polygon collider 2D if we want, but I think that just shrinking the size of his box collider to maybe a point 75.
There we go.
And get it nice and tight so I don't have to worry about accidentally rubbing up against them.
But again, if I want, I can just uncheck that.
Go add component.
Add a polygon collider 2D.
And now I'll have an even tighter collider.
In fact, let's do that.
Let's remove the box collider.
Have the polygon collider.
Save.
Press play.
and go try it out.
This way when when a kid jumps on it and says, "Hey, I just didn't even touch that thing.
My head barely it went over the head and I still got the hit.
That sucks." Um, we won't have that problem.
Or at least we won't have that problem nearly as much as we would have with a box collider.
So, come over here.
Check it out.
Our frog comes.
He lands.
Oh, I hit a spike.
Let's try one more time without landing on the frog.
There we go.
The frog killed me.
I collider on my player is also a little big.
So if I stop playing and go find my player, I can shrink down his width of his collider, too.
See how it kind of goes out to the edge a little bit too far.
Let's go grab the size here and put this down to a 75 so that it's quite a bit tighter and I don't have to worry about those early hits where I can't see it and it doesn't look right.
So we'll save.
We'll go into plastic and we're going to make sure that everything is saved.
We've got our frog saved, our player saved.
So, we adjusted frog colliders and made frog kill the player on touch with spikes script.
And actually, we adjusted the player and frog colliders.
So, I should put that in my check-in message.
Before we turn our frog into a prefab, let's make him a little bit smarter.
Let's give him the ability to jump some set number of jumps instead of just once back and forth.
To do that, we're going to need to open up our frog script and make some minor changes.
And what I'd like to present to you first is a quick challenge.
See if you can come up with the solution of how to make your frog jump two jumps instead of one or maybe some variable number of jumps.
If you're up for the challenge, go ahead and give it a try right now.
If not, then go ahead and just unpause right after I say to pause and continue on and I will show you the process.
All right, let's go ahead and I'll show you the process.
Now, hopefully you either found the solution or you're just ready to go through it.
The first thing that we're going to need to do is set some number of jumps that our frog can make.
And I'm going to do that by going up above line 12 and adding another serialized field.
I'm going to make this an integer so that it's whole numbers and I'm going to call this underscore jumps.
I'll set it to two so that our frog will default to having two jumps.
We're also going to create a variable that we're going to use to keep track of the number of jumps remaining.
So, I'm going to do that after line 10.
I'll say int jumps remaining.
Now, in our jump code, we're going to do a little bit of checking.
We're going to see if we have any jumps remaining.
And if we don't, we're going to flip around.
If we do, then we won't flip around.
That's pretty much all there is to it.
So, we'll add some lines here.
Line 28.
Right after line 28, say if underscore jumps remaining is less than or equal to zero.
Somehow, if we get below zero, we're still going to want to run this code, but we should only ever get to zero.
So, if we're less than or equal to zero, then we want to run some code.
And the code that we want to run is the code that flips our jump force.
So, we're going to take jump force star equals new vector 2 and cut that line out.
So, select the whole line, hit X, and put it right here on line 31.
And then after that, we need to reset our jumps remaining.
So, I'll say jumps remaining equal Oops, if I get that right, remaining equals jumps.
So, when we run out of jumps, we'll flip directions and then reset our number of jumps remaining to however many jumps we allow.
I'm going to add another line here so we have some space.
Not add an else like it's recommending.
And then let's save.
Get rid of our star here and go back into Unity.
We should see our frog in here with a new field for a number of jumps.
There we go.
I've got two jumps available.
And if I press play, I expect to see it not be perfect.
Let's see it, though.
Let's hit play and watch our frog jump and see what we've got going on here.
So, our frog is there and he'll jump.
and he jumped, but he's looking the wrong direction and he's jumping kind of far and then he went into the water.
Okay, so got two little issues there.
One, he went way too far and now I've lost my poor froggy.
He's falling through the world.
And two, um, he's not looking the correct direction.
So, step one, we're going to just reduce the jump force.
So, I'm going to change this to about 150 on the X so that he doesn't jump as far in that direction.
But first, I want to or after that, I want to go into my code and make sure that he actually jumps to the right so that he actually starts jumping to the right because I have it at 150.
He doesn't instantly flip to the left.
If I open up my code again, you'll see that we don't ever set our jumps remaining to jumps when we start.
Initially, we just kind of have a zero and we get reset and flip over.
So, the first time we call jump, jumps remaining is at zero because it's never set and it gets flipped over to the opposite direction.
I don't want that.
I want it to go the direction that I had it facing or the direction that my velocity is set to by by default.
So in awake I'm going to say underscore jumps remaining is equal to underscore jumps.
So that way we get set to the value that we have by default and we stay going in our correct direction.
The other code that I want to fix is with our flip x.
Now our flip x value before was just swapping back and forth because it made sense.
it's a boolean and we're toggling back and forth based on the direction we're going.
That no longer makes sense.
Now, we want to set it to true if we're going to the right and false if we're going to the left.
And we can do that just by looking at our jump force.
So, we'll say flip x is equal to underscore jump force.x greater than zero.
So, if the x value of our jump force is greater than zero, we're going to the right, then flip x will be true.
Otherwise, it'll be false.
We'll save this off.
Let's go look at our sprite, though, because remember our frog by default is looking to the left.
So that's why that makes sense.
We have to flip it to look to the right if our character is going to the right.
If our character was going the opposite direction, the logic of that code would need to be inverted or swapped.
Let's save our scene, press play, and watch our froggy do some jumping.
He should go hop hop hop or hop hop and then hop hop.
Let's see if that's true.
So he jumps any second.
There we go.
hop and a hop and then he should flip around.
Oh, three hops.
Let's see if he's going to flip on this third.
So, he's never flipping around.
He's never actually turning around.
Let's go back to our frog and take a look at what's going on here.
So, why is he never turning around? Well, we never decremented his jumps remaining.
So, let's copy jumps remaining and let's say jumps remaining minus minus on line 35.
We'll minimize.
Go back into our Unity editor.
Press play one more time.
And now our frog should jump two times and not some unlimited number of times.
He should actually obey our frog jump count.
Let's see if that's true.
So we play.
Our frog should jump and then he'll jump again.
And then he's going to turn around and jump back.
Look at that.
We've got a frog now that goes back and forth any number of jumps that we specify.
Right now it's on two.
Let's say we want to go to three and have them jump back three instead.
I go one, two, two, two, and three.
And look at that.
We've got a nice cool bouncing back and forth frog.
Let's stop playing, save our scene, and turn our frog into a prefab.
So we'll go to the frog the prefabs folder.
We'll take our frog, drag him down into there.
We'll save our scene, save our project, and then go to plastic and say that we've added the jumping frog prefab with variable jump count and distance.
And we'll check in our changes.
Before we make any more enemies, let's add some sound effects to our frog.
Let's add a weird sound that we found on Open Game Art, or at least that I found on Open Game Art that I think will work pretty well.
There's this mutant frog sound.
I think that those work pretty good.
So, I've downloaded this zip and I'm going to open it up and then we'll copy the files into the project.
So, I'll grab my zip file.
Open it.
Oops.
Let's go.
Open it.
Select the two frog sound effects, the two OGs.
I'm not going to grab the wave that has both of them.
And then I'll close that window.
I've got them both copied onto my clipboard with C.
Go back into Unity.
Go to my audio folder.
Show in explorer.
I should see my audio folder right there.
I can double click it and paste with CtrlV.
Once those files start to appear, I'll close this window, jump back into Unity, and I should see my two frog sound effects.
I'll select my frog, take that frog one sound, drop it right on them, press play, and make sure that I hear a frog sound right when my game starts up.
There we go.
So, that's working.
Now, I want to make this sound effect play continuously.
or not maybe continuously but perhaps when the frog is about to jump or maybe just when the frog is landing.
Let's uncheck play on awake.
Go to our frog script and then in our frog script when we do our on collision enter let's tell our audio source to play.
So we could call get component audio source oops not audio behavior audio source and tell it to play just like that.
But since we're already caching things we should probably do that here as well.
So, I'm going to copy this get component part.
Put it right onto my cursor.
Hit controll X.
Go up to awake right up at the top.
Put underscore audio source equals.
And then I'll just paste and hit semicolon.
Click on audio source.
Hit alt enter and generate a field.
And I should get a field right up here at the top.
It's a private audio source named audio source.
I'll double click private and doubleclick delete to get rid of that keyword.
Now, down here at the bottom in on collision enter, I'll just say underscore audio source.play.
Now, if I go back into Unity, I should hear my frog bouncing around making sounds.
Oh, I think I rechecked play and awake.
I'm going to have to make sure that I uncheck that.
So, let's listen.
So, he jumps and we hear the sound and we hear the sound again.
But this is a little strange, right? He is kind of far away for me to be hearing that.
I probably should only hear him when he's on screen.
So, how can I do that? Well, there's actually a really easy way to do that and it'll add a really cool effect as well.
So, let's stop playing.
I'm going to minimize some of these scripts on my frog.
Uncheck the play on awake option and let's scroll down to 3D sound settings.
It may be collapsed for you.
If it is, just expand it out by clicking the little arrow or on the text.
And what we want to do here is use 3D positional sound.
Unity has a 3D sound system built in, and we really just care about whether the thing's off to the left or the right.
So, we can set this up to use just our 3D position based off the the left and the right.
What we need to do first is change this from logarithmic roll to linear roll.
We can use logarithmic if we want, but I like a linear roll off because it'll make it nice and easy for you to see what's going on, and I feel like it makes a little more sense when we're building a 2D game.
Of course, you can change this later.
Use whatever you like, but I want you to use this just to start.
I'm also going to change the max distance to be about 10.
Look at the circle here.
Now, you can see the range of our audio effect or of our audio distance.
If I just press play, though, it's not going to work.
It's going to give me the same sound effects.
Watch.
Let's just hit play and make sure that I'm not crazy that we do hear the same sounds.
Yep.
See, it still played the sounds.
When it lands again, it's going to play the sound again.
Yep.
So that's not what I want to happen.
What I want to happen is it for it to use the 3D sound effect.
So I need to take the spatial blender slider and drag it all the way over to one.
Now it will use 3D sound.
But there's one big big problem with this.
Now if I press play, let's watch what happens.
So I play go run over here.
I don't hear anything from the frog yet.
Okay, seems okay.
My player sounds are good.
Let's come over here.
I'm still I'm inside the frog range.
Why don't I hear anything? Well, the reason for that is because we're using 3D sound in a 2D game.
And this sound systems really built for 3D.
So, if we go into 3D mode in our scene view, go to the scene view, check the 3D 2D button, and go look at our frog.
We can see that our frog's audio circle is that big blue circle.
That's the whole thing.
If I collapse or here, let's uncheck it.
You'll see it's turning on and off.
That big circle is the audio part.
Where's our audio listening device? Where's the thing that we pick up audio from? You might think it's the player, but it's actually not.
By default, it's the camera.
It's this object way out here placed outside the world, kind of back far away.
So, let's go select that frog and the camera at the same time.
And you might see why it's not working, why we're not hearing anything.
The frog's circle isn't overlapping with the camera.
So, we need to do something about this.
We've got a lot of options.
We can move the camera.
Maybe we could move the audio source or maybe expand out the range of this frog.
We could maybe make this like 20.
So, if we set this up to like a 20, then it's going to be in range.
But when I go to 2D mode, I can't really tell what the range is anymore.
and it's like half the range that I see and I don't really like that.
So instead, we'll stop playing.
And what I want to do is go to my main camera and find the audio listener component.
There's only supposed to be one of these in your scene.
So I can't just add a new one.
Instead, I want to remove the one that's on my main camera.
Go down to my player and minimize this audio source.
Hit add component and add an audio listener.
Oh, look.
I've already got it typed out and selected.
So, just choose audio listener and add that onto the player.
Now, the listener is going to be at the same 2D space or the same Zdepth as our frog.
So, they'll both be lined up and I should hear it as soon as my player gets within 10 meters or within that circle.
Let's go try that.
Here's my player.
You can see him in both views.
Come over here.
I'm just about in range.
I can hear him bouncing.
There he went.
And you may or may not be able to hear it, but there's actually spatial audio.
I can hear the side he's on.
So, if you have stereo speakers set up with your left and right setup, you should be hearing him jumping from the left to the right.
If you don't have that, or maybe just go put some headphones on and hear it.
You'll hear the cool effect.
It's pretty neat and extremely easy to get working as you can tell.
So, let's stop playing, go into plastic SCM, save our level, make sure that that's in here.
So, we added 3D frog sound effects.
and check in.
It's time for us to add a second level to our game.
But before we can do that, we really need a way to get to our second level.
So, let's start there.
We're going to begin by going to our art and tiles folder.
And let's look for a flag or something that we can use to bounce up to the next level.
In fact, I think is it perhaps in items? Ah, there we go.
In items, we have some flag options.
I'm going to take flag blue one and just drag it right out here into our scene view.
I'm going to set the position to six and -3.5 so that it's perfectly grounded.
That looks good.
And then we're going to add a collider.
We'll add a polygon collider 2D.
Not a polygon 2D, Jason.
Remove that.
We'll add a polygon collider 2D.
And then we're going to add in a script that will allow us to load up a level.
Let's call this a loadle script.
To do that, we'll go into our assets folder.
We'll go to the scripts folder and we'll hit create and choose C script.
I'm going to call this script load level.
No spaces, but two capital L's, not three, just two.
Capital L for load and capital L for level.
L O A D L E Vel.
Hit enter.
That should generate my script.
And it does not open it up the first time.
Like I said, a lot of the time it just opens up whatever you had last.
So, I'll go back into Unity.
Once it finishes recompiling, I'll double click the load level script again.
There we go.
And in here, all I want to do is check to see if the player has entered this object or touched this object.
And if so, load up the next level or load up a specific level that I've maybe laid out by name.
So, I'm going to take all of the code from line 7 to 17, select it, and delete it because we don't need a start method, and we don't need an update method.
And instead, we're going to add an on collision enter 2D.
There, where is that at? On collision, enter 2D.
Now, when we get our collision, we want to check to make sure that it's a player that touched this.
So, we'll say if collision collider.
Now, do you remember the way to check a player? If so, go ahead and type that out right now.
If not, hold on just a second.
That's right.
We're going to do compare tag and we're going to put in parentheses and quotes player.
So, if we hit a player, then we want to call our load scene method.
And if you remember from the way that we kill players, that's in our scene manager.
We say scene manager with a capital S and a capital M dot load scene.
And here, we're not going to give it a zero or a number.
Instead, we're going to give it a name.
Let's say underscore level name.
I'll put a semicolon at the end.
Go over to level name.
Hit alt enter and generate a field for it.
Now, we need to do two things.
First, delete this extra private keyword cuz I don't want to have it there.
Not cuz we need to, but just cuz it's extra.
And then go to this private keyword up here and replace it with the serialize field attribute.
Now, I'm going to save.
Control shiftb to do a build.
And then we'll go into Unity.
The build is just to force it to save as well.
Control shiftB.
And then it pops up.
If I typo something, it gives me real quick feedback.
But we're back into Unity.
Let's go find our loadle script and attach it to this flag.
I'm going to minimize the sprite renderer, minimize the polygon collider, drag the load level script over here, and let's put in the level name level two.
I will save my scene.
press play, run over, and expect to get a nice big error in my console.
Let's see if that's the case.
So, we play, we run over, we touch this flag, and you can't see it.
It's just off screen.
But if I drag it up, there's the error.
And if I go into the console, you see that it says level two could not be loaded because it has not been added to the build settings or the asset bundle has not been loaded.
So, says we need to go add it to build settings.
So, I'm going to stop playing, go to file, go to build settings, and go, "Oh, I don't have a level two." So, I need to make a level two.
Next, I'll go into my scenes folder so I can see where I've got my level one, and think like, okay, I need a level two.
Let's uh how am I going to make a level two? Let's start by just doing this file, save as.
Go into my scenes folder.
Put in the word level space 2 because that's the way that I typed it in my loadle method or in my low-level uh component.
And then let's add the loadle 2 script.
So, or the load level 2 scene.
And now I can do that by hitting add open scenes because I now have that scene open.
Or I can drag it from here and drop it right onto my scenes to build.
Now I need to go to file and save project to make sure that my build settings gets saved and go into plastic SCM and I'll see that my editor build settings asset is updated.
I can close this window now.
Press play and when I run up to that flag, what's actually going to happen is it's going to just load me into level two when I'm already in level two.
Let's see.
So I run up and bam, it reloads level two and it reloads level two.
So let's change this up just a little bit in level two.
So, I've got level two open.
I'm going to select the flag.
I'm going to go to my project view and I'm going to expand out the sprite renderer.
I'm going to change this from flag blue to flag green one.
I'm going to drag that right up there.
And then I'm going to change the level name from level two to level one.
I'll save.
So now in level two, I have a green flag that takes me to level one.
In level one, I have a blue flag that takes me to level two.
Let's press play and see if I can go between the two levels now.
All right, we've got level two and we're in level one.
You can see it up there in the hierarchy and I can go between my two levels.
Right now, they're very similar.
They're exactly the same except for the flags.
But I've now got a very simple way to bounce back and forth and I can start adding some things to level two and thinking through my scene management setup.
Let's stop playing.
Make sure that everything is saved.
go into plastic SCM and say that we added level two and flags to get between levels and we'll check that in.
Now that we have a second level, let's begin by making it look quite a bit different.
First, we'll change out the background.
So, I'll select the background over here, the colored grass.
Let's rename this to background and then give it a new image.
We'll select click on the colored grass and I want to use the blue shroom for our background here instead.
I've swapped that out just by dragging it onto the sprite.
Now I'm going to zoom in and let's change out the ground here.
So we've got this grass center and this grass center here.
I'm going to just call these ground pieces.
So, I'm going to select both of them with control, rename them to ground by clicking up in the inspector, and then we're going to replace the grass center here with a snow center.
So, I've got grass center available or selected right now.
I'm going to go to snow and find the snow center and drag that in instead.
Now, it does say that it doesn't like that my thing isn't set to full wctck mode.
So, now I'm going to go into my snow folder, select all of them in here, control A.
Remember, if you have one expanded out, this it might give you a problem.
It's going to look like that.
So, you want to make sure that they're all collapsed and then you click and hit control A.
Once you do that, you should be able to switch this over from tight to full wrecked and hit the apply button.
Now that now that error is gone and we'll go over to the two grass mid pieces that I've got.
So, I've got that one and that one.
I'm going to replace these with snow mid.
Click snow mid and drag it up and drop it on there.
It's already looking quite a bit different, isn't it? Now, we need to make a couple other changes.
Look at our water right here.
Our water looks very strange.
It's got grass now in the background in both of those spots.
So, I want to make a change to it.
Let's click on the water, expand out the water, and find the grass background.
I want to make this into a snow background instead.
So, I'm going to click the little eyropper, click the color that's right above it.
There we go.
And now it looks like a snow background.
I'll take my water, hit the select button in my inspector so that I find my prefab.
Then I'll take my water and drag it down into the prefab section into this folder of prefabs, not on top of anything, but into the empty area and hit prefab variant.
This is going to create a new version of my water that's just a variant of the existing one where I've changed this one thing and nothing else has really changed.
I want to rename this though.
I don't like the name water variant.
I'm going to call this snow water.
So, this is water with my snow background.
And that's my snow background color.
Now, I've got my snow water existing.
I want to go over, find the other water object here, or just click on it, rightclick, choose prefab, and use that replace option.
Go find my snow water.
And look at that.
The water is looking much, much better.
All right.
Next, I want to do the same for these prefabs or these platforms up here.
Let's do grass platform 4.
I want to make this into snow platform 4.
So, the first thing I'm going to do is expand it out.
Look at all of my little uh sprites here.
I've got a grass left, a grass right, and I need to replace both of these.
So, I'll go into the snow folder with right selected.
I'll take snow right.
And it doesn't necessarily matter what the name is here.
So, I'm just going to leave it there.
And then in the base prefab, I'm going to rename these later.
So, I'm going to leave that named grass.
Right.
I'll select grass left.
Take snow left and drag that on as the sprite.
And here you can see that the two sprites are starting to show up and it's looking pretty good.
And then we'll go to the main one here, the center or the root object, grass platform 4, and take snow mid.
Look at that.
We've got a nice platform.
Let's rename this to snow platform 4.
And then we'll go to our projects prefabs folder.
take our snow platform 4, drag it down, and make this a prefab variant as well.
So now we've got snow platform 4, and it has the word variant.
I'm going to double click it, delete that out, and the extra space.
So now we just have snow platform 4.
All right.
Next, I want to challenge you to go ahead and make snowplatform five or six on your own, and then we'll go through the process and make the rest of them really quick.
So, go ahead and see how many of them you can do and then continue on and I'll run you through them all real quick.
All right, I'll assume that you're done with all of them or if you ran into any problems, let's just go through them again.
So, here's my grass platform 5.
I'm going to rename it F2.
Call this snow platform 5.
I'll replace the grass mid here with a snow mid.
And then I'm going to do the same for my right and the left.
Snow mid.
And oh, didn't click the right one.
So I'll click on that left again and grab the left.
Now I'll take my snow platform 5, drop that into my prefabs, and make that a prefab variant.
I'll remove the word variant, and do the same for number six.
So, I'll go find number six.
F2.
Rename it.
Snow platform 6.
We'll go find our sprites again.
So, I've got my snow mid.
I can also use the search box.
Why don't I do that on the next one? I'll use this one.
I'll search for snow, right? And I'll drag that over so you can see it.
So, we've got snow right.
In fact, I could even alternatively, let's do it.
Let's go for a cliff here.
So, on platform six, we're going to go with a rounded cliff edge.
And then on the left side of it, we'll go with uh let's see what else we've got here.
Snow.
Um let's go with we got an alternative cliff edge.
Let's go with that.
So our six wide one is going to look totally different than the others.
Let's go into the prefabs, drag that in, and make that another prefab variant.
So this is snow platform six.
And then the final one that I need to make is snow platform number two.
So this one doesn't have a center.
It just has the left and the right.
So I'm just going to search and I think I'll just take the normal left and the normal right.
So I'm going to click on that one.
Go select the the left side.
Drag snow left over there.
Oh, and then on this one I got the wrong one.
on the that side.
I need to have snow.
Right.
There we go.
We'll rename this to snow platform 2 and then drag that into the prefabs.
And I should have all of the prefabs that I want for my different snow platforms.
Now, let's see.
Prefab variant.
We'll remove the word variant and the extra space.
And then this platform right here is a grass platform 4.
But we can just remember rightclick and choose prefab and replace.
And we'll just choose our snow platform for.
I can't tell which one's for though.
So I'll go to list view by holding control and double click snow platform 4.
Look at that.
We now have a nice beautiful snow level to go along with our grass level.
Let's save our scene.
Go into plastic and take a look at all the files that we've changed.
So we've got all of our snow art files.
That's because we changed the modes to full wrecked.
We've got our level two and then we've got all of our new prefabs.
Just to be sure though, make sure you go to file and hit save project.
Double check that all of your prefabs are in there.
Now, let's add a comment and say that we added snow prefabs and redesigned level two to use snow graphics.
And we'll check our changes.
Now that we have an icy snow level, let's make it actually feel icy and snowy so that our character is kind of slipping around and not getting that same feeling that they're getting on the grass.
To do that, we're going to need to go modify our player script and make it a little bit aware of what it's on and maybe control the way that our character is moving a little bit more tightly.
So, we're going to open up our player script and we're going to find our movement code, which is inside of our update method.
We do our update grounding and then we read our horizontal input into this horizontal value.
I want to rename this value.
Now I think that horizontal is something that we're going to need to keep track of, but I want to use the horizontal value um not necessarily as the input or from the input, but I want to keep track of it the actual value that we're using.
So instead of having this underscore horizontal equals input.get get access horizontal.
I'm going to double click on horizontal here and I'm going to say var horizontal input.
I'm going to make a temporary variable and we're just going to keep horizontal around as its own variable.
Remember if I hit F12 on it, it's a float that exists inside of our class.
So it just kind of sits here and we can use it every frame or however we want.
But we're no longer assigning it to the input.
Now that's assigned to this horizontal input variable instead.
And now what I want to do is move our horizontal value from our current horizontal value towards the value that I actually want to be at.
So we're going to figure out a desired velocity and then use a math formula or a math calculation to go from that our current velocity to that desired one.
We're going to add in a line here on 69 and say var desired horizontal.
Did I spell it right? Yep.
Equals.
And we're going to use our horizontal input times our horizontal velocity, which is our horizontal max speed.
Actually, in fact, we're going to rename this now.
So, with horizontal velocity selected, I'm going to hit controlR or F2.
That's also a rename button.
And we're I'm going to call this max speed or let's call it max horizontal horizontal speed.
There we go.
So now we've got a max horizontal speed and our horizontal input and we've got a desired horizontal this is our desired velocity along that x and x axis.
So our desired horizontal is there and our current is right now getting multiplied by max horizontal.
That's not what we want at all.
Instead, what we want to do is assign our current horizontal value to be equal to.
So say equals and we're going to use math f.lurp.
This is a linear interpolation which is going to go from one value to another over some amount of time.
So we're going to give it our starting value which is the current horizontal value and then we'll give it a comma and the desired horizontal value as the ending value or the target value.
And then finally we'll give it an amount of time.
And for that we're going to use our time dot delta time.
And then we're going to give it some sort of acceleration value.
So, we're going to do times acceleration.
I'm going to go to the end and add a semicolon.
And then we'll generate a field for our acceleration.
So, I'll hit alt enter with acceleration selected.
Allow it to generate a field.
Hit F12, replace private with serialized field, add that square brace, and then I'm going to move this line.
And so select line 23, cut it with Ctrl X.
Go up here to line 11, hit enter, and paste.
And let's give our acceleration a default of 1.
So we've got an acceleration of one.
And now inside of our movement code, let's go find that again.
Where are you? Movement code.
We no longer do the old calculation of just multiplying our horizontal velocity and then setting our rigid body velocity to it.
Instead, we go we set our horizontal velocity to our current value lurped to some new value.
Now, let's talk a little bit about what this math f.lurp ma method is actually doing.
So, at when you call this method, you pass in a beginning value and an ending value.
Let's say we passed in a zero for horizontal and a 100 for desired horizontal.
Totally made up numbers.
Let's just imagine them for a moment.
The last value that we pass in is a percentage from 0% to 100% or how far along between those two values we want.
So if I had a zero for the horizontal and a 100 for the desired horizontal and I pass in a 0.5 or a 50% I'm going to get back a value of 50 because that's in between 0 and 100.
Now, if I had a value of say negative - 100 and positive 100 here, maybe I was going all the way to the left super fast 100 meters and and my desired is 100 meters to the right and I put in a value of 0.5.
Well, the value in between there right in the middle would be zero.
If I put in a value of one, the value that I would get back would be a positive 50.
And if I put in a value of negative one here, I would get a negative 50.
So a negative 1 or a zero sorry a zero will get you the first value.
A one here will get you the second value and a value in between 0 and one will get you some number in between the first and second value.
So this is going to slowly accelerate or decelerate us multiplied by some acceleration value.
So we have total control over it.
Let's go back into our game.
Press play and watch our acceleration on this icy level and see how it feels.
There we go.
You can see my character kind of doing that little slip there.
And if I adjust this acceleration down to like a 0.5, you'll see that they slip quite a bit more.
They'll go for quite a while.
And it takes a little while to speed up and get going the direction that you want to go.
That's the feeling that I want here.
Now, if I crank this up to like a 20, then you'll see that I've got nice snappy movement just like I had before.
I can control it exactly how I want.
Now, I want to do two little changes here.
First, I want to stop playing and I want to crank up my maximum horizontal speed.
I had it at three.
I think a five might seem a little bit better.
So, let's save.
Actually, let's go to our player script and let's change the default value of that to five as well.
So, we'll set it max horizontal speed to five.
Go back into Unity.
Play.
And I want to jump around.
Make sure that it feels good.
And then, let's figure out a number that we're going to want for when we're not on the ice.
Because right now, notice that we're slipping around no matter what surface.
We didn't do anything to check the surface.
We just made it so that our character slips around.
So, let's set it to we've got a max horizontal speed of five and right now an acceleration of one.
Let's see what that feels like.
Yeah, that's kind of kind of good and slippery.
I feel like this could go down to maybe even a 0.5 though on the ice.
Let's see.
Uh, no.
Let's go to a one.
So, one on the ice seems good.
I felt it.
It felt a little too slippery.
And then maybe let's try a 10.
Yeah, something like that.
Like a 10 or maybe even higher on non ice surfaces, I think, would be good.
I don't have a way to do that right now, though.
So, we're going to stop playing.
We're going to leave it at one.
Or let's crank it up to 10.
Actually, we'll save and then we're going to go into plastic.
And actually, let's go to our player script.
Before we do this, we'll go to our player script.
We'll change the default acceleration to be 10 as well.
And then we'll go back into plastic and we'll commit and say that we've added acceleration controls to our player.
And we're done this so that we can control it with the iciness effect or so we can add an iciness effect.
So, let's say added acceleration controls to the player and we'll check in our changes.
Let's separate out the slipperiness now so that our player only slips around on ice and not on grass.
And we're going to do that by using tags.
We're going to create our own new custom tag just like we've been using the player tag.
We'll compare against it and do some custom code based on that.
So, we're going to start by selecting our grass mid object, which is actually a snow.
Let's call this snow ground.
I think that's a better name for it.
And then let's go down and we want to change the tag right here in the tag section by going to the add tag option.
In the add tag option, we're going to get our tag and layer inspector.
Remember, we've added layers, we've added sorting layers here, and now it's time for us to add a tag.
We're going to hit the plus button and I'm going to call this snow with a capital S.
So now I've got a snow tag.
I'm going to select my snow ground and I'm going to tag this as snow.
Now let's go into our player and make our player use the snow.
Right now we have an acceleration value and I want to add a snow acceleration as well.
So I'm going to open up my player script, find my acceleration part, and then duplicate it with control or command D.
I'll add the word snow before acceleration and capitalize that A.
That way I'll get my camel case and watch what happens when I go back into the inspector.
Well, the words are going to be nicely separated.
One of the very important reasons to use proper casing.
If we don't use proper casing, our max horizontal speed would maybe not look like three words or our jump velocity and so on.
So, there we go.
We've got a snow acceleration and an acceleration.
Let's change this to be a one though instead of a 10.
I'm going to go into the code though and just change the default value in here so that I don't have to go change it in multiple levels.
We'll save off our code.
So now we've got our acceleration and our snow acceleration here.
And we're going to go down into our grounding code because when we check to see if we're on the ground and or if we are grounded or is grounded is true, we want to also check to see if we're on the snow.
So we're going to do that inside of our update grounding method.
And right now we've got some good opportunity to do what's called refactoring and separate this out.
But we're still not going to do it just yet.
We're going to add in our snow stuff.
We'll talk about that a little bit later.
So if our collider is hit, so if when we do our center check and we do our raycast downward, if we hit something and we get back a collider, this is going to be true.
And we want to do more than just set is grounded to true.
We're going to add in a brace and add a closing brace after the is grounded is true.
We'll add in one more line and we're going to add a line for on snow.
So say on snow with capital O and a capital S is equal to.
And here we're going to check that colliders tag and see if the colliders tag is the snow tag.
So we'll say hit collider compare tag just like we did with the player.
And we'll add in a parenthesis and a quotation.
Then put the word snow.
Go to the end and add a semicolon.
Now I'm going to click on on snow and we're going to generate ourselves a field.
I'll hit enter and then we're going to hit F12 to go to that field and we're going to make it public instead of private.
This is so I can see it in the inspector and that's pretty much the only reason.
We might want to view this later.
We might want to see it somewhere else.
For now though, we're just going to set it publicly and make it visible to us.
I'm going to add in another line here in between the public parameters or the public fields and the private fields here.
So, we've got a little space between our on snow and animator.
And then we're going to go back down into our code.
So when we do our grounding check, right now we're only setting on snow when we do a hit in the center um the center ray cast.
So right in the center of our body.
I want to do this for any hit that we get.
So I'm going to take lines 87 through 91 and copy them.
87 right here through 91.
Select and control C.
Then I'm going to replace my other two spots where I checked the collider.
So lines 96 and 97 where I check if hit collider then is grounded is true.
I'll just paste.
So that way I get my extra lines.
Now I could have just done the extra parts here and pasted but I took a little bit more.
So we're going to go with that.
Now I've got to do the same for 105 and 106 for my right side check.
So I'll select these two lines and again paste.
It's still on my clipboard.
And the final thing I need to do is at the top set on snow to be false.
So I'll say on snow equals false.
And you know what? I kind of want to rename this.
Instead of being on snow, I want to rename this to is on snow.
So I'm going to hit controlR and put in the word is.
And there are a couple reasons for that.
The biggest one is conventions and just cleanliness.
Is grounded is on snow.
It makes more sense.
Otherwise, it should be grounded and on snow.
If I'm going to have is for one, I should have it for both.
So now we've got our check our state here that'll tell us whether we're on the snow or not.
Let's go try that out and then we'll use it next.
So, I'm going to go into Unity.
We should have our snow platform right there.
And on our player, we should have an is on snow check box showing up right here.
Once I hit play, I expect that to get set to true when I fall onto the snow and then false as soon as I leave the snow.
Maybe I get unggrounded or I go up to another platform that's not tagged as snow yet.
So, let's check that out.
So is on snow is true.
When I jump, it's not true.
And if I jump up to this other platform that's not marked as snow, it's not true as well.
But if I change this platform, if I go select snow platform 4, change the tag to be snow, and then look at my character again, now I'm on snow.
So it is working.
It's getting that variable correctly.
Now I just need to use that for our movement.
So let's stop playing and make our final change.
We'll go back into the player and find the update method where we're moving our player around.
So right here where we set our horizontal, we use an acceleration value.
And we have two accelerations now.
We have a regular acceleration and a snow acceleration.
So let's decide which one to use one line before and then pass that in.
So on line 75, we'll add a new line here.
We'll say var acceleration equals and if we're on snow, so we'll say is on snow and we're going to use the conditional statement question mark.
We'll use the snow acceleration.
Otherwise, we'll use the default or the normal acceleration.
Now, we've got this new variable on line 75.
We'll copy it and paste it right here onto 76.
Essentially getting rid of that underscore.
Now, I don't like that these variables are named almost the same thing.
I think it's a little bit confusing.
So, we're going to rename acceleration to ground or normal acceleration.
Let's call it ground acceleration.
We'll hit control-R.
Add in the word ground right before and capitalize that a.
So, now our acceleration will either be the snow acceleration or the ground acceleration depending on whether or not we're on snow.
And we'll use that value down here in our lurp.
Let's save and watch the magic in action.
So, this bottom one should be slippery and the top one should not be because still haven't tagged it as snow yet.
Let's see if that's the case.
Start playing any second.
If I didn't hit the button twice, I do have my snow and ground acceleration values set the same on my player.
So, soon as it starts playing, I'm going to need to set that snow acceleration down to one.
There we go.
And then run around.
It's pretty slippery.
looking slippery there so far.
And if I jump and I'm in the air, it's not slippery at all.
And on this platform that's not marked as snow, it's not slippery at all either.
Got a tiny little bit of acceleration, but not not the slipperiness that I'm feeling here.
And if I put this down to a 0.5, I can see it's even slipperier.
And if I want to make it tighter on the ground, I can just crank this ground acceleration up to something like a 20 and then have super tight controls.
Now, you might be thinking, well, what about air acceleration? Definitely something we can do.
Let's stop playing, though, and go select all of our snow platforms and mark them as snow because we want them all to be marked right so that our character slips around on them.
So, we'll go find all of our prefabs, our snow platform 2 through six, and we're going to go change the tag from untagged to snow.
Now, let's go open up snow platform 4.
Go select the child objects here.
Grass right and grass left.
And look at that.
Those are not tagged.
When we set the tag, it doesn't set all of the children.
So, we need to go into each of these, select both of the children, and change the tag to be snow as well.
So, that's snow platform 4.
I'm going to open up snowplatform 5 by double clicking on it and hit save to allow that to save and modify my changes.
I'll go select these two, tag them as snow, and then I'll go open up snow platform 6.
I'm going to do the same.
Go select both of these sides and tag them as snow.
And we'll do the same for my snow platform, too, as well.
So, it's got a right and a left.
And I just want to tag both of these as snow objects or having the snow tag.
We'll hit back and save.
Now, everything in my scene should be slippery.
I can run around, slip on all of these objects, and have it work.
And then, if I go into level one, it should be a nice tight feeling.
Let's Oh, first one last thing I need to do.
I lied to you.
We're going to go back into the code and we're going to change the default values for the player.
Right now, we have the two acceleration values and they're both Oh, no.
They're not both set the same.
Okay, good.
We've got snow acceleration at one, ground at 10.
Let's go try it out.
So, I run over here.
Slippery.
Oh, no.
See, this is the problem.
My player version is set to not be on the default.
So, I'm going to stop playing, go back over here, and reset that snow acceleration back down to one.
And the reason for that is just that my default had been changed off.
So, it was no longer on the default.
I had accidentally saved with the value of 10 in there.
So, let's play again.
Got a snow acceleration of one, a ground of 10.
Should slip on level two, and be able to, you know, tightly control myself on level one.
There we go.
It's a little bit slippery.
and I hit the the flag and we've got nice tight controls.
Go back over here and it's slippery again.
All right, let's stop playing.
Save our scene.
Make sure that everything's in plastic that we added slipperyness to ice using the snow tag.
And we'll check that in.
Now, we're going to add a menu to our game.
I find that it's easiest to put a menu in relatively early so that way we can choose which level we want to be in and start to think about our players data persistence across levels because we'll already have that starting area.
So, we're going to begin by creating a new scene.
We choose file and new scene and I'm going to go with the lit 2D URP option.
We choose create and then I'm going to save this by hitting Ctrl S into our scenes folder and name it menu with a capital M.
Now that I've got my menu, I want to do a couple things.
I want to put a background in there and then put a couple buttons in there.
First, let's pull in the background.
You should be able to download that on the page below.
And then once you've got it downloaded, get it onto your clipboard.
Just right click on it and hit copy.
Let's go into the art and backgrounds folders.
I'm going to rightclick, hit show and explorer to pop up that window.
And then I'll paste it right inside this backgrounds folder.
Hit Ctrl +V.
And I should see my background appear here.
any second now.
There it is.
And then it'll jump back over to Unity and my new background is in.
So when I drop this background in, I don't want to just drag it and pop it out there because I want to do this as a UI element.
And if I do that, drop it drop it out there, it instead uses a sprite renderer and a sprite element and doesn't work with canvases and the UI stuff that I want to use.
So I'm going to delete this sprite renderer.
We're going to go to game object UI and then choose image.
Now that I've got an image here, I'm going to assign it.
So, I'll expand out this image section, the image component.
I'm going to collapse the recct transform for just a moment.
And then I'll assign the background to to this sprite of the image.
If it doesn't allow me to assign it, I can always go over to the texture, make sure that it's click on that background there, and make sure it's set to sprite 2D and UI and not default.
If it's set to default, it won't allow you to drop it in there.
Now, I'm going to go select that image again, and we want this to be bigger.
I want this to fill my entire background.
So, I'm going to go to the rec transform and we'll click right here at this anchor part where we've got the part that says middle and center.
And it's going to give us this anchor presets option.
I want to do this thing up here where it says hold shift to also set the pivot and hold alt to set the position.
So, I'm going to hold alt and shift.
And then look at what happens.
It it's telling me what it's going to do.
As I hold alt, it's telling me, hey, this is going to set the position up to the top left.
So, I can hold alt and click that and it'll move it up.
But I also want the pivot to be up at the top left.
I don't want this position to be based off the center.
I want the position to be based off the top left of this icon.
So I'm going to hold shift and mark that pivot as well.
So now I've got a 0 0 position and it's set to a width of 100 100.
That's not what I want though.
I don't want it up in the corner.
I want to fill my whole screen.
So I could do maybe this stretch one right here to stretch it.
But that just goes across the top.
You might have guessed which one is going to stretch across the full screen.
It's this bottom right one.
Hit that and it's going to stretch and take up the entire screen.
Now that we've kind of got an idea of how to stretch and set up some images, let's add a button.
We're going to add a button that's going to go up in the top left.
That's going to be a level one button.
So, I'm going to right click on the canvas, go to UI, and we're going to choose button text mesh pro.
When I click this, it's going to give me the tmp importer, and I'm going to need to click on both of these buttons.
First, the import tmp essentials, which is importing the text mesh pro or the very nice version of text for Unity into into our game.
Not every game needs it, so it's not included by default, but most games need text, so it's something that you're probably going to want to pull in nine out of 10 times.
Now that I've got the essentials in, I'm going to import the examples and extras.
Let's go to the text mesh pro folder first, though, and take a look.
If you look here, I've got documentation, fonts, resources, shaders, and sprites.
There's a little bit of stuff here.
There's not a whole lot though.
There's a couple There's one font.
If I go into the fonts and materials, and then there are a couple settings for the font.
But if I hit the import examples and extras, this is going to pull in a whole bunch of extra fonts.
Well, like five or six different fonts, and some really cool examples that show how to do some interesting different types of things with text that you can only do with Text Mesh Pro.
So, I've got those both imported, and I'm going to go over to my button.
My button right now is placed right in the center.
You can kind of see it there.
It's this boring little kind of default looking like the '9s button.
I want to make it bigger and dock it to the top left.
So, the first thing I'm going to do is adjust the width.
I'm going to make it 600 wide and make it 100 tall.
Then I'm going to change the color.
I'm going to just click the color dropper right here, the eyropper on the sprite if you or on the image.
If you don't see this, make sure you expand out the image.
So, hit the eyropper and I'm going to go with a color that looks like Oh, here.
Let's see.
Let's go.
Let's just type in the color here.
I'm going to go with a color that looks like about this.
So, put in a 7B D253 or right around here on your kind of green.
Something that looks kind of greenish.
It doesn't have to be the exact same color, but some sort of a green.
Now, I want to change the pivot of it or the lo and the location.
So, I'm going to click on the anchor tool.
Remember, hold alt and shift just like this.
Alt and shift and hit the top left.
Now, I don't want this anchored all the way to the top left.
I do want to move it over a little bit.
Have it maybe 50 pixels over and 50 pixels down.
So, grab this X position and just drag it till it looks about right.
See if the Yeah, 50 seems like a good number.
So, then I'll just type in a 50 to make it nice and round.
And do the same with the Y.
I'll just grab it and drag it down till it's looking good.
So, maybe.
Yeah, I think negative 50 seems good, too.
So, I'll just go with 50 and a 50.
Last thing I want to do to this button is make it well, not the last thing, but the next thing I want to do to this button is make the text not just say button.
Make it say level one and make it look nice and pretty.
I said that we brought in that text mesh pro thing.
We didn't actually use it yet.
It just kind of appeared and made an ugly text under here.
So, let's expand out our button.
Click the little arrow here.
And underneath it, you'll see that we've got the text tmp, which again is just short for text mesh pro.
It's because there used to be two text systems.
There was an old text that didn't look as pretty and then there's the new text mesh pro that's been around since like 2016 or 18 or something like that and it is now the default.
You should always use this, not the old one.
So, we've got our text tmp object here and it has the word button here in its text.
If I expand out the text mesh pro, if you don't see this area here, just make sure that you expand it.
You might just see the the shader down below.
So, if I expand this out, I see the word button.
I want to replace that with level one.
And then I want to replace the font.
I'm going to choose font the font asset here.
I'm if I click on it, I can see that it goes and selects it.
That's not the folder that the one that I want is in though.
So, I'm just going to hit the little search box, the little button there.
And then we'll go find the bangers font.
This looks a lot different.
But if I hit the auto size, you'll see, let's see.
Whoops.
Let's see.
Auto size.
Okay, I hit auto size, but for some reason, my auto size options are wrong.
And my max value is set to zero.
So, I'm going to set this to a 200.
That's actually never happened before where I've seen that where it popped up and had an invalid max auto size.
Didn't happen last time I did this.
So, if you do see that, just make sure that you put it up to it.
But it should say 72 by default.
So, if you see a 72 here, just change this up to something like a 200.
And we'll get a nice big font size of it looks like about a 94.
I can turn off auto size also and just kind of hardcode it at what I want.
But I like auto size because it fills it into the right spot or the right size for what I want.
Now, I'm going to change the color of this text by clicking the vertex color and just make it white.
And finally, I want to add an outline.
There are a couple ways to do this.
I can go down into the shader options here and find the uh where's outline right here? Outline option and just drag up this thickness.
But that's going to change all of the text in this bangers font to do that.
Instead, what I can do and what I want to do is use the material preset.
So, underneath the font asset, there are a couple different presets for this font.
There's a drop shadow, an outline, a glow, and a logo.
If I choose the outline one, I think that that looks pretty good.
And I've got a decent looking level one button.
So, I'm going to rename my button to be level one button.
And then I'm going to duplicate it and make a level two button.
So, I hit control D or command D.
Then I'll rename this second button from level one button one to level two button.
And I'm going to move the Y position down.
So, just drag it down.
Let's see what looks good.
Oh, about a negative 200 probably is looking about right.
And then we'll change the text here to say level two.
All right, we'll save our scene.
And before we add in any functionality, I just want to save this off and get it committed.
So go into plastic and we've added text mesh pro and we've also added a bunch of fonts.
So I'm going to make sure that everything is checked.
So say added text mesh pro and extras plus menu scene with level buttons and we'll check those changes in.
Now that we have our two buttons in our main menu scene, let's hook them up so that they actually do something.
First, let's take a look at the actual buttons.
If I click on the level one button, you'll see that I have the image where I changed the color and I can adjust that to be whatever I want.
And I can even change out the sprite, the background here to be some other sprite, make it have a different effect.
If you go download a cool UI pack, you can get a really nice looking button with borders and everything else.
Or you could change it out to be just about any icon.
I think that just using the default one looks pretty decent, though, so I'm going to stick with that for now.
Let's expand out the button component, though, because the button component is the part that does a lot of the work or is going to do the work for us.
Inside of the button, there are a couple options.
First, there's an option for whether or not this button is interactable.
If you uncheck it, you'll see that it kind of grays out and it makes it makes it essentially become unusable.
So, the button can't be interacted with or used.
I'm going to recheck that because I want both my buttons available.
You also see that you have some options for how to transition.
There's a color tint option, which does the tinting that you'll see in a second when I put it in play mode.
There's a sprite swap option which allows you to set a different sprite for when you're clicking on the button, when you're kind of hovering over it, that's the highlighted or when it's disabled.
Or there's even an animation one that'll allow you to do animations of the sprites.
The default though is color tint that has these nice little tints that kind of give you an idea of what's going on.
Let's hit play real quick and see those in action and then we'll talk about the onclick part, which is where we actually get to hook up code.
So here you can see that as I put the mouse over the color just changes a little bit.
As I hold the button down, the color changes pretty drastically.
And if I change them to be not interactable, obviously changes quite a bit.
And then it no longer is clickable or does a hover or anything.
So to use this on click part and actually have something happen when we f or when we click on one of these buttons, we're going to need to write some code.
You don't necessarily need to write code.
It is possible to do something without writing code.
I'll show you that first.
But for what we actually need to do, we're going to need to write code.
Let's start by doing something that doesn't require code though.
In this on click for the level one button, I'm going to hit the plus and we're going to take the background here, this uh image, and it's just named image right now.
I'm going to drag it into the target.
That's this part that says none object.
Then I'm going to choose the no function part and choose game object.
Meaning I'm going to run something on the game object of this image.
And we're going to choose set active which takes in a boolean parameter which is this checkbox.
True would be checked and false is not checked.
So when I click this button, it's now going to take this image and move its active property to be false or change it active property to be false.
Now I'm going to do the opposite on the level two button.
So I'm going to select the level two button, hit the plus.
We'll go take the image here.
We'll go to game object, choose set active, and I'm going to check the box.
Now, if I press play, you should be able to guess what's going to happen.
I want you to think about it for a second before you press play and before you see it.
Think about what's going to happen, but it should be pretty obvious.
We click the level one button and the background disappears.
We click level two and it reappears.
So, this is how we can hook up the buttons to do things, but now we want to hook it up to run our own code.
We don't want to turn the background on and off.
We want to just load a level.
So, we have a loadle script, and we can open that up and use that as kind of a starting point.
Our load level script is the one that's on a flag right now and it takes a level name and whenever we collide with the object, we load that level.
We want to do something similar, but we want to do it from a button.
So, we're going to create a new script.
And this time, we're going to create a new script inside of a script.
I'm going to show you the way that I create most scripts when I'm writing lots of code.
We're going to go down to the bottom of our loadle script.
Hit enter right after the braces.
You have to be outside of these braces.
and we're going to put in the word public class load level button.
Then we'll put a colon and mono behavior.
I'm going to hit enter to let that autocomplete.
Hit enter and then add in some open braces.
This is going to give me a new class inside the same file that's a loadle button.
This is our load level that's on a flag.
In fact, we'll rename it to loadle level flag in a little bit.
Don't do it yet though.
And then this will be our load level button.
So in our load level button, we're going to want to use a level name and have something that we can assign a level to for now at least.
So we'll copy line 8, Ctrl + C, go down to line 19, and paste it with Ctrl +V.
Now, I don't want to do an on collision enter in our load level button.
Instead, I want to be able to call this from some other script or essentially from our button.
Let's go take a look at that.
I want to be able to call it from our onclick listeners.
And to do that, we need to make it be something that's public on that script and then have that script be the or on the attached or the assigned object there.
Let's go back into that loadle script.
What we're going to do is make a public method public void and we're going to call this load.
Um, I think that's it.
Just load.
We'll add in open closing parenthesis and then some braces here.
And oh, I accidentally added an extra line on 22.
I'll delete that.
Inside of our load method, we're going to call scene manager.load scene level name.
So, I'm just going to copy line 13 and paste it right here on line 23.
Now, we need to do something.
So, if I save this off and I just go try to add this load level button, it's not going to let me.
Let's go take a look at that.
So, if I go over to my level one button, give it a second to finish compiling.
Probably going to give me a warning down there.
And then I minimize these components and go to add component.
Search for load level.
You notice that the loadle button option isn't there.
The reason for that is that for a component to be added to a game object, the script that it's in has to be in a file that's the main that is named the same as that script.
So load level works because it's in a file named loadle.cs.
Loadle button doesn't work because it's not in a loadle button.cs.
So, what we're going to do is with the class selected, the cursor on the class, you can just hit alt enter and then choose the move type to loadle button.cs.
There's always a move to file option in code editors and it'll just move it over, create a new file.
Let's see if we can find it.
There we go.
And then open that file up.
So, we've got our load level button, and as long as that's saved, I should be able to jump back over to Unity, see it be added right here, and then go assign it to my two buttons.
Let's see.
Once it finishes loading, I'll go select level one button.
We'll add the load level button script here.
And I'm going to put in the word level one with a space.
We'll go to level two button and drag in that script and put in the word level two.
Now, if I just press play, still not going to work because I haven't hooked up the buttons on clicks to my load level button.
So, here we are on level two button.
Let's expand out the button script and instead of on click changing the active property of the image, let's take the load level button and make that be the target.
Then we'll change the function here to be load level button load right there on the bottom.
Then we'll do the same for the level one button.
We'll just take in the script here.
Then we'll choose load level button and load.
Save our menu scene.
Press play and watch the magic of our level loading as soon as we click our buttons.
Let's go see if that works.
So, we press level one and it loads up.
Goes into level one.
Let's stop playing.
Play again.
Press level two and make sure that it goes into level two.
There we go.
It's going into level one.
It's going into level two.
I can still go back and forth between them.
And if I die right now, it's actually going to take me back to the grass level.
Let's see that.
So, I die and it goes back to the grass.
The last thing we need to do is make it go back to the main menu.
So, we'll hit file and go to build settings.
And we need to add our main menu to our build settings and make it be scene zero.
So, hit add open scenes.
Drag the menu up to the top.
And then when we do our load scene and pass in a zero, it's going to be that menu scene.
So, go to file, save project, press play.
Let's run over.
Die real quick.
Make sure that our game goes back to the main menu.
And then we can pick the level that we want to be in.
So I'm going to go over here, press level two.
Hey, I want to test level two.
Let's see how level two is working out.
And see if I hit a spike or something else.
Oh no, I died.
Okay, let's go try out level one.
All right, looks like it's working.
So I'm going to stop playing.
Make sure that we've saved everything.
Just go to file and save project.
And then we'll go into plastic SCM.
So go to plastic and we'll commit our menu with level load buttons.
So, menu works with level or load level buttons and checkin.
Now, I want to pause from the technical stuff for just a moment and show you something really cool that comes in really handy when you're building out games, especially if you don't have a full art team, and that's the AI image generation.
The background that we used in the menu scene was generated by MidJourney.
You can generate your own backgrounds that you can use as concepts or as background pieces.
and I found it to be extremely helpful.
We're going to use it for some game over scenes.
I also used it for some concept art that I had converted into actual characters that we'll be using later.
So, if you haven't tried it out yet, I recommend that you go log into MidJourney.
It's totally free.
Go to midjourney.com and you'll first want to hit join the beta, go through the process of logging in with your Discord server or sorry, with your Discord account and then you'll be able to generate images.
Once you generate images, it's free for up to 200 a month.
You can start putting them in.
You can see I've generated tons and tons of different stuff.
Everything from concepts to for different characters to logos to thumbnails and of course all of these very cool backgrounds.
I think that these things make really great just background shots.
Um nice menu scenes and transitions.
And it's very very easy to do and again totally free or cheap.
I I'm on the I was on the $10 a month plan and I think I've recently upgraded to the 30 because I just love it so much.
Let me show you really quickly how you would generate a background though.
Once you're logged into MidJourney and you're on the Discord server, what you need to do is open up the channel, open up your general one or any of these general channels and then you'll go down into the message part and start typing slash imagagine and then give it a prompt.
So, here I'm going to say a let's say concept art for a sci-fi platformer video game in space with robots and blasters.
And then we'll do a double slash or double dash AR3 col 2 to get a wider aspect ratio.
This will give me a 3x2 aspect ratio.
And it's going to generate an image.
And you're going to see a bunch of other people's images flying up and generating as it's waiting to generate mine.
You can see it still says it's waiting to start and other people's things are popping up that they've generated.
Everything from a what is this? A bird to an armadillo skydive black pen draw.
I don't know, all kinds of different stuff.
You'll see tons and tons of different things.
But you can see that my concept art is starting to appear and it's just loosely showing up.
It's going to get more and more detail.
It's at 62%.
When it gets to 100%, we should have some pretty nice detailed versions of it.
Let's see.
93.
We're almost there.
I'm already liking like this top right one.
So, once it's done, it's going to send me a new message and it'll be down here.
And then I've got a couple options.
I can see the image just by clicking on it and see these are my four different variations.
So, like, okay, I think I want to use this one.
And I kind of like this one.
Or maybe I like this for this first one because there's I I I kind of like the second one.
It's pretty cool.
It's this weird giant robot in the background.
So if I want to make a bigger version of that, I can hit YouTube and it'll upscale that one and give me a nice big wide 1080p version of it.
Or I can upscale number one.
Or if I maybe want variations of number one.
Maybe I like number one, but I want to see a couple different versions of it.
I can hit that V1 and then hit submit.
and or if you don't have it in the by default, you don't even have to hit submit.
Just hit V1 and it'll pop up.
Or I can hit this button and just generate a whole bunch of new ones.
This will actually generate me four new ones.
So, I have to scroll down to find the messages, but eventually I'll see my messages pop up here with the upscaled versions of the graphics and then the uh the new ones and the new variations.
And I start to pull these in.
Again, I think this is great for concept art, for coming up with ideas, for things to send over to artists to create.
I think I found it to be very helpful for sending over to artists on Fiverr because then I can say, "Hey, I want something that looks like this, but a character, and they don't have to come up with it and do the back and forth.
I can give them the one that's closest to what I'm thinking without having to try to translate that into words and then back into art.
I can actually give them something that I'm able to put together relatively quickly.
Here you can see I've got some more variations.
Oh, they just popped by.
That's the one thing that you'll run into is that they're constantly scrolling past.
There's so many messages in here.
Oh, yeah.
So, we've got lots of variations here.
Um, once I'm done with one though, and I really like it, I can download it either through Discord or I can go back over to the midjourney page and scroll up to the top and just hit F5 and refresh.
And after oh, two to three minutes, the graphics will start to appear on here.
and then I can download them.
So I can just click on them and then choose the save button and then download them to to my system and then import them into the game.
So I found this again to be extremely helpful.
I hope that you know it's useful for other people.
I know some concept artists really hate it, but it's nearly impossible to do the same kind of thing actually talking one-on-one back and forth trying to translate stuff if you're a solo developer and you don't actually have a team.
So, if you're a solo, small, you don't have a concept artist already, this is an amazing way to get lots of cool backgrounds or even just lots of placeholder and temporary stuff.
So, go try it out.
Pull stuff in.
Again, we'll be pulling more in, but I'll make those available for you to download just like this one, the last one was.
So, hopefully that's helpful.
Go check it out.
If you find something, come up with and make something really cool.
Um, put it in your game and let everybody know.
It's time for us to start looking at multiplayer development.
There's a lot that goes into games and if we want to build something that's multiplayer, it's important that we do it early on and that we don't try to slap it in later.
It's a whole lot harder to convert a single player game to multiplayer than it is to build multiplayer from the start.
So, we're going to start really early by adding multiplayer support.
We're going to change out our player and have our player use the new input system, which gives us some really great multiplayer capabilities out of the box.
So, we're going to start by importing the new import new input system and talking a little bit about it.
So, we're going to go to window and go to package manager and then we need to be in the Unity registry packages section and then scroll down until we find the input system.
You should be able to find it there or just search for it and then choose install.
Right now, it's on 1.4.4.
Expect there'll be lots more releases after this.
We'll hit the install button.
This should bring in the package and update our project really quickly.
And it's going to give me a popup asking me if I want to restart the Unity editor to add support for the new input system.
And I'm going to choose yes because that's a required thing to make this actually work.
We can't use the new input system until we allow Unity to restart.
So give it a second.
There it goes.
Popped up.
Do you want to restart to allow the backends? We'll choose yes and give it just a second.
Once it restarts, we'll have that new input system up and ready to go.
There it goes.
Oh, looks like it gave me a nice little crash and then it's going to reload.
This happens a lot when I bring in packages and allow Unity to restart or revert something and allow Unity to restart.
That time I had to manually reopen Unity and reopen my project, but it's okay.
Now it's up and running again.
I expect that to happen when I pull in certain packages or especially when I do reverting in source control.
It sometimes happens, doesn't happen every time, and shouldn't happen every time you pull in a package, but occasionally you're going to run into problems like that.
Just restart Unity.
All right, so I've got the new input system in, and nobody who isn't super familiar with it probably knows what that means.
That's okay.
And what it means is that we're going to have a brand new super powerful input system that allows us to do things that the current or existing input system doesn't allow us to do or at least doesn't make it easy for us to do.
The current input system is what we call a static class.
That's why we write input with a capital I.
Let's go take a quick look at it.
We write input with a capital I.get access.
That's because this is a static class with a static method on it.
That means that there's only ever one input and it has all of these methods on it that have string names for them that we can get.
So, if I want to have a player two, I'd need to have like a player two horizontal, I would need to go create that.
I would need to write the code to find a player two horizontal and I'd have to figure out how to map that all together in order to do that for every single player and every single button.
It's not there by default.
If I go into edit in my project settings and I go find the let's see go find project settings and input manager and I go look at these you'll see that there's horizontal, vertical and fire one two three but this is all just one player.
There's not stuff for another player.
The second horizontal and vertical here is just other inputs.
This is joystick versions versus keyboard versions.
We need something that's a lot more robust.
And the new input system is exactly that.
That's what it's there for.
So what we're going to do is collapse the sprite render.
I've got my player selected here in level one and we're going to add a new component.
Hit add component and we're going to search for player and look at that.
There's a player input and a player input manager script.
Now we're going to use the player input script.
That's the component that's provided to us by the input system.
And then expand it out in here.
You'll see that it has an actions field that's not assigned.
It says none a none there.
There's a button to create actions.
We'll click that in just a moment.
There's an option for the UI input module, for the camera, we'll talk about that in a moment, and for the behaviors.
First thing we need to do is choose create actions.
This is going to create what we call an action map.
We're going to give it a folder that we want to put it in.
I'll just I'm going to leave it in the default assets folder for now.
And then allow it to pop up.
So, it's going to give us this input actions dialogue window.
And this window allows us to create and do mappings.
Kind of like that ugly window you saw a minute ago with the horizontal, vertical, and fire 123 did.
But this one allows us to create multiple different action maps with multiple different actions and have them work differently across different devices.
If I expand out and move, you'll see that it works with the left stick on a gamepad WD, the primary 2D access controller on an XR controller, or the stick on a joystick.
look is going to be like your right thumb stick y and your pointer movement pointer delta.
So mouse look and the hat switch on the joystick and then fire is bound to right trigger left mouse primary touch or tap on a touchcreen trigger on a joystick or whatever the XR controllers.
You can see we've got quite a few different bindings here for different devices and it's much more um I guess clean and generic.
But the cool part that about this is that we're not going to need to have multiple action maps for multiple players.
We don't need to make a player two map or a move to action or anything like that.
We're going to be able to have a single player input with this action map hook up to multiple different players with different inputs work across keyboard and controller all kind of automatically and get split screen controls and everything as well.
So what we need to do next is well if we press play realize that nothing's going to happen.
Let's let's hit play and let's see what what it does.
We press play and we go in.
We've got our player input script and I can still move around just fine.
And that's because by default the input systems will now work together.
If you enable the new input system, the old input system can still give you back input.
You can still read the values and get the data out.
That can be disabled though.
It's an option in the player settings, but they've changed it looks like to be both of them on by default.
So, I want to now start using the actual player input here, though, instead of reading from the old input system.
So, we're going to open up our player script, and we're going to make a couple of changes.
The first thing that we need to do is get a reference to our player input in our awake method because we're going to be using it every frame.
So, right after we get our rigid body, we'll add a new line underscore player input equals get component, and we'll do of type.
So the less than player input with a capital P and a capital I and then close that out with a greater than open close parenthesis and our semicolon.
This is going to get our player input component from the same object our player's on and cach it in this player input field that doesn't exist yet.
So we'll click on it, hit alt enter and generate the field.
Should give us a field right up here by our other fields.
I'm going to delete that private keyword and add a space after it so that it's separated from our non-component fields.
So now we've got our player input.
Let's copy that onto the clipboard.
Double click it and click control C or command C.
And then let's go find the spots where we read input.
So we've got input.getaxis horizontal.
This is getting that X value of our hor or our horizontal.
So our X value of our movement.
Now if we want to read that from our new input system, we need to get it from the move action instead of the get axis.
So we're going to replace input.getax.
I'm going to just select it all and hit delete.
And then we'll paste in our player input.
And we want to first dotactions.
And then we'll do a square brace because the actions are actually an array that are indexed by name.
So we give it um well I don't know if it's actually an array.
It might be stored as a dictionary or something else underneath.
But it's some sort of a mapping that is indexed by array.
So we do actions and we put a square brace or by index and then we give it a quotation marks and the name of the action which is move.
Let's go take a look at that again.
So minimize our code.
We'll go back into that action map.
I'm going to go find our actions.
Just double click it and see that the name was move right here.
M OV with a capital M.
Now if we go back to our code, we need to go to the end of the part where we get our action.
So right now we've got our player input and we're going to reference the move action.
And so the next thing after the dot is going to be working on that move action.
So we'll hit dot and then we've got all of the properties and methods of the action or of that specifically of that move action.
And what we want to do is read a vector 2 value.
And that's because a move input is a vector 2 input.
It has an up and down or a left and right and an up and down or a horizontal and a vertical or an x and a y.
So we're going to say read value and we have to give it the type.
we have to tell it very specifically that we want a vector 2.
If we give it the wrong type, we will get an error.
So we have to make sure that this matches.
Then we'll add our open close parenthesis.
And the final thing that we need is that we don't actually care about the x and y input right here.
We just care about the horizontal or the x value.
So if we just do this right now, we leave it like this, we're going to have an error down here because desired horizontal is a vector 2, not a float.
So, we don't want this to be the vector 2 with the x and the y.
We just want to get the x and assign that to the horizontal input.
So, we'll just do ax.
Now, we could save this vector off if we want to use the y later, but right now we're not going to cuz we're not using it and it would just be extra code that would be extra confusion.
So, now we've got our move value read from the vector.
Let's go down and check the other two spots where we read our input.
I said from the vector I'm from the new input system from the player input.
So we've got our where's our inputs? So here's what I'll do.
Ah, there we go.
Just have it pop up right in front of me.
So for our fire one button or our beginning of our jump, we're going to replace the input.get button down.
Fire one all the way to there.
Do underscore player input.
And here again, we need to get the action for our fire.
So we'll do actions quote fire.
It's not fire one because we don't have a fire one.
We just have a fire action.
Let's go take one quick peek at that.
You look here, it's fire.
And we're going to add a jump action shortly after this, but we'll add a fire action.
We'll say dot performed.
Let's see this frame.
So there we go.
Was performed this frame.
There's already exists on there.
And this will tell us whether or not the fire action was performed on this frame.
So whether or not they started pressing fire during this frame.
Now, on line 74, we check to see if they're still holding the fire button down.
To determine that, we have actually a couple options.
There's an event system that allow us to know when they started and stopped pressing it.
But for now, we're just going to read the actual raw value of the fire button to see if the value is greater than zero, if the button is still being held down.
And we're going to talk about that in a moment.
Let's copy the code from player input all the way up to the end of the square brace for fire.
Ctrl + C.
And then I'm going to replace it over input.get button fire one.
So controlV.
It should look just like this.
Input player input.Actions and then square brace quotes fire with capital F and close in quotes and a square brace.
And then we'll say read value.
And we're going to read a float just like we read a vector 2 there.
We're going to read a float from our button.
And when you look at the button mapping, remember that the trigger is one of the buttons.
So buttons are actually going to return back a value between zero and one depending on how pushed down they are.
It's going to assume that every button has the capability to be dynamic or variable.
But all the buttons will work as a single button.
Even if they're just on or off, it'll just go from zero to one instantly.
So we've got our read value and we need to open close parenthesis to actually call that read value method telling it that we want to type a float.
And it still has an error here because we can't check to see if a float is true or false.
We have to make sure that this value is actually greater than something else.
So we'll check to see if the value from fire one is greater than zero and our jump time is still greater than end time.
So we can still continue jumping.
So this is just replacing our input reading to use that player input.
Let's save, get rid of the star there, and then jump over to Unity and see if it works and if our mappings are all working.
And then it's if it is, it should feel just about the same like there's not really much difference yet.
Let's see if that's the case.
In fact, there probably shouldn't really feel like any difference.
I can run left and right.
I can jump up and down.
Um, but interestingly, I can't Oh, there we go.
Now I can move on the controller once I get the controller on.
So, now I can bounce around and move on the controller or move on the uh keyboard and everything's working using the new input system.
Let's stop playing, go to plastic, and say that we've upgraded our game to use the new input system.
First, let's save our scene.
say um well, let's say switched game to use new input system and checking our changes.
Now, let's play our game.
Here I am.
I'm running around clicking and jumping and I go on to level two and a look at this.
My character can't move.
Why not? Well, let's go take a look.
Go expand out my level.
Go look at my player and oh yeah, it doesn't have that player input script.
Let's stop playing and go look at the scene.
So, if I go look at scene level two, my player does not have the new script on it because we added it in level one.
If I go back to level one, it's got that new player input script.
So, we need to get this input script onto the other player in level two.
What are our options here? Of course, we could open up level two, go copy that, and do all of the work for it.
But, I'm sure you know where we're going with this.
We've done enough prefab creation that it should have been something that's already kind of mulling around in your mind.
So, you're thinking like, "Hey, why haven't we made this into a prefab yet?" Well, now is the time.
Let's go to the prefabs folder.
I'm in level one.
I've got our player with the player input.
We'll take the player and drag them out into the prefabs folder.
We'll go into the scenes folder.
Go to level two.
Save our scene.
Make sure that level one gets saved.
Right click on our player, choose prefab, and replace.
And then we should easily be able to find our player prefab.
There he is.
And then save our scene.
Now, if I play, we should see that our character is consistent across both scenes.
Let's see if that's the case.
So, we run around and he's moving.
Yep.
Seems like he's working.
And then this one is working as well.
That's closer to what I what I should expect.
I want to have our player be reusable across multiple scenes.
and then mult well really across multiple players because we're going to be spawning a whole bunch of these in just a moment.
So let's stop playing and then go into plastic SCM.
We've created a pretty significant and important change.
It's important to just get this committed.
So say we created or let's say turned the player into a prefab and checking our changes.
Let's take a deeper look at the input action asset.
Now I've got my player selected and the player input and I'm just going to double click on the action map.
You could also go to the assets root folder and just double click on it here.
It's actually the input actions asset that has the action maps in it.
So inside of here we've got our player action map and it has our move look and fire actions and we've hooked up to move.
We've hooked up to fire.
But I really want to have a jump action as well.
I think this is a great opportunity to create a new one.
So we're going to go to the action section and choose the plus button.
It's going to allow us to create a new action.
We'll name it jump with a capital J.
And then underneath the action, we need to add some bindings.
So, by default, it's going to have this blank no binding.
And what we can do is click down here, click on it, and go to this path section and start searching.
The default key I want for jump, the thing I think of by default is space.
So, I'm going to search for the word space and then find my space on the keyboard.
I also want the X or the cross button on my PlayStation controller to be a jump button.
So, I'm going to hit plus and choose add binding.
And then I'm going to go down here and search for PlayStation and find the cross.
Now, if you have a different controller, you have an Xbox controller or something else, find a button that makes sense and bind it as your second button.
Now, once I'm done with that, I'm going to choose save.
Save the asset.
That's going to update this alien blaster input actions file.
I'll close this window and then we'll go back to our player, open up that player script, and in the spots where we looked for fire, let's look for jump instead because that's what our action should be.
So, I'll put jump there and jump right here on 65 and 74.
Minimize.
And then we'll go back into Unity.
And now I expect that instead of the right trigger being my jump and left click, it's going to be space and the X button on my controller.
So, let's hit play and see if that's the case.
I totally expect it to be, though.
So, we run around.
Oh, it's nice and slippery.
I can jump with the space key, and I should be able to, yep, jump with the X.
And the right trigger no longer does the jumping because that's doing firing for when we add in something for our player to actually fire.
So, let's stop playing and say that we've added a jump action in Plastic SCM.
added jump action and bound player to it.
And we'll check in our changes.
It's time to enable multiplayer.
To do that, we just need to add in the player input manager component and make a couple changes to our player prefab.
Let's start by creating an empty game object.
I'm going to do this in level two because it's the one that I have open.
So, I'll hit create empty.
We'll call this player input manager.
And then we'll hit the add component button.
and find the player input manager script.
I'm going to right click on the transform to just reset it so the position's all zeroed out.
It doesn't really matter, but it's a habit of mine.
And then I'm going to look at the options down here.
We have a couple things that we can choose from.
First, there's a notification behavior.
We're going to talk more about this in a little while when we start diving into the code and hooking into the code.
And same with that on the uh player or the player input script.
But we also have a joining section.
And there's a join behavior which has join players when button is pressed, when an action is triggered or manually.
When button is pressed means that as soon as I press a button on a controller that's valid, it will try to add a player for that device or that controller.
And that's what I want to happen.
I hit any button and then my new player will come in.
For the player prefab, I need to go assign the player.
So, I'm going to hit the little search box, go find my player prefab, and just assign it.
Now, there's an option here for joining enabled by default.
I want that on.
Just allows my players to hop in automatically.
And then an option to limit the number of players.
For now, I'm just going to limit it to two.
We could have any number that we want, but I'm just going to set a limit to two because um well, that's how many controllers I have set up right now.
I'm going to save my scene, press play, and let's watch our character jump into the game.
So, we should start with one character that's already there spawned.
I should be able to run around, use my space bar, and jump up and down.
And then press the X button, and have another character appear.
And this character is now bound to completely separate controls.
Notice that the camera's following him, though, and it's no longer following the other character.
It's because I've added a new one.
It's going to follow the most recent character that's been added into the game.
That's We haven't set up anything to deal with tracking multiple players yet, so it's just going to follow whatever is most recently added.
Let's stop playing though and try out one other option.
There's this enable split screen option that allow us to get a split screen view of both of our players.
If I just check that box and press play again, we should get our game starting up and I should be able to hit the X button or any button on here.
Let's see.
And get another view.
But I don't get the actual split screen.
And the reason for this, if we look down here at the errors, is it says player has no camera associated with it.
Let's click the error box so we get it in the console here.
It says the player has no camera associated with it.
Cannot set up split screen point player input camera to a camera for the player.
So what it's telling us is if we go to this player, the camera here is not assigned.
So we need to stop playing.
And what needs to happen here for our split screen setup to work is that the camera needs to be a child or associated with the player.
So, we need to have some way to associate the camera with our player.
And the easiest way to do that is to just take our main camera, drag it down to be a child of the player.
Then go to our player, hit overrides, and choose apply all.
Now, our camera will be a child of that player object, and we can assign it right here.
So, on the player input, we can take the camera and drag it in and assign it.
Then, choose overrides and hit apply.
In the last section, I worked on level two.
Let's go back to level one and make a couple of updates.
We need to make sure that our level one works and we should probably turn that player input manager into a prefab as well.
We're going to be making changes to that along the way and it should be its own prefab.
So, here I am in level one.
Let's start by just pressing play and see how things work and if there are any issues.
So, I hit play, hop on in, and start running around.
And first, I'm already noticing that my player's not being tracked.
If I jump and see that my player is not being followed by the camera.
If I hit another controller and jump in though, let's see what happens.
Oh, I get an error.
And if I look down here, it says that the player prefab must be set in order to um oh, in order to spawn new players.
So, somehow my player prefab even got cleared out here in my player input manager.
So, let's go turn this into a prefab.
Let's go into the prefabs folder.
I'm going to take the player input manager.
I'm going to drop it down into prefabs and then I'm going to go assign the player prefab in the player prefab manager or player input manager.
So, I've got the player input manager selected down here.
You can see it up here in the inspector.
And I'll just take the player and drag it onto the player prefab spot.
Now that I've got my player input manager updated, I should be able to see that the player is assigned in this one.
And if I load up level two, let's go right click on it and hit load scene.
I should be able to see that my player input manager here is not using that prefab.
And I can tell that it's not using that prefab because it's not blue.
I'm gonna right click on it, choose prefab, and hit replace, and then go find the player input manager.
There it is.
I'll double click on it, and now it's blue, and I'm going to save and get both of my scenes saved off so that I don't have that star there.
I'm going to remove level two again by right-clicking and hitting unload so that it's there.
I can access it and use it, but it's not loaded.
If I go to hit play right now, if I hit play, I'm just in level one.
I like to have both of my levels loaded sometimes and just go back and forth between them.
This is a nice little trick.
So, here we go.
I can run around and I'm still not tracked, but can I join with a new player? Yep, I can.
And this new player is tracked.
So, why is this player not being followed? Well, let's take a look at him.
Here's the player.
Or let's actually stop playing and play again so that we only have one player and see why he's not tracked.
I think it'll be a little bit more confusing if we have the second player in there.
So, here we go.
I run around and you can see that if I expand out the player, we have the camera here, but if you look down here, we still have that main camera in the route that we had from before.
This is the camera from that we drag into the player on level two, but it wasn't any part of a prefab setup.
So, in level one, we had a copy of that camera.
So, what we need to do is just delete that camera.
Then, my player will be followed and tracked around.
I did that in play mode, though.
So, I got to stop playing.
go find that main camera, delete, and then save.
Now I should be able to run around and see my player and join with another character.
Let's see if that's the case.
So, I run around.
Looks good.
I can jump and I can join in.
And everything seems to work.
Let's go over to the next level.
I go to this level and I can run around with my first character, player one.
And I can join as player two on the second controller just by hitting a button.
And everything seems to work.
So, let's go back over to level one.
Same thing.
Everything's looking good.
So, we'll stop playing.
Go to plastic and say it created a player input manager prefab.
Let's see if I can get a space in there and updated level one.
And we'll check that in.
Now that we have our multiplayer setup started, it's time to start adding some data to our players.
It's one of the most important things that you'll see in a game, keeping track of things like health, money, coins, or powerups or items.
So, we're going to build a system that allows us to keep track of all of that stuff across multiple players and then persist that, save off games, and do all of the cool things that you want to do in a regular game.
So, we're going to start by creating a coin.
I think that's one of the easiest things to comprehend and and start with and then we can build our systems on top of that and add in support for all different types of things that we want to store for our player.
So, we're going to begin by going into the items folder of our art folder.
So, we've got a subfolder items and we have three different coins here.
I'm going to choose the gold coin.
You can pick whatever color you want.
I'm going to drag mine right out here and take a peek at it.
You see that we've got a sprite renderer.
Let's see with the position.
It's at nine and 2.5.
Let's Let's change this to a solid nine exactly and a negative -2.
It's up there a little bit in the sky.
Now, I'm going to add a collider to it.
We'll start with a circle collider 2D.
And if I zoom in, you'll see that the collider is a little bit bigger than the actual coin.
It's got a radius of.5 m.
And I can drag that in to a value that looks right.
It looks like maybe about a three is good.
Oh, maybe like a 0.25.
There we go.
nice tight circle right around the sprite render.
You can just barely see it just barely matches.
All right.
Now, I want to check the is trigger box because I want this coin to not stop my play.
I don't want to have my player jump up, hit his head, and then fall down.
I want him to go right through the coin and pick the coin up.
So, I'll add the is trigger box.
And then we need to create a coin script, something to deal with the trigger enter.
So, we're going to go to the scripts folder.
I'm going to rightclick, choose create, choose C# script, and call it coin with a capital C.
I'll go select that coin.
Oh, it just opened up my code editor.
I'm going to minimize, though.
We'll go back into Unity.
I'm going to go select the coin and I want to attach the coin script to it.
So, I'm just going to drag the coin script over here.
And then I'm going to rename this to coin.
Actually, let's call it gold coin.
Maybe I'll add some other coins and use the other coins later.
We'll be a little bit more specific.
So, I've got my gold coin with the gold coin or the coin script on it.
Let's open up that coin script and then start by just deleting out our start and update methods.
In this coin script, all we want to do is deal with triggers and having our player kind of jump through us kind of like we did with spikes.
We deal on collision enter or in water we do the where's it at? On trigger enter, and we play an audio clip in the coin.
We want to disable the coin, maybe play some audio, and tell the player to get a point.
So, what we're going to do is delete out the start and update.
And we're going to add an ont trigger enter 2D.
Just start typing and find on trigger enter 2D.
Let it autocomplete by hitting enter.
And then I'm going to delete that private keyword just to get rid of it and keep things consistent.
And first check to make sure that the thing that went through us or the thing that entered our trigger was a player.
And we'll do that by trying to get the player component from the collision.
We could check the tag, but we're going to need the player component if we actually have one.
So, we may as well just try getting the component and skip the tag check.
So, we'll say if collision dot or actually I lied there.
We're not going to say that.
We're going to say var player equals collision.get component player.
And then we do our open close parenthesis.
Here's where the if statement comes in.
if player.
So, it's just is going to check to see if the player exists.
Then, we'll add our open braces on the next line.
And we want to do two things.
We want to tell the player to take a coin or to add a point.
And we'll have it do the audio playing inside of there.
The other thing we want to do is turn this game object off.
So, let's start by typing player add point.
I'll just call it add point for now.
We could call it add coin.
I think we'll start with point.
And we'll hit alt enter and generate a method for it.
That's going to create a method inside of the player class and that error should go away.
I can hit F12 to go to it.
I should see this little method here.
Then I'm gonna hit control and minus to go back.
I also have that bound to the third key on my mouse.
So I do that all the time.
I hit that button to go back.
You can go into your um options and your hotkeys and I believe it's under tools and options.
It's going to be in a different spot for every editor, but of that third button there bound to back so I can just constantly bounce back.
So we've got our add point method.
The other thing I said I wanted to do was turn this coin off.
So to do that, we call game object set active.
And look that it already knows what I want to do.
So I'll just hit tab tab and let it autocomplete.
Knows that I want to set this object to not active.
All right, let's save.
And then let's go into the add point method.
I'll hold control and click on add point.
Take me right in there.
F12 does that again as well.
So we need to not throw an exception, which is to log out an error and stop running stuff.
Instead, we want to just increase our number of coins.
So, we're going to create a variable named coins with an underscore and then increment it by one.
So, say underscore coins plus+ and a semicolon.
I'll hit home, alt enter, and generate a field.
And the other thing I want to do is replace this internal keyword with public.
Now, it doesn't necessarily matter, but I just like the consistency of keeping things public versus internal.
Now, the real technical difference technically internal was probably a better setting here or better value here, but I find that it confuses people a lot because that's another layer of protection.
And I I don't know if I really want to dive into the difference between public and internal, but the the core difference, I guess the high level difference for anybody who's curious is that a public method can be used by things outside of this library or outside of this DLL, which is something that we'll talk a little bit about later, but it's not something you really need to know too much about for a lot of game development.
Uh, and a internal method cannot be called outside of the library or outside of the DLL.
So, you can't use it across libraries if you import in a library.
Um, we don't necessarily need it to be public, but that's kind of the the default that I like to go with just so that we don't have the extra internal keyword that tends to confuse people.
Okay, so we've got our coins plus+.
And just know though that internal and public for all mo most of your use cases, it's not going to make any difference.
All right, so we've got our coins here.
Let's go take a look at it.
I'm going to hit F12, find our coins variable.
It should be right here after our other um floats because if we keep things nice and organized when we autogenerate things, they'll go into the right spot.
If you make the mess in your file and you have floats and everything defined everywhere, it's not going to know where to put them.
So, let's get rid of this private keyword.
That one we don't need.
It is very redundant.
And save.
We'll go back into Unity.
And what I want to do now is go pick up that coin and see if my score goes up.
I don't need a second player yet.
I'll just come in with my first player.
run around with the keyboard, jump up, and then go see what my coin value is.
So, I come over here, jump, get that coin.
The coin disappeared as I expect.
I'll go to the player, and then let's look at my coins value.
Collapse the sprite renderer, collapse the player input, expand out the player, and since I can't see it here, I need to go into debug mode to actually view it.
Got a couple options.
I can go up to the top here, hit the little dots, and choose debug from the drop down.
It's just off screen there.
And then I can scroll down.
I can see that coins is equal to one.
I don't generally like to do that, though.
I like to switch this back to normal.
And then right click on the player and go to the properties window.
And then have this nice properties window that I'm going to drag over here.
And then I'll set this one to be in debug mode.
So that way I have my normal inspector, but then I've got this extra window where I can see the value.
So, I can see that the coin's value right now is one.
And when I stop playing, let's hit play again.
It should go to zero.
And then when I jump up and get the coin, go back up to one.
Let's just double check that that's the case.
So, switch this to debug mode.
It was in debug mode, but it's not showing.
So, we're going to switch it out of debug mode to normal and then back to debug.
For some reason, it wasn't updating the view.
There we go.
It switched to one.
All right.
So, let's stop playing and go create this a pre prefab out of this gold coin.
So, we'll go to the prefabs folder.
I'll take the gold coin and drop it in here.
And I'm going to zoom out.
And I want to place a couple of these coins so I can pick them up with both players.
So, I'm going to select the coin and duplicate it with control D.
And hold control and just drag it up a little bit.
So, get these kind of spaced out.
Get a row of maybe four of them.
Grab this row of four.
So, I'll select the first one, hold shift, select the last one.
So, I've got all four of them selected.
Then, hit control D, and still holding control, just drag them over to kind of grid snap them.
Control D again.
Do it again.
And again, now I've got a 4x4 grid of coins.
I don't like that that my hierarchy now is getting polluted with all this extra junk, though.
It's filling up with coins.
And now all I can see is coins here.
So, I'm going to rightclick and create an empty game object.
Call this coins.
I'll reset the transform position and everything else.
Just reset on the transform.
Go select all of the coins.
Drag them onto coins.
And now I've got a nice collapsible folder of my coins.
Let's save.
And then what we're going to do is jump in with two players and make sure that the coin values are updating for both of the players and they both have their own scores.
Eventually we're going to turn these into UI elements, but we don't have those yet.
So, we're going to learn how to use the debug view.
So, I've got my player here.
I'm going to switch this to normal and back to debug.
This is player one.
Let's dock this down here on the bottom view.
Now, I'm going to rightclick or I'm going to join first with my second player.
There we go.
Then right click on that player or right click on the players player script.
So, select them, hit properties, get the second one here.
And I'm going to drag this side by side with my first player.
So, and I've got player one on the left, player two on the right.
I'm going to switch player two's view here to be in debug mode as well.
Scroll down so I can see the coins on both of them.
All right, they're both at zero.
Now, let's go run over here with player two.
Grab a couple coins and watch my coin value go up.
Look at that.
Coins two, three, four, five, six, seven, eight.
You can see player two's got some coins.
And player one's going to run over here, go grab some coins for himself.
And you can see now he's got six coins as well.
So, it is working.
We're collecting coins and we're collecting coins across both players.
So far, I think this is good.
So, we'll go into plastic.
Make sure that our scene is saved.
Everything else is saved off.
So, that we added gold coins or I'll just say added coins and checking our changes.
Now, let's add those coin sound effects so that when we pick up a coin, we get kind of a nice little feeling and some feedback outside of the data and the UI stuff that we'll eventually add.
So, here I am on Open Game Art and I've searched for coin and there's an 8bit coin sound effect pack.
Sounds pretty good.
So, I think I'll use that.
I'm going to download this pack, open it up, and copy out all of these 10 coin files.
So, I'll hit Crl + C, get them onto my clipboard, and then go into Unity.
We'll go to the project.
And actually, I'm going to go to window and layouts and go to default to just reset my layout.
Get rid of those two extra properties windows that I had.
And then I'm going to go to my audio folder, rightclick, choose show and explorer, pop up that little window, and then hit enter to go into the audio folder and paste in my coins.
Here I've copied all 10 of the coins.
I think that I've copied them and they're pasting.
There they go.
So, they should all pop up and appear in here.
We're going to start by just using one and then I'll show you how we can use multiple to add kind of that ramping up effect as we pick up more and more coins.
So, let's go select our player.
I'm going to go down in level one, find our player, and then open up the player script.
When we add a point, and our coins get it incremented, which is down at the bottom, let's for now just tell it to play a sound effect.
We'll say underscore audio source.
Remember, we have that reference to the audio source.
I'm going to go up home and just show you real quick.
We have that reference to the audio source that we get in awake.
So, we'll use that audio source down here.
And we're going to not use play like we did before.
We've used play for jumping, but we're going to use the play oneshot method.
Play oneshot allows us to pass in a specific audio clip or sound effect and just play it once.
It doesn't have to be the one that's assigned and we don't have to reassign or change the one that's assigned.
We can just call play one shot and pass it in the clip.
To do that, we need to give it a reference to an audio clip though.
And we're going to name this, let's call this coin sound effects.
And I'm going to start with an underscore because it's going to be a private serialized field.
So I'll call this underscorecoin sfx for sound effects.
And then I'll add a semicolon at the end.
Go over to the coin sfx.
Hit alt enter.
and we'll generate a field for it.
It's going to know what type because I'm passing it into play one shot which takes an audio clip.
So, it's going to know to generate an audio clip.
I can hold control and click on it or hit F12 and find it right up here.
Now, I don't like the position of this.
I want it to be up here with my serialized field.
So, I'm going to select line 29, cut it with Ctrl X, go up here and paste it right below that snow acceleration.
I'll add the serialized field attribute over the private keyword.
So, start with a square brace, serialize field, and ending square brace.
So, now I have a coin sound effect that I should be able to assign in the inspector and play whenever we pick up a coin down here with the play one shot method.
Let's go into Unity and assign that.
So, we'll go find our coin sound effect right here and let's go to the audio folder.
And I'm just going to take coin one, drag it in here.
Now, if I just do this and save, I should be able to hear my sound effect every and everything, at least on level one.
Let's go try it out.
So, I'll run over here.
Well, I got to hit play first.
Run over here.
Jump.
Oh, got to unmute so that I'm not muted.
Jump.
And I heard two coin sounds.
Let's try a second player, though.
Let's hit play.
Run over here.
Jump.
No sound effects.
So, why are there no sounds there? Okay, think about it for a little while.
I'm not going to tell you the answer yet.
Let's go to level two.
Let's run over here.
Oh, I don't have any coins on level two.
So, you can't figure it out with level two.
Think about it for just a moment on level one.
Why did player two not have any coins? See if you can figure out the reason.
And if so, fix the problem real quick.
If not, then hang on just a second and I'll show you the solution.
All right, hopefully you already figured it out and don't need my help.
But if not, or you might got a little stuck or just want some confirmation.
The problem here is that when we create our second player, let's hit play real quick.
And I'm going to spawn our player.
So, hit the button and our second player comes in and we go select this second player.
The second player's coin sound effect is not assigned.
The reason for that is because we didn't apply the change to the prefab that we made on this instance of the player.
So, if I go select the prefab, let's stop playing.
I go find my prefab here and go select it.
You'll see the prefab version doesn't have the coin sound effect.
If I go select my player, hit the overrides button though, you see there's an option to apply all.
If I click on this, let's see, I'm going to have to drag the inspector over to here.
And if I click on the overrides and then click on the player script, you'll see that I can actually see the difference right here.
The coin sound effect hasn't been applied.
So I just hit the apply button or apply all.
And now it's going to work for multiple players.
So now if I run over there with my second player or if I add some coins to level two, the players in both of those will be able to pick up and have a sound effect.
Let's go just double check that.
Sounds good.
Now I'm getting some cool sound effects on both players.
So I think it's time to save my scene.
Go into plastic.
Let's go find my plastic window.
Window and plastic SCM since I set reset to defaults.
So that we'll we've added coin sound effects and check in.
Now we're going to add some UI elements for our players so they can see their score and health without having to look at debug stuff.
And also just to make it a lot easier on us.
So you don't want to have to pull up debug windows all the time when you know you're going to want to have these on display anyway.
So let's start by creating a new canvas.
And we're going to use this canvas to show our player input or our player info for just the first player.
So we'll go game object and UI.
And we're going to start with an image which will automatically create a canvas with an image underneath it.
I'm going to dock this to the top left.
So, we'll click this set this anchor presets, alt and shift, and hit the top left there.
And then let's go to the game view so we can see it and get a good preview of what it looks like.
It's going to be right here at about a 100x 100.
That's probably a fine size for now.
I'm going to change the color of it.
The default color is uh white, and I don't particularly like that.
Let's go back to a default layout here.
I've messed up my layout just a little bit, and my inspector was too small.
So, in here, we'll go change this color to be something closer to my players color, one of these blues or something.
Go back to that game view.
Um, let's let's actually go select him just like that.
Get it exactly matching.
So, I've got this little panel up here.
And then underneath the image, I want to go add a text element.
So, we're going to rightclick and we're going to choose UI.
We're going to choose text mesh pro text.
And I'm going to call this score text.
And I'm going to set the value here in the text to be zero.
We're going to center it.
So I'm going to use the center alignment here and the center right here.
And then we're going to set the erect transform value to be a stretch.
So that it will just fill this area in with some value.
We'll change the font asset.
Instead of using that liberation sands, let's go use bangers again.
And then let's turn on auto size so it can get nice and big.
Right now it's just the coin counter.
It'll be big.
We'll shrink it down and add health and all that stuff later.
But since we only have one thing to show in there, let's make it nice and fat so we can see see it easily no matter what size our screen is.
All right, so let's go rename our image.
Now, this isn't actually going to be an image.
This is going to be a panel for our players.
We're going to bind this panel up to player one.
Then we'll make another one for player two and so on.
So, we're going to rename this from image to player panel.
And then we're going to create a script for it, a player panel script.
you might have guessed.
So, let's go into the assets folder and scripts.
Rightclick and choose create.
Create a new C# script.
Call this player panel.
Capital P's in both spots.
Again, no spaces in our script names.
Once that's created, it's going to pop up the code editor.
That's fine.
Not going to find my file.
I'll go back into Unity.
We'll go select that player panel and we're going to assign it.
Before we do anything else, we're just going to drag it on.
So drag the script onto that player panel object in the inspector so we can see it right there.
Then we'll open up that player panel.
Now player panel is going to be responsible for updating that text so that it shows our current score.
And we're going to start by doing it in a less than efficient way and then refactor it into a more event driven way shortly after.
So we're going to begin by adding in a way for our player to assign themsself to a player panel.
And we're going to use what we call a bind method.
So I'm going to take my start all the way to my update.
Delete them out.
And we're going to make a public method.
So write the word public void because it's not going to return anything.
Bind b i n d.
This is not a hard-coded keyword or anything.
It's just a very common pattern where we want to link two objects together or bind them together.
We're going to bind a player to a panel so that that player's health score and everything else shows on that specific panel.
So, we're going to add an open parenthesis and we're going to need a player to be to pass in.
And look at that.
Since it's named player panel, code's named bind, the AI is already able to determine that we probably want to pass a player in.
So, I'm going to hit tab and let it autocomplete.
We'll hit enter and add in our braces.
And we have a bind method that allows us to pass in a player.
What we're going to do here to start is just cache the player.
So, we're going to save the player into a private variable.
And we'll just use the variable name underscore player and we'll say equals player.
Add a semicolon.
We'll hit home and alt enter and generate a field.
Now, the reason for this again is so that we have this player after this method call.
So after bind is called, the player is saved off into this field that we can use later because we're going to want to use it again in our update method in just a moment.
So right down below, we're going to add an update.
I think we just deleted the update, but we're readding it and we'll remove that private keyword.
And in the update method, we want to update our text to just show the player's current core value or their current score.
We don't have a reference to our text though, so we're going to need to get our text mesh pro text.
And I know that this player panel is going to have multiple text objects.
So, I'm going to need a way to just assign one.
To do that, we'll add a serialized field attribute and then just a field for our text mesh pro text.
And to do that, we use the keyword or the class name tmp_ext.
So, that is the class name for a text object or the text component that you're seeing in Unity.
Technically, there are two sub versions of it.
There's a ui one and a um there's one for the UI and then one for worldsp space stuff, but the tmp_ext allows you to access all of the things that you need for both of those at least for setting the text and all of that stuff.
So, we have tmp_ext and we're going to call this underscore underscore score text the word score.
So, underscore and then the word score text.
This is the text object for our score.
I'm going to add an enter extra space there and then get rid of this private keyword just to clean it up.
I find that the less keywords I have in here, the the better and the easier it is to understand.
So in our update method, we'll say underscore score text, that's a very difficult one to say, do set text, which is going to change the text or what you see on the screen in that text object.
and we're going to set it to our player dot and here we need to get the current coin value.
So let's go look at our player again.
I'm going to hold controlclick on our player and right here we have our coins value and our coins value right now is private.
It can't be accessed outside of this player class.
If I go back in here, if I try to access underscorecoins and add a semicolon here, it's going to give me an error.
If I put the mouse over it, it says coins is inaccessible due to its protection level.
So I need to make this publicly accessible.
I can hit F12 and then just put the public keyword here and save and then go back and my error is actually different and it'll say that it can't convert from an int to a string.
And here it's saying, hey, set text requires a a string.
You can see the first parameter there, string source text, but you're passing in an integer.
So, we need to convert this integer to a string and we can do that with the tworing method here.
But that's not all there is because right now we've got a little bit of messy code.
Now, technically this is going to work.
Technically, there are no problems, but in a theory sense and in a keeping your code clean and keeping it so that you don't accidentally mess up in the future, there is a a big problem here in that our coins value is now accessible from anywhere and can be set from anywhere.
So that means that inside of our update method, we could actually say player_coins equals zero and our coin value would get reset to zero every frame.
Now, we probably wouldn't do that, but we might do something else accidentally with this coin value outside of our player class if we allow it.
Or somebody else on our team might go, "Oh, hey, I need to modify the player's coins and not know that we have an add coin or add points method that plays a sound effect and does all that other stuff." So, they might go bypassing that to modify our coin value and it can cause big problems and bugs in the future.
So, how do we fix that? Well, first we'll just crl x and get rid of that line.
And we're going to hit F12 and go to the coins field here.
And what we can do is turn this from a field into a property.
And we make it into a property that can only be set from this player class.
So we're going to add an extra space here.
And we're going to add after the word coins and going to delete that semicolon.
We'll add an open parenthesis.
And then we'll put look at that.
It's already trying to autocomplete.
get and a semicolon which means that the get part of the public value is now or the get part of coins is now public.
So reading it is now public.
Get is to read a value.
But the set value we want to make private.
So here you can see it's already recommending we do private set.
I'll just hit tab and let it autocomplete.
So now coins can only be set from inside of player, but it can be read from anywhere.
Let's save this off.
Go back over to that player panel and just rewrite that code.
So I do underscoreplayer.co_coins equals zero.
You'll see that now we have an error saying that it cannot be used in this context because the set accessor is inaccessible, meaning that the set is private and we can't get to it.
That's almost perfect.
I'm going to remove that line.
The last thing I'm going to do is rename this because since it's no longer a private field, it shouldn't have that underscore.
At least not by my naming conventions.
Go with whatever your company or whatever uses.
But if I use my naming conventions, public properties do not have an underscore.
That's only for private fields.
So I'll hit controlr control.
Get rid of the underscore and capitalize the C and go back to a Pascal case.
I'll save that off.
We'll do a build real quick.
And then we're going to jump into Unity, assign our text to the score text object, press play, and absolutely nothing's going to happen.
Why is that? because our player still isn't binding to the panel.
So, the last thing we're going to do is go into our player and just do a quick binding in our player before we set up a system for multiple players to bind to multiple panels.
We'll go right into the player script and inside of our awake, we're just going to do a quick and dirty find object of type and we'll give it the type player panel.
So, this is going to find the first player panel in the scene.
and it's going to search through all of our active scene and find a player panel.
And then we'll get our parenthesis in there.
And we want to say bind.
And here it takes in a player.
And we're on a player.
So we can use the keyword this to just pass in this current instance of the player.
Add a semicolon.
And I'm going to add an extra line here just to clarify and make this a little bit cleaner.
We'll save it off.
Jump back into Unity.
And I should now see that my player is bound up to that.
And as I grab some coins, the value goes up.
Let's let's go check that out.
And then when I come in on a second player, I expect them to bind over it and kind of take control of that panel because they haven't set up code to deal with multiple players in multiple panels.
We only have one panel right now.
So here we go.
We jump.
Coins are going up.
Looking good.
And if I come in here on another player, look at that.
It went to a zero.
And I jump.
And now coins are going up.
and the other character or other other player no longer affects that because he's no longer the one bound to it.
And if I go look at my player panel and go set this into debug mode, you can actually see in here the player that's bound.
You can see it's this player.
I can click on it and you can actually see that it's this specific player, which was our second one, not the first player.
Pretty cool, right? So, let's stop playing, go into plastic, and commit our changes.
So, I'm going to save our scene.
And here we'll say that we created the player panel in level one and found it to the first or most recent player.
And we'll check that change in.
Now, we're going to extend our UI and make it work for two players.
Of course, you can go on to four players or however many we want, but I think that two is a good point to get to.
So, we've got our canvas here.
Let's add in a new script.
We're going to add in a player canvas script that will allow us to bind multiple players to our player panels.
So, we're going to go to the scripts folder.
I'll rightclick and just choose create and choose C# script.
Put in the word player canvas.
Capital P, capital C, and no spaces again.
We'll open that script up.
And that didn't open.
There it goes.
Now it's open.
And inside of our player canvas, I want to have a way to have multiple player panels so that we can assign all of the player panels that are children to it and then have our players just try to bind to the player canvas and it'll know which player panel to give them.
So to do that, we're going to first delete our start and updates.
Something I almost always will end up doing.
We're going to add a serialized field.
And the serialized field is going to be of type player panel, but it's going to be an array of them.
So to make it an array, we're going to use the square braces.
That means that we can have multiple, any number of them really, and then we can go through or iterate through them or find them by index.
And we're going to call this underscore player panels.
Now, we're going to create a bind method.
So let's go look at our player panel.
Inside of our player Oh, there it is.
Our player panel, we have a bind method that takes a player.
We're going to take this definition right here, public void bind, and copy it.
I'm going to go right into player canvas, and paste.
We're going to have a public void bind that binds to a player right inside of here.
And what we want to do now is find the correct player panel and bind to that panel.
And we've got a couple of ways that we could do it.
We could maybe keep track of the last player panel that was bound up and then maybe store that in some variable or something.
Um, we could maybe put them into some list or some collection of them.
There lots of different weird ways that we could do it, but we're going to go with what I think is the smartest and simplest way.
We're going to get the player index from the players input play the player input script on the player and then we'll just get the player panel that matches at that index.
Check this out.
So, first thing we want to do is get the player input.
So, we'll say var player input equals player.get component and we'll get the player input.
Then we'll get the index from the player input.
say player input dot whoops player input dot player index.
So we've got this value and this is going to be either zero for the first player, one for the second player, two for the third player, three for the fourth player.
Essentially it's going to be a number starting with zero for the first player and counting up.
So we want to get the player panel at that index and then bind our player to it.
So we have this index and to get the player panel at that index, we just take player panels.
We'll put it right here at the front underscore player panels and add a square brace around this player input player index.
So we'll either get number zero or number one or whatever number.
And then we will bind to that number.
So call the bind method and pass in our player.
We'll save this off.
Let's go into Unity and see what these indexes look like on the player panels and go assign them real quick.
Might make a little bit more sense if you're a little bit confused.
So, we'll jump back into Unity.
Go to this canvas.
Let's rename it to be player canvas so that it matches the name of our script.
We'll assign the player canvas script to it.
I'm going to collapse these other components here.
And then we've got our player panels on our player panel.
So, we'll just drag the first player panel on, drop it on, and you can see this is element zero.
So, this is at index zero.
Now, we don't have a second player panel.
So, we're going to need to create one.
To do that, we'll select our player panel, hit control or command D to duplicate it, and then expand out that rect transform that I just collapsed.
There we go.
We want to anchor and dock this to the top right.
So, I'll click on the anchor control, alt, and shift, and hit the top right.
And there we go.
I've got one up at the top right.
This will be player panel 2.
I'm just going to rename it.
And then let's rename the first one to be player panel one, just so that we have nice, clean names and we can see them when we're in our canvas.
Let's go back to the canvas.
We'll drag player panel two on.
And you see that that has an element of one.
So player index one is going to get assigned to that.
Let's save.
Press play.
And now when we go into Unity, we should see, let's see.
Well, first we're going to see some errors in the console.
But let's run over here, grab a couple coins.
And you can see that I've got some points on one of my players.
Let's go grab some coins on the other one.
And you can see that uh well that's interesting.
Oh, I've got coins on the other player.
Now, the reason for this is that inside of my player script.
Oh, let's go take a look inside of my player script.
When we call the bind method, we didn't actually call into the new player canvases bind.
We're still just binding the player panel.
So, we'll change player panel to be player canvas and save.
And that should fix our binding issue so that both players get their own canvas.
Let's check that out.
and then we'll check out the error message that's in the console.
So, we'll press play.
Now, I expect the first player to be bound to the left one and the second player to be bound to the right one.
So, come over here, get a couple coins.
Looks good.
And I come over on player two, grab some coins, and it's looking pretty good.
Things are looking solid.
So, this is good, but we do have an error here.
The error's gone away, though.
You can see that it was logging out an If I uncheck this collapse, there's a whole bunch of them.
I have 347 of that error specifically.
If you don't see them, just make sure that the error is not disabled.
You can disable and enable them right here.
I've reenabled it, and you can see them right here.
So, why did it stop? And what was causing it? Let's stop playing and play one more time.
And look at the errors.
They just keep going and going and going and going.
Watch what happens when I join with player two.
The errors go away.
Now, let's take a look at what this error message is saying.
I'm going to hit collapse, and you see that they're all the same error message, meaning that it's the same thing happening every single frame happened 994 times.
Let's go double click on it.
We can see it's in player panel.cs on line 19.
An object is not set to an instance of an object.
So, we're trying to use something that doesn't exist.
We'll double click on it.
And if you look here on line 19, the thing that doesn't exist is probably the player because we haven't assigned or bound a player to this object yet, but we're still trying to update it.
So imagine we've got our second player panel there.
Our first one's got player one already kind of assigned automatically and instantly, but player two isn't assigned until they come in.
But every frame until they come in, we're trying to use that player and read a coin value.
But there's no player assigned.
So we need to add in a check here on line 19.
We'll copy the word player underscore player, add in a new line.
We'll say if player, and then add the closing brace, and then add in a tab here just to clean up our formatting.
So now it's only going to do this code if we actually have a player bound.
If we haven't bound a player yet, we won't see that code running.
We won't get the error.
Let's try it out.
We'll press play.
And look at that.
No more error.
All right, let's stop playing and go into plastic SEM.
Actually, before we do that, let's turn this into a prefab.
Let's take our player canvas, go into our prefabs folder, drag it in.
So, we now have a player canvas prefab.
And then, let's load up level two.
So, I'm going to hit load scene.
We'll drag our player canvas into there as well.
So, we have a player canvas in both of our levels.
So, that way our game is going to work across levels.
We don't have to worry about it yet.
We're going to talk more about how to deal with this across a whole bunch of levels later, but for now, we're just going to make sure that it's in both of them.
save so that both of our levels are saved.
Remember, if you don't know how to get both of these levels out here, let me just show you one more time.
So, if you double clicked on a level and it just opened one, you can just click and drag and add another level there.
You just don't want to have them both loaded when you play.
Just make sure that you hit unload to unload the scene that you don't want to play.
Or you can always rightclick and hit remove to unload it completely and just get it out of there.
Let's go into plastic now and say that we've added multiple player player canvases or that yeah, we added the player canvas.
Added player canvas and support for UI on multiple players and we'll check that in.
In this section, we're going to learn about data persistence and data management because it's something that a lot of people really struggle with when it comes to game development.
And that's partially because it's just so easy to save data off in any way that you want.
It's really easy for us to add data to just about any type of object when we're writing code in C.
Like you saw with our coins, we added a data for coins onto our player just by adding a coins field.
Remember, let's go open up our player and take a quick peek at it.
We just added this coins.
Technically, it's a property with a backing field, but we added this coins property, and we just keep track of how many coins our player has right there on the player object.
And it seemed like it kind of worked.
But you probably noticed that when we actually start playing and go from level to level and stuff like that, that our data is getting reset.
Let's go check it out real quick and talk a lot more about this and then we'll go into some really interesting solutions.
So here I can come over, pick up some coins, go to my next level, and my coins are back to zero.
And if I go back to level one, my coins are still at zero.
Go pick up coins, and my coins get their values again.
So the reason this happens is pretty simple.
It's because this player object with the number of coins that we have, let's go expand out our debug mode here and take a look at it.
our player with the number of coins, which is right now set to six.
And if I jump up, it'll be a seven.
That player object is going to be destroyed, and a new one will be created when I go into level two.
Let's go take a look.
Go into level two.
And well, we've got a totally different player object.
In fact, I can make this even more obvious by going to my level two.
Let's go into scenes.
Go to level two.
And I could do something different to this player, like maybe change his default color.
Or let's go out of debug mode into normal mode.
And I'll just make him like a 50% larger.
So on level two, we've got a big fat tall player.
And on level one, we have a smaller well smaller scale down normal scale.
So here's my level two version of the character and the level one version.
So got two separate objects.
It's not the actual same object being recre or being reused even though it shares a prefab.
It's actually two separate instances of that object.
So, what we need to do is get our data to persist across different versions of our character.
Let's reset this back to a one and a one.
And uh I'll leave the position there.
And we'll talk a little bit about what what our options are here.
We first we could just maybe keep a player around and keep a player object that we keep from scene to scene and just move them around.
But you're going to notice that that'll cause some issues as your game gets bigger.
If you got something small and you've just got one player object, it's not too difficult to keep them around and keep them from scene to scene as you load in.
Maybe using something like the don't destroy onload method, which will keep an object around even when you load into a new scene.
But I found that in general there's a better way to do it.
And the easier way to manage data and the easier way to make it so that you can keep building on your project later, do things like saving and loading, having multiple players and all that, is to separate that data off of your player or separate it off of the objects that care about it into a system that can just persist that data.
give you back a player or do all of the things that you might want to do in a nice clean way that doesn't kind of bloat and make your player script get nice and big or cause other issues along the way.
So, let's start by opening up our player script.
And the first thing that we're going to do is create a new player data object.
We're going to create a new class that will store data for our player and store this coin info there and then kind of wrap that or hide it.
We're going to do this in a way that seems like it's not changing anything at all.
And then we're going to do a little switch and you'll see the magic kind of appear.
So, let's start by creating a new class.
Um, let's do this down at the bottom of our player script.
And we're going to put in a value for coins and we'll add in a value for health as well.
So go down to the bottom with control and end.
Go down and just start typing.
We'll put public class player data.
Inside of it, we're going to put a public int coins not in coins and a public int health.
So now I've got a public class player data with a coins and a health value.
I'm going to copy the word player data.
Go all the way up to the top of our class.
And right here, um, right above our coins, actually, we'll put a private or we won't need to put the word there.
We'll just put player data data player data.
And let's initialize it to be have a new value at start.
So, we'll say equals new player data.
This will give us a brand new blank player data with a zero for the coins and a zero for the health.
Now, when we access our coins, instead of just directly accessing this integer, let's modify the coins on our player data object.
To do that, we've got a couple options.
I could write this out as a big U property, or I can use my expression body property syntax to simplify things down.
And after the get, instead of having it be automatic, we'll add a lambda statement.
So, that's an equals and a greater than.
and we're gonna have it get back or return back the player data's coins.
So to do that, we do underscoreplayer data coins.
So now this coins value whenever we read it, it's actually going to read from player data and it's going to read its coins value.
Kind of confusing if you're not sure what we're doing yet, but don't worry, it's going to make a lot more sense really soon because we're going to split this player data off so that it's not just part of the player.
We can see it other places and rebind it and stuff.
So we've got our get method.
But what if we want to set it? Well, for the set, we need to add a lambda statement as well.
We do the equals and greater, which means that when we want to set, we just want it to run the code after this lambda statement.
That's all this is doing here.
When we read this, when we read the coins value, it's saying, hey, when you try to read this, just return back out this value instead.
That's what this weird little get syntax does.
This private set means that only set it from inside this class.
And when you call set, you say coins equals something.
Then instead, technically underneath do this code, which is going to be player data.coins equals.
And here we use the special magic keyword value, which is the one that's being passed in here.
You can see that it's blue because it's a kind of a keyword or a special word.
So this has now wrapped my coins data in this player data.
Let's save, minimize our code editor, and then go back into Unity.
and we should expect to see exactly the same behavior.
That's what we're looking for right now.
And then in the next section, we're going to figure out how we can split that off and have that player data persist even when our player doesn't persist.
So, let's see.
We play.
Run over here.
I've got zero coins.
Yeah.
Yeah.
Yeah.
Run over here.
Jump up.
Get some coins.
Go into the next level.
No coins again.
Go back over here.
And got my coins again.
All right.
So, we're going to stop playing and we're going to commit this to plastic again.
We should have exactly the same functionality.
We've just added a player data layer.
We haven't actually taken advantage of it.
So, we're going to say that we added player data layer to the player, but didn't hook it up completely yet.
And we'll check those changes in.
Now, we're going to go back into level one and start to set up our game management and data persistence system.
To do that, we're going to create a new script.
And this script is going to be our game manager.
And the game manager is going to be responsible for a few things, but the key thing it's going to do is bind our players data to the player.
And then we can bind other things up later.
Let's start by going to the scripts folder.
And we're going to create a new script, a new C# script called game manager with a capital G and a capital M.
And we'll even get that special little logo or icon on it.
Let's see.
We should get the little gear icon that appears because game manager class name is associated with a little gear.
It's just kind of a a built-in thing.
And you can actually go into these icons.
So, if I select a class, you can actually go in and select the icon, go search for an icon, pick whatever you want, or change the specific one there.
Game manager just happens to have a gear assigned to it by default by the name.
That's because most games are going to have a game manager and they just I think thought, hey, why not give that one a cool icon? All right, let's go to the player input manager component now or game object.
So, in level one, we've got a player input manager that has our player input manager component on it.
And we only need one of these in our game, and we only need one game manager in our game.
Well, two things.
So, what I like to do here is combine these into a single object.
So, I'm going to take my game manager script, drag it onto the player input manager, and then apply the override.
So, go to overrides, and hit apply all so that it gets applied to the prefab.
Then, I'm going to rename this to player input manager and game manager.
And then hit, let's see.
No, there's nothing to apply now.
I just wanted to update that.
But I do want to copy the name here.
And then go select the prefab and rename the prefab as well, just so that its name matches.
And to do that, just select it, hit F2, and then paste in the new name.
So now it's got a new name here.
I should see in plastic SCM that it's got it as moved, which just means that I renamed the file.
So if you rename a file in source control, you're generally going to see that as a move.
Some source control systems will show it as a rename.
A lot of the time though, you'll just see it as a move.
So we've got a moved item here.
We've got our new changed item, which is kind of changed and moved.
And we have our game manager.cs script.
Let's go modify that script now.
So, I'm going to go to my player input and game manager and open up the game manager script.
The game manager script's got a start and an update.
And I'm going to delete both of those out of here.
The first thing that I want to do with my game manager is just make it be a singleton.
I want it to be an object that's going to be only one instance.
So, there's only ever going to be one game manager around.
And I want to make sure that if there is a game manager in a scene and I load into another scene, I don't end up with two game managers.
So let's write the code to do that.
Now, we're going to add an awake method.
And the first thing that we're going to do is set our instance to this object.
So we'll say instance equals this.
Now we'll generate that property.
So I'll hit alt enter with instance selected and create generate property or click generate property.
We should get a public game manager instance with a public getter and a private setter.
What this is going to do is allow us to keep track of whether or not our game manager has already been spawned.
We'll do that by checking to see if the instance is already set.
But to do that, we're also going to need to add in the static keyword here before game manager.
And that's so that every game manager that spawns, if we have a game manager in level 1, 2, 3, 4, 5, 10, and so on, all of them will always share this same instance.
So if a game object the game manager gets destroyed and a new game manager comes up, well this instance would be here.
It' be kind of a problem.
Not exactly what we want.
But if we spawn multiple game managers, like we go from level one and it has a game manager to level two and it has a game manager, then we're going to know that this has already been set by level one's game manager.
So we can add a line here before the instance equals this and say if instance is not equal to null.
So if it has been set, then what we want to do instead is just destroy this new game manager.
So we'll say destroy game object and then return.
So now we've got an object that should only allow us to have one of and it will well right now it won't persist across levels.
So we need to add in one more line of code down here on line 17 and say don't destroy onload.
There we go.
I spelled it right.
And we'll pass in our game object.
Let's save.
Go set this up in Unity and see what it does and how it feels before we dive into how we're going to bind the player data up to it.
So, we've got our game manager here.
It's assigned.
And if I save my scene and just press play, I should see that it moves now down into the don't destroy unload section.
And that's because we've added that don't destroy unload.
So, I've got it right here right next to my debug updater.
So, I've got my player input manager and my game manager here.
And if I go over to the flag or here, let's go grab some coins first.
Go grab the flag, you'll see that I still have my game manager, my player input manager.
My inspector did not clear out.
That's because this object is the same exact object and it's still selected.
Go down here.
I can see I don't have a game manager and player manager cuz they got destroyed.
And if I go into level one, that's the ones that were placed in level two.
If I go back to level one, the ones that were placed there got destroyed.
And the one that I already had from before is still around.
So now I've got an object that persists across multiple levels and I need to use that object in my singleton my game manager here to keep track of this data and start to bind it up to players so that we can have our player continue their game across multiple levels.
So first though let's go into plastic and commit our change because we've added a singleton game manager and we need to have that in here before we start hooking up player data to it.
So, we'll go in and save our scene, make sure everything is saved and updated, and then check in our changes.
Now, let's take a look at our game manager and our player input manager.
What we want to do is have our game manager know whenever there's a player added and then have it hook up or bind up data to that player.
And we're going to do that by calling or tying into the player input managers on player joined event.
So, we're going to start by opening up the game manager.
And in the part where we do our awake, where we set our instance, we've already got our player game or our player input manager right here on this object.
We're just going to need to get a reference to it.
We'll get a reference to it and then register for an event that will fire off whenever our a player joins.
So, to do that, we're going to open up our game manager.
We're going to say get component and we want to get that player input manager and we'll have open close parenthesis and then we want to register for an event on it.
So we can do that by either saving off this player input manager to a variable and then referencing it that way or I can just put the dot right after and search for the event that I want.
Now if you look down here at the bottom you'll see that there are actually a couple different options that allow me to filter things.
If I click the lightning bolt, it'll actually show me all of the events.
Or at least it's supposed to.
I don't know why it's not showing me all of the events.
There we go.
I clicked it twice and now it showed up.
So, we've got an onplayer joined and an on player left.
These are things that will get fired off or called or we can tell it to do something essentially when this event happens or when this thing happens.
So, when a player joins, we want to run some code.
So, I'm going to just double click on it and hit plus equals, which is going to add a method to be called after or whenever a player joins.
So, do plus equals.
And then we need to give it a method name.
I can hit tab to get a game manager on player joined.
But I'm just going to type in the name of the method that I like instead, which is going to be handle player joined.
I'll add a semicolon.
Hit the left arrow once so that my cursor is on handle player joined.
Hit alt enter.
and then we'll generate a method for it.
So what's going to happen is every time a player joins with this player input manager, which remember is going to be the same one because it's on this game object that we're not destroying.
It's on the singleton that we're keeping around.
So whenever a player joins, we're going to call our own special code handle player joined and it will give us the player input of the player that joins in a variable named OBJ, which I don't like.
So I'm going to rename that to player input.
and then it's going to throw an exception which is not very handy.
So let's start by just logging out a debug log so we can make sure that all of this is kind of making sense that we're getting an event when a player joins.
We can see it and we can maybe do something with it afterwards.
So we'll start by writing the code debug.log and we'll add in some open parenthesis.
And here I'm just going to write handle player joined and then let's add in a space a plus and we'll put in player input.
two string so that way I can see the the name of the player or whatever some input about the player.
We'll put a semicolon and I said some input but really some data about that player input is what I mean.
So we'll save that off.
I've got my semicolon at the end.
We don't necessarily need the two string by the way.
We can delete that and it'll do the exact same thing because what happens is when you combine a string with another object, it automatically implicitly calls to string on that object which just converts it to a string.
All right, let's save.
And we'll talk more about overwriting that and some cool things you can do with that later.
Let's save though.
Get rid of the star.
And oh, first let's go get rid of these private keywords that I don't like to have.
Those two right there in front of the methods.
Remember, we do need it here because we don't want other things setting this game manager instance.
All right.
Now that I've saved that, I'll go into Unity.
And we're going to open up the console window here.
Make sure that it's cleared and press play.
Now, I expect we'll see our player here.
So, we we're in I'm in and nothing happened.
If I go over to the next level, you'll see that nothing happens.
I'm not getting these player joined events.
And the reason for that is actually right here.
It's this notification behavior on the player input manager.
By default, it's set up to use the um kind of old send me.
I call it old, but it's this older default send message system in Unity, which would call events or it would call methods by their name kind of magically.
And when I say that, I mean that there's no hookup in the code.
The hookup was all done kind of right here.
Here you can see it will send messages to the game object on player joined and on player left.
Which means that if I had a method in there named on player joined with the right player structure.
So with a player input parameter and an on player left with a player input parameter, it would call those.
But it won't call the things that I've registered for like on player joined.
These are C events and by default they're not on.
What we need to do instead is change this notification behavior to invoke C events.
Now, if I change my level, you'll see that I got the notification down here that a player joined when I went into a level.
And if I go back to the other level, I'll get another notification.
Now, if I stop playing, that's going to reset.
So, I need to make sure that I stop playing, switch it over to invoke C# events, go to overrides, and apply all so that it gets applied to my prefab.
I can select the prefab, and it should show just like this that I've got invoke C# events.
Now, if I press play, it should clear my log.
Or maybe it's just going to add on and I'll get a third and fourth entry depending.
Okay, that's clearing.
I get get my entry and you can see that every time I join I get a player joined message or every time I enter I get a player joined.
All right, let's stop playing and we're going to do well our final bit of code here.
We're going to hook up our player manager or our game manager to our player data.
To make that happen, we'll add a new line right here after our debug.
And we'll say player data.
Player data equals get player data.
And we'll pass in player input dot player index.
So, we're going to create a method that will give us back the player data for a specific player based on their index or their number.
Remember, zero is going to be the first player, one will be the second, and so on.
So, I hit alt enter, and we'll generate a method for that.
We'll figure out how to get that player data in just a moment.
For now though, what do we want to do once we have the player data? Well, I want to get our player object and tell them to use this player data.
So, we'll say player input.get component and we'll get the player object.
And then let's save this off.
Actually, let's say var or let's say player player equals and we'll get that component just so we can make this a little bit more explicit and a little bit more obvious what we're doing.
So, we're getting our player data from this method.
We haven't figured out how yet.
And we're getting our player by calling get component.
Remember, our player input is on the same object as our player script.
Let's just go take a real quick peek at that just so that it makes sense.
We got our player here and our player input there.
All right, let's go back into that game manager script.
Game manager.
And then in here, let's bind our player to the player data.
So, we'll say player.bind bind player data.
Now, this method does not exist, but it is a very common syntax that you're going to see throughout this course and throughout game development and all programming in general.
We want to bind up this player data to this player, which essentially means that we want to associate them together so they're they're linked together.
We're going to hit alt enter and generate a method for bind.
And then we're going to hit F12 and go into it.
Now, our bind method doesn't have to be complicated.
It just needs to set our local player data object to be this player data.
So, we'll say underscore player data equals player data and save.
I'm going to go back, go into our game manager.
The final thing we need to do is determine how to get a player data.
So, what we'll do for that is store off some list of player datas.
And if we don't have one for the current player, we'll just make a new one.
So, let's create a list.
I've deleted out my throw statement, but let's make a list down here at the bottom.
make a list of player data and we'll call this underscore player datas and let's initialize it.
I'll just hit tab so that by default it's a new list and it's not a null list.
We don't want it to be null.
We want it to exist.
So we've got a list of player datas and then in our get player data method we'll check to see if we have one for our player index.
So we'll say if player datasc count is greater than our player index.
So we have some left or let's let's say that we don't have any left.
Let's say that our count is less than or equal to our player index.
And we'll talk this through in just a second.
So if our player data's count is less than our player index, we want to make a new one and add it to the list.
So let's do that and then talk through the code.
We'll say var player data equals new player data data data and then player datas add and we'll add in that player data.
Just hit tab and it autocompleted for me.
Final thing that we want to do is return player datas at player index.
There we go.
It's autocompleting.
So let's talk this through.
On line 34, if we have no player datas in our list at all, count is zero, which is equal to our first player, which is index zero.
So, it's less than or equal.
It's it's equal.
So, it will get a true statement here, and we'll create a new player data, and it'll get added to this player data list.
If we call it again though, say we go to level two, and we try to get player data for index zero, well, then player datas is going to have a value in it.
So this will be false and we'll just return back the player data at index zero cuz that's the first player.
So we'll get back the first player data if we add it put in a one here.
So we get the second player then we would go against count of one and we would say hey um we actually are equal to one.
So our player index is equal to the count.
We've got one player here.
Second player comes in with an index of one.
We create a new one and so on.
So, let's save and let's go into Unity and see what this magic does for us.
So, we'll press play.
We should be able to run over, grab some coins, watch our coin count go up, go to the next level.
We still have eight coins.
Let's go back to level one.
Go grab some more.
And look at that.
Our coin count is persisting across levels because it's now being saved in our game manager.
Let's go into the plastic and commit our changes.
And then we're going to add a little bit of debug stuff so we can see it slightly better.
So we'll save and we'll say that we've added player data to the game manager and hooked up bindings.
And we're checking our changes.
One of the few things we can't do right now is see our data outside of the UI.
There's no easy way to go in and view what we've got right now.
So, if I go into debug mode and look at my game manager, you'll see that I don't actually see my player data there.
Even if I press play, it's not going to just magically appear.
And I'm I'm not able to easily debug it because of that.
If something's going on with my coins and I want to see what the values are at, let's go find this thing again.
I can't really see anything there.
So, what I need to do is make two little changes to the player data class.
Well, one change to the class and one change to the reference or the use of it.
So, let's stop playing.
I'm going to go into the game manager.
And the first thing I want to do is just add a serialized field attribute here.
So, we're going to serialize out the player datas.
And this is just so that I can see them in the inspector temporarily.
So, we'll save that off.
And then let's go look at the inspector and see what it shows now.
So if we go find our game manager, got to make sure I select the actual game manager.
See that it still doesn't show up.
And that's not a bug.
That's not something wrong here with what I've done.
It's actually a side effect of my class not being serializable.
So what we're going to do next is go to the player data class.
I'll just hit F12.
And right at the top of the class, we need to add the serializable attribute.
Let's see if I can spell that right.
I can't.
So I'll just let it autocomplete.
So it'll add the serializable attribute which of course needs the using system name space.
So if I move this player data into its own file which I'm going to do right now, alt enter and hit move to file.
You'll see that inside of my player data class or script.
Let's go find it.
Here it is.
We have using system.
We've got the serializable attribute and the player data with our two public fields.
Let's go check that out now and see if our two public fields show up.
Well, we've got player datas that's showing up here.
Let's hit play now and see what we get in the first player data.
All right, here we are.
And it it's not showing up right, but I think if I go select and reselect.
There we go.
My game manager.
I can see it.
So, if you get it kind of weird and bugged out, I think it's from the level loading and the object moving.
It's not updating the inspector.
If you see that, that just reselect the object.
And let's go check it out.
I've got my player datas with an element zero, some coins.
You can see my coins going up.
And if I join on player two, here we go.
So, I run over here, go get some coins.
And if I look at this second element, you see that I've got coins in there as well.
So, now I'm getting coins in both of them.
I don't need to be in debug mode.
I can see that in normal view.
And my coins are tracked independently across levels.
Let's go to the next level.
You can see that this character, player two, isn't in.
They haven't rejoined yet.
But if they rejoin, they've still got their 11 coins.
And if I click through, you'll see that they've got the same amount of coins here once I rejoin again.
I got to rejoin the level every time.
We haven't dealt with that yet.
But everything else is uh I think pretty much just working and keeping track of of our data.
And hopefully you're starting to see some of the benefits here.
Now we've got an easy way to rebind up our player data to a player without having to do any complicated stuff in our saving and loading of data is also going to be easy as well.
So I'm going to stop playing.
We'll go into plastic SCM.
Make sure that I've saved my scene.
And then we'll say that we made the player data serializable and check it in.
Now that we've got coins and health on our player, let's start implementing health so that our player can actually take more than one hit without going to a new level.
Nothing would suck more than having a two-player game and the second player dies instantly and game's over.
So, let's put in another way for our player to die and take some damage or maybe an easy way to take damage so that we can start putting in some health points or health bars and then see see that system kind of come together without having roaming enemies that we have to run into.
We're going to begin by creating some lava.
So, all you need to do is in fact, let's do this as a little mini challenge.
Create a new lava object off to the left of our ground.
So, I want you to create an a lava that's about the same size as this water, but just over here to the left.
I want you to start doing this on your own.
See if you can go through the process and make it kill the player on touch at first.
Once you're done with that, resume the video.
I'll run you through that process and then we'll start talking about how we're going to change our player to not just die every single time they touch stuff.
So, go ahead and go through that process.
Make your lava right here.
Make it kill the player on a single touch for now.
and then we'll run through the the rest of it afterwards.
All right, I'll assume that you've either gone through it or you don't want to and you just want to be guided through.
So, let's find the water object and create a new lava object off of it.
I'm going to actually just start by duplicating my water, hitting W and holding control and dragging it over here.
So, I've got a object right in the same spot where I'm going to put my lava.
I'll rename my water to be lava.
And then I'm gonna rightclick on it and hit prefab and choose unpack completely.
I want to just make a new prefab out of this lava.
So I want to remove that com that prefab reference completely and make some totally different type of object.
First thing I want to do is remove this buoyancy.
I don't need that.
I'm not using buoyancy.
This thing's going to kill the player when they touch it.
I think I want to uncheck the is trigger box as well and uncheck the water or remove the water script.
Don't need that.
Oh, and I don't need this.
Well, maybe for the audio source, I'll add a lava effect.
So, I might leave that audio source on for a while.
Now, we'll add a component.
I'm going to add the spikes component so that it kills the player.
And then expand out my sprite renderer and change this water top high to be a lava top high.
Let's see if I can find lava top high.
And drag it on over.
Look at that.
I've got some nice, beautiful lava.
I need to change my bottom part here.
So, I'll rename this from water bottom to lava bottom.
And then change the graphic here.
Oh, actually, look, I've got lava right there.
I just drag it right over.
So far so good.
I think um let's see if I got anything else missing.
I don't think so.
Let's hit save and press play.
I should be able to run over now and I think kill myself on that lava.
Unless I've missed anything.
Let's see.
I run over here.
I jump and yep, level one.
Go back over.
Here we go.
Bam.
I'm dead again.
All right, so we've got some lava.
That's exactly what I wanted.
Now I've got something that I can use to kind of bounce my player off and have them take some damage.
So let's go into our prefabs folder, turn this into a prefab first.
We'll take our lava, drag it right out here into prefabs, and then we'll save our scene, go into plastic, and say that we've created a lava prefab and placed in level one.
And we'll check that in.
Now that we have our lava set up, let's actually take a look at our spike script because right now we're using that to kill our player.
And it's not on spikes, so it seems like it doesn't make a lot of sense.
Maybe we should turn this into something more reusable and then figure out how we can have it actually damage the player without killing the player.
So, let's take a look at our spikes script.
The spike script right now checks for a collision enter.
And if we collide, it checks to see if we hit the player.
If so, we load scene zero.
Instead of doing that, let's have our player just take some damage and then our player can decide what to do from there.
Maybe they took some damage, their health went down, they bounced up, maybe they ran out of health, and we need to kill that player or maybe load up another scene or go back to the menu.
We'll let the player decide instead of a spike script that's just randomly attached to objects.
So, we're going to add in some braces here and we're going to delete out that scene manager load scene zero.
And instead of doing that, we'll get the player object.
So we're going to say var player equals collision collider.get component and we'll get the player.
If that player is not equal to null.
So essentially assuming that we have a player there, which we should because we're getting that with the tag.
We can actually remove that tag check in a moment.
But if we have a player, then we're going to tell our player to take damage.
And that's it.
We'll start with just having them take damage.
We'll create a method for that by hitting alt enter and hitting generate method.
Now let's start our take damage method by just having it load scene zero.
So we'll say scene manager load scene and we'll pass in that zero.
Save and make sure that everything works.
Again, we've done no functional change, which is the way I like to do it before we make a a big change.
We'll make a structural change here so that we change what's doing the thing.
And then after we make sure that that works, we'll change what that thing is.
So right now, the player is going to call load scene zero instead of the the spike.
Let's see if that works.
So we should be able to hit play, run over, jump on that lava or a spike or anything else, and go to our menu.
There we go.
We're to the menu.
That's working just as expected.
Let's go back into our spike script and then we'll go to the take damage method of the player.
So, I just went in, hold control, and click on take damage to go to our take damage method.
Remember, this internal word is essentially the same as public.
I'm going to put public here over both of these internal keywords just to make it a little bit less confusing.
Less keywords.
All right, so we've got our take damage method.
And instead of loading scene zero, what I want this to do is just reduce our health.
And if our health gets below zero or two zero, then we could load scene zero.
So, we'll say health minus minus but we don't have a health right so instead we need to say underscoreplayer dataalth minus minus then we'll say if our player data oh is it going to autocomplete for me player data health is less than or equal to zero then I want to do this load scene so I'll take line 508 and put it up here in between the parenthesis and then we'll return so we lo we'll load scene zero and then exit out because that means that we've died.
Otherwise, well, we probably just want to make the player do something special like play a sound effect or bounce them or maybe flash the screen or do a screen shake or something else.
But for now, let's just save and not do anything.
We'll just say, "Hey, if you take damage, we'll reduce your health and if your health gets down below zero, we'll kill you." But right now, our health is always going to be zero.
So, we need to come up with some sort of a default value for our health.
And I'm going to do that right inside our player data.
We'll just assign it to let's go with a value of six for now.
So imagine we've got six little hearts and we're going to go through six of those.
We'll bind this all up and kind of figure out a better place for this later.
But for now, if we just default initialize it to six.
Whenever we get a new player data, it should have a value of six.
Let's go try that out.
So we're going to hit play.
We'll select our game manager so we can see all of the data across our game.
Well, specifically our player.
Good.
There we go.
We've got six health.
And I'll go run over here.
Jump on the lava.
Bam.
I've got five health.
Four health.
Three.
Two.
And notice when I walk on it, I can even kind of bounce myself cuz I go up and down off of the lava.
But there we go.
I'm down to zero, even negative one, and totally dead.
Go back in.
And I'm actually still going to be dead here the second I touch anything because my health doesn't reset when we start a new game.
So, something else that we're going to have to deal with is resetting that data.
For now, though, let's go into our plastic SCM setup.
Make sure that everything is saved.
So, that we added take damage method to player and hooked it up in spikes.
And we'll check that in.
in.
in.
Now that we have our player taking damage from the lava, let's make it a little bit more interesting.
Let's make it so that our player bounces off or gets knocked off of the lava or anything that they hit that causes them to take damage.
Going to knock them back and then maybe even add in a sound effect.
To do that, we're going to open up our player script again and we'll take a look at the part where we take damage.
When we take damage, what I want to do is have our player kind of fly back the opposite direction of they hit something.
So, if they hit something straight up and down, they kind of go up.
So, if they land on something, they go up.
they had something at an angle that kind of go up and at some sort of an angle kind of off the way that they should bounce back.
So to do that, we're going to need to know the angle of the collision that our player came in at and then tell them to bounce in the opposite direction of that angle.
So what we're going to do is take a parameter in our take damage method.
Right now it takes no parameters.
That's why the parenthesis is open.
But we're going to make it something like the bind method where it will actually take in a parameter that's a vector 2.
So put vector 2.
And what we want here is the hit normal or the kind of collision normal which is the angle that we've come in and collided at.
So this is going to be a vector 2 representing the angle that we collided at.
And I'm going to call this hit normal.
And then down here on line 159, we're going to tell our rigid body to add some force in the opposite direction of our impact so that we bounce back the opposite way that we hit.
To do that, we'll call underscore RB add force and we'll give it our hit normal.
And we want to multiply it by some velocity amount, some knockback velocity, but we want it to be the negative value of that knockback velocity because we want the opposite of our hit normal.
So we can do a negative hit normal here or star equals negative knock let's call this knockback velocity.
In fact I'm going to move the negative over to hit normal just so that it's a little bit more obvious.
So we've got our knockback velocity.
Now it doesn't exist.
We're going to generate a field for it and that'll be a serialized field.
So I hit F12 to go up to it.
Replace private with serialized field.
And we want to replace this vector 2 as well.
By default, it just assumed that I want a vector 2.
And that's because we were multiplying a vector 2 times that number.
So it just says, hey, you probably want another vector 2.
But we really want a static or a floating point variable.
Not a static, but a single variable or value that we can multiply our hit normal by.
So we can have some sort of a magnitude or intensity for that velocity.
So we're going to place replace vector 2 with float.
And then we'll give it a default value of I'm gonna go with 200.
I'm gonna move this up by my other serialized fields.
So I'll cut it and then paste it right up here by my coin sound effects.
And then we'll save.
Now I should be able to go back into Unity and see my value right here of 200 right below my coin sound effects.
Oh, if I Oh, I have an error though.
So I don't I'm not going to see that.
Let's take a look at this error here.
It says that spikes.cs CS has an error saying there is no argument given that corresponds to the required formal parameter hit normal of player.take damage vector 2.
And here it says this is on line 15 at column 24.
The line number is always good.
The column number usually okay but not always the not always 100% accurate.
Line 15 though.
So let's double click on it.
And here you can see that we're calling line take damage.
And it looks like column is correct too.
But we're calling the take damage method.
And it now has an error because we didn't pass in that parameter that it wants, the hit normal.
I hit F12 to go to this.
Let's go back and just pass that in.
To get the hit normal, we actually can grab it from our collision data.
We'll pass in collision.
And the contacts are all of the different points that our collision hit.
So most of the time our contacts is going to be an array with one entry.
And it'll be like, hey, right here at this specific point on my finger is where the contact is.
It'll tell me the exact point.
and that normal if I hit in two spots in the exact same frame though I might have contacts like this where I've got or technically if it was yeah I could end up with two contacts or maybe they're like this and they're like side by side and two I'm touching at two spots on on my hand with this this other hand object I could have two in there but by default we're always going to have at least one so we can access it by index zero and then get the normal so we're going to pass in the normal of the first contact if they have multiple context, we're just going to ignore it and assume that the first one is the correct one.
Most of the time we're only going to have one though.
So, let's save.
At least most of the time with our normal character on a normal surface.
We're going to have one contact.
So, here we'll save.
And now we should no longer have that error.
If I hit control shiftb, I should get a build succeeded in the bottom left.
And I should be able to go back over to Unity, see my knockback velocity, press play, and now run over to this lava and start bouncing off the top of it.
Let's see if that's the case.
So, I run over here, jump, and bounce, bounce, bounce.
You can see I'm getting knocked up.
Let's change this to a 300.
And let's give myself some more health.
I'm going to go select the player input manager and game manager.
Grab my health and crank it way up.
Look at that.
I got 405 health.
Now, I bounce.
And that feels like a more reasonable amount.
Thinking 300.
Let's go with a 400 and see what that looks like.
Yeah, I think um I might even be good with a 400.
So, I'm going to stop playing, put in a value of 400 here for my player, save or go to overrides and apply all.
And then I'll even go into the code and just change that default.
That's one of the things that I like to do a lot.
If I come up with a new default value that I think I'm going to use, I just go into the code and change it right away.
So that way I don't have these overrides in two different values and have to try to remember which one did I actually want to use.
Now I've got my knockback velocity in there.
We'll go in save our scene one more time.
Go to plastic SCM.
Say that we've added a knock back to taking damage.
And you're going to notice that this happens when we hit the springs as well.
Anything that causes damage is now going to knock us back.
Now that our player can bounce, let's add some sound effects as well, so that when we take damage, we hear a little grunt or some feedback that our player can see or hear, I guess, not necessarily see, but kind of get that into more of their senses.
We've got a coin sound effect, and I already like using that.
So, let's take a look at what we've got there and see how we can maybe use that same or similar code to do a sound effect for taking damage.
So, go open up our player.
We've got our coin sfx here and let's just duplicate this line.
We'll take line 16, duplicate it, and call this hurt sfx.
So, this will be our sound effect for when we get hurt.
Now, let's find where we're calling our coin sound effects and see how we were doing that.
Again, to find all references to our coin sound effects, I can select it and hit shift F12 or rightclick and there should be a find usages or find all references option.
Find all references right there.
Shift F12.
That'll bring up a dialogue down on the bottom of my code editor, my IDE, and it'll allow me to find all of the usages, which there's only one of.
So, when we add point, we call this audio source.play oneshot coin sound effects.
So, you can probably already guess what to do here to play a her sound.
I'm going to give you a couple seconds to go figure it out, put it in yourself, and then I'll run you through it.
So, go ahead and do that.
And now I'll run you through the solution.
So we're going to cut line 146 or not cut it, just copy it.
Select it and copy it.
Go down to our take damage.
And when we take damage, we'll paste.
And we'll call the hurt SFX.
We'll save that off.
Minimize Unity.
And then we'll go download a sound effect.
So I've got these five hit sounds from Open Game Art.
I think that these sound pretty good.
I'm going to download this one.
And then we'll pull in those sound effects.
So, I'll go open up that pack, go into the MP3 folder, and I'll just take hit um let's just take hit one for now.
We'll take hit number one.
We'll put it right into our audio folder.
Right click, create.
Actually, you know what? I'm going to take all of these.
I'm going to take hit one through five and die.
Copy them.
And I'm going to paste them all inside of my audio folder.
So, go back to my audio folder.
Right click, show and explore.
I think I accidentally created a new window in there.
A new folder.
I don't want to do that.
I'll delete that and just paste instead.
There we go.
I've got my hits and my die.
Let's see them all appear right here.
And then we'll go assign one of the hits to the player for now.
So, we'll just take hit number one and drag it in as the hurt SFX.
Go to overrides and apply all so that it gets updated in our prefab.
If I select our prefab here, we should be able to see that we've got that hurt SFX there.
Looks good.
Let's press play now.
Go jump over there, take some damage, and see if we hear a little bit of a noise, some audio feedback that we're taking damage.
All right, four, five, and six.
Okay, and we're dead.
Did I take one extra hit? I've lost track now.
Go to my game.
Yep, I did take one extra hit.
So, we didn't die when we got to zero health.
Let's go open up that game manager.
Not the game manager, the player script, and see why did we not die when we got to zero health.
This is, I think, going to be the final challenge of this lesson here.
So, take a look at this code and tell me if you can figure out why our player lived until they got to negative one health.
If you can figure it out, go ahead and fix the problem right now.
If not, then hang on just a moment and I'll show you.
All right, hopefully you already fixed it or paused it and found the solution.
But the problem here is actually pretty simple.
On line 157, we're doing a check to see if the player data.health is less than zero instead of less than or equal to zero.
So if it gets equal to zero, we'll just subtract one.
It'll go to negative one.
It'll play the damage.
They don't actually die.
We want this to be a less than or equal to zero.
So just add in the equals to the right hand side of that less than statement.
I'm going to get rid of this extra space that we don't need.
Save.
Go back into Unity.
And let's go to plastic SEM and commit our changes.
So, we fixed health and we added hit sound effects.
So, let's put this in added hit SFX.
And I'm going to uncheck this new folder that I don't want added that I didn't mean to create.
So, we added hit sound effects and fixed player dying properly at zero health.
Then, we'll check in our changes.
Now that our player's health system is working, we need to hook it up to the UI and give them some sort of a health indicator, like a health bar or some hearts.
Right now, the only way to see the health is to look in the inspector.
And here you actually have to make the player data public to even see it.
I can watch my health go down as I jump on things.
Oh, and got to go reselect him.
There we go.
I can see my health there.
Jump on things and watch it update.
If you don't see it updating, just make sure you go reselect your player object.
But that again only shows up if I make my player data public.
And using the inspector or the editor like that is obviously not what we want to do.
Instead, I'm going to remove that public keyword that I just temporarily added.
We'll watch this turn gray and disappear so we can't see the player data.
And then we're going to modify our UI, our player canvas and our player panels specifically to give ourselves the ability to um have health bars on here.
So, let's start by going to our player canvas.
We're going to open up that prefab.
I'm just going to hit the arrow right here to open the prefab in context and go to the scene view.
Now I should just see the prefab edit mode.
I can zoom in and out with my mouse wheel and get that left mouse button to pan around.
And the first thing I want to do is update this player panel.
This player panel one, I want to make it four times the size.
So twice as tall, twice as wide, and then give it some room for health bars or for health hearts.
First, I'll switch out of debug mode on my inspector into normal mode.
She's in the little hamburger menu or the three dots there.
And then we'll modify the size.
So, I'll set this to 200 by 200.
So, just type in a 200.
Tab and 200.
Go select the score text.
And this one I only want to cover like the top 75 pixels or so.
So, I'm going to set the bottom here to what is it going to be like? 125.
So, that way I've got 125 below it.
And now you can see I've got my number up here.
And if I go to the game view, well, you can't see anything cuz it's in context in the prefab edit mode, but you can see right here about the size that I've got.
I've got 75 pixels for the top and 125 to spare for the bottom.
Now, I'm going to go to the panel, right click on it, and choose UI, and we'll create another panel.
That's going to be this bottom panel here.
We'll set the top to 75 so that it covers the bottom except for the top 75 pixels.
This is the offset from the top, assuming that it's filling out and stretching everywhere.
And then I'm going to disable the image because I don't want a background image for this part.
Underneath this panel, I'm going to rightclick and choose UI and image.
And we're going to add a heart.
So, I'll once I've got the image here, I'll name it heart.
And I'll name it heart_1.
And we're going to use that name specifically because you'll see why in just a moment.
And then go to the source image and we're going to search and we're going to find the heart.
This should be included with the assets that we got.
And I'll just take the full heart right here.
Now I'm going to go up to this panel and we're going to add a new component to it.
What I want is multiple hearts to appear in a grid.
Either a 3x two grid or a 4x2 grid or 2x two, whatever size it is you end up deciding you want to go with.
But I'm going to go with I think a I think I'll do a 3x two grid.
So to do that with the panel selected, well first let's rename this panel to hearts.
And then with the hearts object selected, we'll hit add component and add a grid.
Just search for grid and find not grid itself though.
Grid layout group.
Look for this one right here.
Grid layout group.
And add that component.
We'll change the cell size to thinking 66x 66.
So that's 200 / 3 like 66.66 right around there.
Give us the right width.
And then I want the height to match so that I keep the right ratio.
So, I don't want this to be like um 100 tall and stretch out or anything.
I want it to match.
So, change that back to a 66x 66.
Then, I'm going to go to this heart and I'm going to duplicate it.
Now, the first thing I want to notice if I duplicate it right now, the name gets kind of weird.
It's heart_1 and parentheses 1.
I'm going to delete this heart and we're going to go into our options or preferences.
We'll go to edit and go to I believe it's under project settings.
And then we need to look for Let's just search for duplicate.
Let's see if it shows us our text.
Nope.
Um, let's see.
I think it's under editor.
We'll find it right here.
We'll find the option uh right here under editor in project settings.
You'll see the game object naming and it's got prefab and then the parenthesis and one.
You can choose a couple options.
There's prefab one or prefab_1.
and we're going to go with the underscore one.
If you prefer dots, go ahead and use dots.
It doesn't matter.
I just don't like using the parenthesis because it ends up being a mess.
So, here I've changed it to one underscore one.
I'm going to close that window, go to file, and save project, which is going to update my project settings.
If I go to plastic SCM, you see that now my editor settings and project set, I think it was the project settings specifically, they got updated for that.
Now, let's go back to our heart.
So, I'm going to go select my heart and I'm going to duplicate it with control D again.
Now I've got a heart two, a heart three.
One more time.
Keep doing it.
D, d I've got all of my hearts lined up here.
I've got a nice row of six hearts, which is just about what I want.
Now I need to do this for my other player panel as well, player panel two.
But I don't want to recreate all of this work and have it become a mess and, you know, possibly mess up one and have to do this work multiple times if I go to three or four players.
I don't want to have to do it over and over either.
So, what we're going to do is create a nested prefab.
Now that we have our hearts created here, what we can do is create a prefab out of our player panel and then have our player canvas.
Use multiple of that prefab.
So that way, we don't have to modify both of these panels.
We just have to do the one.
Now, to do that, we're going to go to the prefabs folder here.
We'll take the player panel one, and I'm just going to click it and drag it in to turn it into a prefab.
Now, now it'll become a prefab.
obviously see that it's turned to blue and it shows up down here.
I'll rename the prefab instead of it being player panel one to just be player panel.
We'll still leave this one here as player panel one because this is the one for player number one.
Then we'll go to player panel two, select it, just leftclick and then right click on it and find the prefab menu and hit replace.
Now we'll choose the player panel and check that out.
We now have a panel that's here but it looks a little bit weird.
And the reason it looks a little bit weird is that right now we are overriding the width and the height.
If I go to overrides, you can't really see it there.
It's actually not really overriding.
It's kind of at the one level up.
So, what we need to do is select the width, put in a 200.
Select the height, put in a 200, and tada, everything is fixed.
So, now you can see we've got both of our player panels.
I'll rename this one to player panel 2 since it's for our second player.
And then we'll save off our player canvas by going back, hitting save, and then let's go back into game view.
And we should see both of these.
Let's just press play, and make sure that the coins are still working, and we've got both of the UI elements there before we start worrying about code.
So, we've got it here.
I can run around.
I can still go grab some coins.
Watch my UI update.
And my health bars should not update yet when I go over here, but I should still be able to die.
So, there we go.
We got I'm still taking damage.
No updates yet because we haven't hooked up the code.
But we do have these panels here and we have our nested prefabs.
Let's take a look at those prefabs one more time.
So, if I go into my level, you can see I've got my player canvas here.
If I select it, I can see the prefab data on it.
It's referencing this player canvas prefab.
And I can go select it by hitting the select button and finding that canvas.
If I select one of these panels underneath it, though, these are referencing the prefab.
That's the player panel prefab instead of the player canvas.
They're children of the player canvas because now we're using the nested prefabs.
And you hear about nested prefabs, which you'll probably hear about a lot with Unity.
Just remember that they're essentially a prefab that's reused underneath another prefab.
And almost or most of the time, not I'd say almost always in the experience that I have, they end up being UI related type things.
Occasionally you'll have some nested prefabs with characters, but most of the time they end up being UI related because it just makes a lot of sense with UIs because you're creating these components and those prefabs are getting put in as components of other bigger components and you're building up these systems.
So now that we've got our nested prefabs, I want to go into plastic SCM and just go commit our changes really quick.
I can see though that my player is showing here has changed.
So, I'm going to right click on it and hit diff just to make sure cuz I don't think I changed anything in it.
Let's scroll through.
It says the files are identical up here.
So, it looks like I didn't actually change anything.
I must have just uh opened and modified the file accidentally.
So, I'll just hit right click on that one specific file player and hit undo changes.
And then I'll check in my changes that we added.
Nested player panel prefabs.
We have our hearts now in the UI.
So, let's bind up to them or use them in our player panel binding.
I've got my player panel one selected here.
And let's go open up the player panel script.
First thing we're going to need is a reference to those hearts because I want to either change the sprite or toggle them on and off based on what our current health is.
We can maybe use the empty health image or just turn the sprite completely off.
Let's go up to line eight.
add a new line after it on nine and we'll add a serialized field which it's nicely autocompleting.
And here we're going to add an image array.
So we'll put image image g.
And if I hit enter right now or tab or anything that's going to autocomplete to the wrong one.
What I want to do is go up and find this image that's unity engine.
I'm not even going to do that though cuz I want to show you how to manually do it in case you can't find that.
So I'll hit escape here and add in our two square braces.
That tells it that it's an array, not a single image.
And I'm going to call this underscore hearts.
Now I'm going to pull this up to the other line just by going up to the end of the line and hitting delete.
And just kind of re it'll re realign it.
And then let's hit alt enter.
What's going on here is it's saying, hey, I don't know what image you want me to use.
There are a bunch of different types of images all defined in different libraries and namespaces.
There's one here in the media types, the net my media types.
There's one for the Visual Studio editor.
There's one for the Unity engine UI.
And there's one in the Unity engine.
Uuielements namespace.
The one that we actually want to use because the UI that we're using isn't UI elements is the Unity engine UI.
And as soon as I click on this, it's going to add a statement right up at the top that says using Unity Engine.UI.
Let's hit it.
And you can see that got added.
If it doesn't pop up, you can't get the popup to appear.
You can of course just type that text right in.
But if you have multiple of them, like say let's duplicate this and say that I also have the UI, what was it? UI elements.
Now, it's going to give me an error because I'm going to say, "Hey, I don't know which image you want.
Do you want the one from UI or from UI elements?" If I just get rid of this UI elements because that's the new UI system that we're not using.
It's it's a slightly different UI system.
We're not using it right now.
So, we don't need that in here.
We remove it and the error is gone.
So, let's go to our update method.
Now that we have our hearts here, let's say we have all of our hearts assigned, all six of them or however many there there are.
What we want to do is in our update just update the hearts that are visible or change the sprites.
Again, we'll go through optimizing this in just a moment.
But first, let's make it work exactly like our score text does.
So, we'll add a new line here, and I'm going to add an open brace because I want it to do more than one thing after the if statement.
We'll delete that close brace.
Go down here, hit enter, and add in a closing brace.
Now, I've got braces around my set text.
And after we set the text, what I want to do is loop through each one of these hearts.
So, we're going to iterate on them with a for loop.
And we want to just toggle whether or not they're enabled based on how much health the player has.
And it's a pretty easy thing to do, but it's kind of a a unique I guess it's it's a cool thing that you should definitely remember how to do.
Let's just type out the code.
Let's start with the for loop.
So, type four and then hit tab.
It'll kind of autocomplete for me.
If it doesn't autocomplete, you can of course just type out the entire thing.
But we got the int i equals zero with the parenthesis.
The semicolon here, the i less than length, which got not selected yet, but will be in a moment.
And then it gave us some braces.
So I'm going to hit tab a couple times, go over to the word length, and what we want to do is loop up to the number of hearts that we have.
So we'll go from zero to hearts hearts.length, which is however many hearts are in that array.
If we put nothing in there, it'll be zero.
Nothing will happen.
And if we put one in there, it'll run through this loop one time with I being zero.
If we put two in there, it'll run through this loop two times with I being zero the first time and I being one the second time.
So let's write some code inside of this loop to do what we want it to do.
So first thing we want to do is check to see well the first thing we really want to do is modify whether or not this thing's enabled.
There's really only one thing we want to do.
I'm saying the first thing, but there's really one thing we want to do.
So, what we'll do is get Well, first let's let's split this out just a little bit.
Let's say heart spelled that wrong.
Um, oh, it's image heart equals underscore hearts at index i.
So, this is going to get us the heart for the number that we're on.
So, zero will get us the first one, one will get us the second one, and so on.
And you'll see these indexes match when we're looking at them in the inspector.
So, we'll get the heart, and then we'll say heart.enabled enabled is equal to I greater than player.alth.
Oh, health.
There we go.
And I actually said that wrong.
It should be less than.
And then we are done.
Except we have an error.
So let's first evaluate what this code is doing and then we'll fix the error.
So on line 27, we set enable to be either true or false based on whether or not this I value is less than the health.
So if it's heart number zero and our health is at one, then it will be set to true.
If our health is at zero, then we're dead and it's set to false.
If it's if our health is at three, heart zero will be true.
So the first heart, heart one will be true enabled and heart two will be true enabled.
So I'll have three hearts enabled with three health.
But heart three will be I index would be three which is not less than our health.
So that one would not be enabled.
So that's the logic here.
But we don't have access to this health.
We can't actually read it.
It says hey player does not contain a definition of health.
Oh no.
What do we do? How do we possibly get this? Well, all we need to do is kind of expose this variable to our player.
Right now it's in our player data and we want to make it read only accessible to our from our player.
So we'll hit alt enter and generate a property.
Now if that doesn't work for you, you can of course manually type it in, but I'm going to hit F12 and go to that property.
It should have put it right below my coins.
And if you don't have your things organized, your properties aren't all together and stuff.
It's it's kind of going to be a crapshoot.
Who knows where it's going to end up.
If you keep things organized and clean, it'll show up in the exact same spot.
So, we've got our health here, and we don't want to have this setter part.
We We kind of want this getter like we have here, but we don't necessarily want the setter.
So, I could copy this getter part, paste it right in here, and then replace coins with health.
Now, there's also a shorter way to write this, though, because if we don't want to do a a setter at all, and we just want to get her, we can actually remove the parenthesis and the get and just do it like that.
And this will give us a property that can read this health, but it cannot write or modify it.
And that's because we don't want our UI modifying it.
So I'm going to save with control S.
Go to our player panel.
Save with control S.
I'll do a build with control shiftB.
And just make sure that it succeeded, which you can see right down here.
Build succeeded.
And we'll go back into Unity.
Let's take a look at our player panel.
We should now see our hearts appear here.
See, we did expose those as a serialized field, right? Yep.
There we go.
any second now.
I expect it to recompile unless I've got an error here.
It's not picking it up yet.
So, I'm going to go to my scripts folder, rightclick, and just hit the reimpport.
Where's that at? Reimport.
See if that recompiles.
It should force a reload, and then have this code re-update.
Let's see if that works.
There we go.
Now, I've got my list of hearts.
Now, I'm going to go into my player panel prefab.
I'll just hit the open prefab button.
And what with the prefab open, I'm going to have the player panel selected.
I'm going to choose the lock.
Just go hit the lock so that my inspector doesn't change.
And now if I go select a heart or anything else, see that the inspector stays the same.
Now I'll select heart number one, hold shift, select all the way down to my last heart, heart number six, and drop it right on the word hearts.
And I should get element zero all the way through five with hearts 1 through six in that exact order.
So remember this is that I index of 0 1 2 3 4 5 that I was talking about.
Let's go back.
Hit save.
That should save our prefab.
And if I go look at the other player panel, it should also have hearts.
But I don't know.
Yeah, I'm not in lock mode.
Make sure that your lock turned off.
When you got out of prefab mode, it should have turned off that lock, though.
Now, if we press play, I should be able to run over and watch my health just drop down.
Let's see if that's the case.
I run over here.
Boing.
Look at that.
Health is going down.
And let's add in another player.
So, I run over here with player two.
And it still works.
Everything works.
And it's all hooked up and bound using the same binding that we had on on our coins.
Oops, I can't run over there and get a coin.
All right, let's stop playing.
Go into plastic SCM and say that we set up a basic coin U or not coin, basic health UI.
setup basic health UI bound to the player and we'll check that in.
Now I want to have a little discussion about performance.
Our current setup for the player panel pulls the player and updates the UI every frame.
If we take a look at our player panel script again, I'll go find my player canvas, go grab a player panel, and just pop it up right here.
See, in our update method, if we're bound to a player, we basically update the text every single frame and then update the hearts every single frame.
And while that works and it's not really causing us any problems right now, there are some things to think about with this.
A lot of the time when we have UI data or just data in general that isn't going to change often like our health or our number of coins.
And when I say isn't going to change often, I mean isn't going to change, you know, more than once a second or or very rapidly or very commonly.
It's not something that's going to be changing like every single frame or multiple times a second.
If we had some timer or some count up thingy, that that would be a little bit different.
But if we have something that's kind of a a semi- rare event, at least taking damage should be a semi- rare event in this game, then what we can do instead of polling and reading the data is get notified with an event and update based on that.
And there are some real big benefits to it.
But first, I want to show you the performance characteristics of what we have right now.
Because you might be thinking, looking at this, oh no, this is a nightmare.
We definitely have to fix this.
We can't be just updating and reading things every single frame.
But if I go into our code or sorry into our project and press play and then open up our profiler window which we'll find under the window menu.
Let's let's start playing under window and then analysis and profiler.
I'll grab the profiler window and I'm just going to dock it right in here with the game view.
And remember that our code for the player panel is running every frame in the update.
It does not care about anything that I do.
If I go grab another coin, it's not going to change anything with the way that it's running.
Let's take a look at the code though or the performance data.
Do that just to verify that I'm not making stuff up.
And then talk about how we can optimize what little there is to optimize right now.
So if I let this run and I just click on any frame, it's going to pause the game.
I'll go back to my profiler tab.
A lot of the time I'll just pull the profiler down to the bottom, by the way, so you can see it.
In fact, let's do that.
Pull the profiler down here.
So, if I select a frame, it's going to tell me exactly how long everything took for that specific frame.
Right now, things are not taking very long.
I'm going to hit unpause and just go to the stats window.
See that things are not taking long at all.
We've got what am I getting? 40 frames a second.
I was getting a lot more than that a moment ago, but I think because I started profiling it dropped, but if I go click on a frame and then expand out the player loop down here.
So, with CPU usage selected, I go click on any one of these frames, expand the player loop section, and then I want to look for the update script run behavior update.
That's the part that's running my code.
Script run behavior update.
That's running all of the things that's in our update loops or in our update methods.
There are other things that show up here in our own code, but this is the one that we're going to worry about now and the main one that you're going to see.
So, I'll expand this out again.
you'll see behavior update and below it, expand it out again, just hitting the right arrow, by the way, and the down arrow to go down.
Below that, I lost it.
You'll see that we've got our player update.
And then down here, we have our player panel update.
If I look at the time for the player panel update is the code, the time that it's running here is 04 milliseconds.
That's extremely small.
It's low enough to not really care about.
It's being called two times because we have two player panels.
the one over here on the right and the one on the left.
But it is doing something bad that might not be as obvious and that's this GC alloc.
It's doing 24 bytes.
And if I scroll through frames, you see that it's about the same every single frame.
We get a low number in the milliseconds and 24 bytes.
If I press play, let's see, and then just run over.
I said I would run over here, grab some coins, you see that nothing's really spiking here.
There's a couple little spikes right here, but they're not in this code.
They're around the audio source playing.
If I scrolled up, I could see a little bit more data on there or some rendering stuff and editing things.
But if I look at the actual code for my player panel here or the timings for it, you'll see that it stays about the same.
It's not changing.
So, what is this allocation and how do we change all of this? Let's go back to the player panel script.
So, in the player panel script, the worst part that we have here is actually this right here, this two-string method that's changing our integer value of coins into some text to pass it into the set text method.
There's no easy way to optimize that and to get rid of that.
There are some hacks that you can do, but the best thing that we can do is just only update the coins when um our coins actually change.
And we can do the same for our hearts.
So, let's start by adding an event for our coin updates so that we can get notified when coins change and then update the number of coins that we have.
To do that, we're going to go back to our player script and let's find the part of our code where we modify coins.
Right here, we set the player data coins in the coins section.
So, let's hit shift F12.
See where we set the coin data.
And you see it's right here on player line 145.
we do coins plus+.
So this is the part where we're adding a coin.
So right after we add a coin or change the number of coins, we want to call an event or invoke an event that our player panel can listen to.
This will be something that will fire off or invoke every time our coins change.
So let's go up to the top and we're going to declare this event.
I think we should do this right before our properties.
So, I'm going to add a line right here on line 34 and get a little bit of spacing.
We'll add a public event with a lowercase E and then action with a capital A.
We'll call this coins changed and add a semicolon.
Now, this is going to just allow us to invoke something called coins changed and have any number of things listen for when that coins changed is invoked.
You can have events with parameters.
This is not an event with parameters.
If we had parameters, we would put the type right here, but maybe do like an int and then we would be able to pass in an integer value.
Or we could do an int and a string or something else and pass in multiple parameters.
I don't want any parameters for this though, so I'm going to delete both of those and just have public event action coins changed.
I'll copy the word coins changed.
And let's go find the part where we modify our coins with coins++.
Right here on after line 147, we'll add a new line called coins changed.
And we want a question mark invoke.
Now, we could do just ainvoke, but what that'll do is fail or blow up and or really it's going to give us a null reference exception if nothing is registered for this event.
If we add a question mark here, it's going to check to see that something is registered before trying to invoke it.
You might think, hey, shouldn't that be the default behavior? But hey, this is actually a pretty new thing.
The way that you used to have to do it before was say if coins changed.
Let's see if I can get that spelled out right.
Then here we go.
If coins change is not equal to null, then invoke it.
But this new syntax of just doing it with a question mark, I think uh is quite a bit easier and works a lot better.
Well, it doesn't work a lot better, but makes it less code.
So now we've got our coins changed event here being fired off when we add a point.
Next thing we need to go do is go to our player panel and tell it to listen to that coins changed event.
We'll do that in the binding.
And this is where you'll usually set up your event registrations in some sort of a binding method like this.
So we'll say underscoreplayer.coins changed.
There we go.
Got to spell it all right.
Plus equals.
And we don't do an equals.
We do a plus equals because we want to add something that's listening to this.
Coins changed is an event.
And with events you either add or remove things.
You don't generally set them.
There's there's some hacky ways you can do setting, but we want to do coins change plus equals to add something to listen to this.
And we could have other things listening to coins change, too.
Audio systems, um, event systems like, uh, I can't get my word right.
Um, achievements.
Achievement systems like that could be listening every time coins change.
Let me know see if we broke a record or something.
You could have multiple things listening here.
We're going to listen with a method called update coins.
I'll just type in the word update coins, add in my semicolon, go back to it, hit alt enter, and generate a method.
I said we're going to have a meth use a method named update coins because that's what seems like a good name for it.
We'll remove the word private because I don't need the private keyword.
And instead of throwing an exception and giving an error, let's delete that.
We'll take our line 30 code here, cut it with controlx, and paste it into update coins.
So now whenever our coins change our update coins method should call.
The last thing that we want to do is call update coins when we do our binding so that we get our coin value set immediately when we bind and we don't have to wait for it to change the first time before we actually set it in our UI.
So I'll copy the word update coins here with our parenthesis.
Put it on to line 19 so that we invoke it right after we register.
So now we'll bind to our player.
We'll cache that player into the player variable.
will register for that player's coins changed event.
So in the future when the player's coins change, we'll get notified and the coins well really we won't get notified but the update coins method will be called.
That's the notification.
And then we call the update coins method after we register for that event just so that we have a good default initial value and we have the correct number of coins.
Let's save, jump into Unity, and see that in action.
And then we'll look at the profiler and see if that cleared up our GC allo, which is a garbage collection allocation, which I didn't even talk about the reason it's bad.
So, let's talk about that while it's loading.
Garbage collection allocation or GC alloc memory being allocated by your computer to be used for something and um needing to be cleared up later.
There we go.
Look at that.
We're getting coins and the UI is updating.
Let's go look at this here, though, and see if we're getting a bunch of GC alloc.
So, I go down here to my player panel here, and you see that we've got zero bytes.
I should be able to scroll through eventually and find the one where um where my coins changed.
Let's see if I can do that.
I don't know how many frames ago that was.
Somewhere in here.
I maybe I'm not going to be able to find this specific frame, but there should be a frame where I generate it.
Every time I actually hit a coin, I should be generating 24 bytes of garbage.
Now, the reason this is a problem is specifically on mobile devices.
Re reathering all of that memory that you keep allocating over and over causes those little spikes and hiccups that you see on mobile devices.
It's a lot more pronounced on older devices, and it's definitely not going to be an issue with 24 bytes on this little thing, but it does build up.
So, garbage collection allocations are one thing that you definitely want to worry about.
We're going to be talking a lot more about that when we dive into pooling as well.
The time though is pretty good.
So, no real noticeable difference there.
You see it's still at 0.0.
It's actually faster.
It went from 0.02 to 0.0 because we're no longer doing anything of any real work.
So, small optimization, not extremely useful right now, but it's going to come in handy to start understanding these concepts and to see what other kinds of stuff we can do with events in the next section.
Now, let's go into plastic and commit our changes.
Say that we switched the coin interface to use an event and we'll check that in.
In this lesson, we're going to start with a challenge.
What I want you to do is exactly what we've done with the coin system, but do it with the health.
So, switch over the health so that it only updates in the UI when the health actually changes on the player.
You're going to need to make changes to both the player panel script, not the player data script.
Let's find the player panel script and the player script.
You'll want to add in a new event and hook it all up.
Now, I'd like you to try this on your own and then when you're done, or if you run into any problems, get confused, just continue on and I'll help you with it.
One thing that I want to note is that you should not pass a parameter for this.
Don't add in a parameter for the player's health.
Instead, try exposing the player's health as a readonly thing.
Well, actually, it already is exposed as a read only.
So, don't pass it as a parameter.
That's over complicating things.
And you don't need to do that.
You can do it completely without.
So, go ahead and give it a try and then continue on once you're ready.
All right.
I'll assume that you've either uh paused and done it all or you ran into some issues or you're just ready to kind of go through and want to see the process the way that I'll do it.
So, let's take a look at our action for coins change.
First thing I want to do is add a new event for health change.
So, I'm just going to duplicate it with control D.
Replace the word coins with the word health.
And then let's find the place where we modify our health.
So, I'll copy the word health change.
Get that onto my clipboard.
Select the word health and hit shift F12 to find all references.
That's going to give me the place where I modify it, which it looks like is right here on line 159 of our player script when we take damage.
So after we take damage, right at the end of the method, I'll just paste in my health changed and call the question mark.invoke to fire that off.
Now, if you're wondering what about when our health dies or gets below zero and we die and all that and we load another scene, I probably don't care about things that are in this scene invoking and updating UIs of stuff that's not there.
If that needs to change and rearrange and I need to have something when a player dies and still update the UI, which may very well happen in a moment because we've got multiplayer stuff, then I might move that up there or rearrange things a little bit.
But for now, since if we're loading into a new scene when we die, doesn't make any sense to call this event.
So, we'll save and then let's go into the player panel.
In the player panel, when we bind, just like we do the coins changed registration, let's duplicate that line.
Add a health changed event and call update health.
We'll replace the word coins in both sections.
Hit escape, alt enter, and generate a method for update health.
Now, I can take this line of code right here, or these lines right here, the for loop essentially, 38 through 42.
Crl + X and then replace the throw exception.
Now look at my update method.
It no longer does anything.
It checks to see if I have a player and then does nothing.
So we can completely delete it.
Now our player panel is not running anything every frame.
It only runs something when something changes.
There's one piece that's still missing though.
Look here.
We call update coins when we do the reg after we do the registration.
We're not calling update health.
So let's copy update health.
add it right below with our parenthesis and semicolon.
We'll do another build.
Control shiftB.
Make sure that it succeeded.
There are no typos here.
We'll go back into the editor.
Let's go press play and watch our health work.
Totally bound up.
And we're no longer calling that update method at all.
We've removed some minor performance things, but we've removed them completely.
Look at that.
Our health is updating.
I'll put in player two here.
Here he comes.
Player two, jump, jump, jump.
And the same thing.
So, the health is working for both players.
When we die, we should go back into the menu.
And things are looking pretty good.
Now, I'll go into our profiler real quick.
Let's just take a look at the data that we had from the last profiling session.
I could rerun, but this is just showing me all of the data from the last one.
You can see here in our um do we have any there? Yeah, there's actually nothing there because the update for player panel doesn't run.
Let's let's hit play one more time.
Just look at it again.
Since there's no update method in player panel, it's not even going to show up in the behavior update.
It's completely cleared out of here.
Let's just go click and just double check.
So, all we have now is our player update, which is doing the raycasts, which is totally fine.
All right.
So, I think we're good.
We'll stop playing.
We'll go into plastic SCM.
So, we added events for health changed and bound to the UI.
and we'll check that in.
Now, we're going to take a look at another one of the benefits of events.
Since we're not just pulling and updating every frame, and we can actually tell when our health changed, we can do some cool little things with that, like give the player some extra indication, not just audio, but maybe something visual in our panel.
I want to add a little flashing part to our panel that just kind of highlights that our health has changed and show you something else really cool along the way.
So, let's go find our player canvas and then our player panel.
And then I'm going to expand out and find the hearts object.
We have this image here that I didn't disable.
And if I turn it on, you might see that little outline that appeared.
But if I change the color to a nice bright like a red and then crank that alpha up like that so that the alpha is at 255 and it's not transparent at all, then it's very obvious.
If I click that on and off, you can see it becomes very, very clear that there's a big giant red flashing thing there.
And I definitely took some damage.
So, what I want to do now is make it so that when I take damage, this turns on for maybe half a second and then turns back off.
So, it's a little bit of a flash.
We could, of course, do something cooler and flashier and fancier, but I think that something simple like this with the code is going to give you a lot of opportunity to just do whatever it is that comes to mind.
So, let's take a look at our player panel and we're going to open up our player panel script and give ourselves a reference to that little hearts panel or this hearts image here.
So, let's go to the player panel.
We'll open the player panel script and right up at the top, let's duplicate line 11 and get rid of the array and let's rename this.
Instead of being hearts, let's call this flash panel something or let's call it flash image.
Make it a little bit more obvious what it is.
So, it's not an array.
Okay, there's only one image.
We could have multiple.
We just have to loop through all of them and turn them on and off.
But I've just got this one here.
So, I'm going to copy it.
Scroll down into our update health part.
And then on line 32, so after 31, we'll add a new line.
I'm going to kick off something called a co- routine.
And this is going to run code over multiple frames.
It's going to allow me to run something now and then do something else in half a second, which turn the sprite on and then turn it back off.
So we'll do that by calling the start co- routine method.
We need an open parenthesis.
Then we need to give it the name of our method.
I'm going to call this flash um image.
Well, let's call flash UI.
No, let's just call this flash.
I think that's good enough.
We'll add our open close parenthesis and a semicolon.
Alt enter and generate a method for it.
The return type of this doesn't want to be string.
It says string by default and it's going to generate that.
But we need to change this to an enumerator.
It's important that you don't get the enumerable which is another one that's easy to autocomplete.
You want I enumerator.
That's what a co- routine must return.
We'll remove the private keyword because we don't need it.
And then if I get rid of this throw, we'll suddenly get an error saying that flash does not return a value because it needs to return an IE numerator.
and it does it in a very weird way.
I'll show you the syntax.
We'll talk a lot more about co- routines as we go on, but you'll get familiar with it really quick.
The first thing that we want to do is update our health image.
So, flash image enabled equals true.
I said update, I meant enable our our flash image.
So, I pasted in my flash image that was already on my clipboard.
Did enabled equals true.
Now, we want to wait for half a second.
And to wait in a co- routine, we do a yield.
So we do y I e l d return and here we need a wait for seconds.
So we have to do a new wait for seconds and then open parenthesis and we want to give it the number of seconds or the amount of time.
If I do 0.5 that'll be half a second and I can add a semicolon, but it's going to give me an error because it only takes a float and 0.5 is a double.
It's a really weird kind of thing if you if you're not familiar with game math.
um and all this stuff.
It's essentially an optimization to make things much much faster.
Uses these floatingoint numbers to go faster and it gets a little bit confused on the type.
So if we put an F here, it'll know, hey, this is a floatingoint number.
It's fine.
Go ahead and use that and don't give me the error.
So that that'll fix the error.
The last thing we want to do is turn the flash image off.
So I'll copy line 27, paste it down here on 39, and put in a false.
Now, it's worth noting that you can save off and cache this wait for seconds object.
It's something that you can um reuse multiple times.
It's another optimization.
I'm not going to dive into that though because it's not something that we need to worry about yet.
And right now, we're focusing on the co- routines and the way they work.
So, we kick off the co- routine after we update health.
Our health UI updates, the correct number of health is there.
We start this co-ine flash, which on the first frame, right when we call it, is going to enable this image.
Then it's going to say, "Hey, now I'm supposed to wait half a second." The game is going to keep running and then half a second later, it'll resume on and run the next code and end it.
If we call this in between, so if we take damage and then we take damage again before this has happened, it's just going to restart and go back up to the top and we won't have to really worry about any problems.
So, let's minimize this.
Go assign our panel, our flash image.
So, I'll take the hearts here.
And actually, I think what I'll do is go into prefab edit mode.
We'll assign the hearts in prefab mode.
So that way it gets assigned on both of our objects.
We'll go back out of the player panel.
Hit save.
And now both of our player panels should have their own hearts object selected.
And then we'll press play.
Let's run over there.
Take some damage and see if we get a nice little flash.
Oh, I should have changed the color of that hearts panel on player two though.
I don't don't think I did that.
So run over here.
Boing.
Take damage.
And you can see got this nice flash appearing.
I can definitely tell that I took some some damage and I'm I'm probably dying.
So, let's stop playing, go into our plastic window, and say that we added a flash co- routine to the take damage interface.
Well, it's really to the take damage user interface.
It's I don't know if I like that commit message, but it's good enough that I understand what it means.
Oh, we need to save our scene.
Let's save the level.
We didn't really need to save our scene because it's prefab in there, but I want to save it anyway because it was starred.
And then we'll check in the changes.
All right.
So, hopefully you're starting to understand how to use these co- routines, by the way, and you can experiment with them a little bit on your own.
Maybe do some other flashing, some other things.
You could flash the the heart that's showing up there or whatever it is that you want.
Make a a slightly different interface for it.
But I think that hopefully you're starting to see some of the benefits of events so that you can get notified when something happens and do something when something happens.
And it doesn't have to be just UI stuff.
We're going to be using events for a lot of other things in the near future.
Now that we have some game data, not a whole lot, but some.
We're going to go through the process of building out our load and save game system.
We'll start with it just dealing with the player and then expand on it so that it can save and load all of the things in our scene later.
But first, we need to take a look at one thing in our workflow.
I'm going to hit play real quick, jump in from the menu, and I'm going to show you an error that you may have already seen, but if you haven't, it's important to see because it's going to be part of our workflow adjustment.
Here, we're going to go to the console tab with with it playing.
I'm going to go into level one.
I'm just going to run over here, jump a couple times, and let this thing kill me so that I can get back to my menu.
in a second.
Now, one more jump.
There we go.
And then I'm not really worried about these two errors right here.
These aren't something that we need to worry about yet.
There's something with the input system.
What I'm worried about is that I just clicked anywhere on the scene and we got an error here saying null reference object not set to an instance of object.
And here it's inside of our player.
So, the reason I care more about this one right now is because it's in our actual code.
These other ones are in the input system and we're going to be dealing with that along the way.
Now, if I click one of the level buttons, you'll see that the game still works even though that error is there.
So, you may be getting this error.
You may have not noticed it or it may just be there and seem like it doesn't matter, but there is something going on.
So, let's take a look at it real quick.
I'm going to open up the code by double clicking on the error and see that it's on line 49.
And here you see that it's trying to access our player canvas.
It's trying to find a player canvas and bind to the player canvas.
And the reason that that's failing is that if we're in our menu, let's die real quick and go back to the menu.
If we're in our menu, there is no player canvas.
So, there's nothing for it to bind to.
So, as soon as I Let's clear the log out.
Soon as I click and add a new player, the player gets created.
It's up here in the menu scene, and it's getting an error because it can't find that canvas.
So, I want to make a change.
I want to make it so that our player input manager doesn't join players in the menu.
And I also want to make it so that our player input manager and our game manager are available in the menu from the start so that we don't have to go into a level and load it because we're eventually going to need our game manager for loading and saving games.
In fact, that's the key reason that we're going to go through this process.
So, let's stop playing and we're going to go find our prefab for the player input and game manager right here and drag it into the menu scene.
I'll save and then we'll switch the join behavior here instead of it being join when a button is pressed to join manually.
I'll save one more time.
Press play.
And now, guess what's going to happen when I click the button and join in? Well, you'll see in a second.
If you if you guessed, cool.
If not, then uh watch.
So I click, nothing happens.
That's good.
Even though I've got the player input manager and game manager here, not getting an error.
But if I click level one and I get in um I've got my player here, that's all good, too.
Then finally, if I try to join in with a new player, though, I can't.
And now the reason that my player one is working and player two can't join in here is that if I look inside of level one, let's stop playing.
Go into our level one scene.
We have a player already placed here.
We have player one already placed in the scene.
So, he's able to spawn.
If I delete this player from my scene and save real quick, I'm going to undo that in a moment.
So, you don't need to do it.
Let's go press play.
And then if I jump in and hit join on level one, you'll see that I don't get a player here.
And the reason for that is that we now have to do our manual player joining.
And you can even see that my camera isn't updating since I don't have a camera.
I'm getting some things from the UI and that's it.
Everything is no longer updating.
I'm no longer getting updates after the the load completed and the old camera unloaded.
So, we need to make a change here.
We need to modify our code so that the player input manager can join players on demand.
And I want to undo that change to level one so that I have a player there placed where it's placed.
So, that's kind of my starting point when I want to just jump in and play on level one.
So, first thing I'm going to do is go to plastic SCM, find level one here that I just modified and changed, and right click on it, and hit undo changes.
That's going to undo the save that I did where I deleted the player.
So, if I go back to level one, I now have a player in it.
Then, I'm going to go back to my menu scene, find my player input in game manager, and what we want to do is modify our code so that join behavior switches to join on button press if we're not inside of the menu.
And we can do that using the game manager script.
So let's open up the game manager and inside of our awake right now we get the player input manager and we register for the onplayer joined event and then we essentially bind up our player whenever a player joins.
So we've got a player input manager here and we're going to need to reference it again to modify its join behavior.
So instead of calling get component a bunch of times or multiple times, what we'll do is cache and save our player input manager.
So, I'm going to add in a new line here right after the right before the dot in the parenthesis.
Add some space here.
And I'm going to say underscore player input manager equals get component player input manager.
So, that's line 20.
I'll hit alt enter and generate a field for it.
Now, we should have a field for our player input manager.
It looks like it went down here.
I'm going to move both of these up to the top because I don't like having my fields down at the bottom right below my static instance.
And let's add one line of space in between them.
And then finally on line 27, or I'll copy line 25, paste it right here in front of 27.
So now we get the player input manager and save it off into a variable that's private.
I'll get rid of that private keyword since it's redundant though.
And then we register for the onplayer joined event.
The final thing that we need to do, let's clean that up, is register to our scene manager to get notified when we load a new level.
Whenever we load a new level, if the level is the menu, we'll set it to manual join mode.
If the level is not the menu, then we'll set it to click join mode or press button press join mode.
So to do that, we need to go down or add an extra line here and reference the scene manager static method or static event which is scene manager.
And notice that it's not autocompleting.
What I can do is hit alt enter and get the using Unity engine scene management statement up at the top.
So I'll hit that.
Go up to the top and you can see that it added using Unity engine.
Management.
You can always just type this out if it doesn't auto add.
This is going to give us access to all of the scene management methods and classes.
And the one that we care about is the static event on here which is the on or no I think it's scene loaded.
That's it.
Not on scene loaded.
It's just called scene loaded.
So, I'll hit enter, let it autocomplete the text or the the casing there.
It's got a weird casing, not the casing I would typically use.
Um, but that's the that's what it's got and we can't change it.
So, it's got scene loaded with a lowercase s and we want to do plus equals because just like on player joined.
This is an event that we're registering for.
Remember, we just did our own event just a moment ago.
Same kind of thing.
We want to register so that something gets called every time a scene gets loaded.
Let's call this handle scene loaded.
We'll hit alt enter and generate a method for it.
It's going to give me a private void method that has an argument arg named arg0 which is the scene that got loaded and then another argument for the load scene mode which will tell us whether the scene was loaded additively or if it was loaded to replace the current scene.
You can do it two different ways.
We haven't talked about additive yet so you can pretty much ignore that for now until we get into it.
Let's delete the private keyword because we don't need it.
And on line 35, what we want to do is check the name of arg0, which is our level name.
So I'll say if argname and here, let's say arg0 dot and you can see all of the different things, the fields or properties that are on the scene object.
So arg0 is a scene.
They just name it arg0 because that's the default when it's autogenerating.
So, we've got the is subscene option, the handle for it, the root count, um, couple other things.
Let's scroll down.
We've got the path, the name, there's a build index somewhere, right there, build index, which is that index in the in the build settings.
You see it starts at a zero.
We want the name though, so we're going to check if the name is equal to, and we want menu with capital M.
It needs to match the scene name.
If it is the menu, then we want to tell the player input manager that it's load or join behavior.
Where's that at? Join behavior is equal to.
And here we want it to be the manual one.
I accidentally did this backwards the first time I did it.
Now, if it's not the menu, we want to do an else, which is going to run if this is not true.
So, if this is true, we'll get line 36.
Otherwise, we'll get whatever's after line 37.
And on line 38, we'll say player input manager jojoin behavior is equal to.
And here we're going to use the button pressed, which is what we had before.
I'll save that off.
Do control shiftb to get a build.
It looks like it succeeded.
And then we'll jump back into Unity and let's see if we're able to go through the entire flow of joining a game, getting through it without that error popping up anymore.
So we press play.
We've got our player input in game manager.
I click a level.
Join.
Looks good.
I can run over here.
Let myself die.
Let's see if it all works.
Notice that that other error message is gone, too, because that was in the player input manager trying to join.
There we go.
I'm in the menu again.
I can click all around.
I can click on my controller here.
Everything looks good.
I can go Let's go into level two.
And we have no more errors.
I can join with the second player once I'm in the level.
And things seem to be working good.
So let's stop playing and go commit our changes into plastic.
So go over here.
We don't have a lot.
Just our game manager and our menu that we fixed player input manager to support running on the menu scene and we'll check in the changes.
Now that we have the game manager in our main menu, we're going to go through the process of setting up a new game button and the ability to load existing games.
First though, let's create the new game button so that we have a UI element that we can hook up to this game manager to kick off a new game.
And then we'll dive into how we're going to structure that data.
So to start, I'm in my menu scene.
I'm going to take my canvas and rename this to level select canvas because that's what it's covering right now is a background and some level select stuff.
I'm going to rename the image to background and then I'm going to select the level select canvas.
So just click on it and duplicate it with control D.
I'm going to select the initial one, the first one that I had and just disable it.
So now I've got this new one here that's just an exact copy of the previous one.
I'm going to rename this to new game canvas.
And then we'll expand it out.
I want to move this level one button or just recreate it and make it into a new game button.
And I'm going to delete the level two button.
So I'm going to go to level two, delete that.
Rename this level one button to new game button.
And then I want to center it kind of let's just do it right in the middle of the screen for now.
And let's make it twice as tall because I want it to be pretty big.
And then let's change the text to say new game.
Now, we could of course just go in and recreate this manually, but I find it a lot easier to just duplicate and go through the process and speed this thing up.
Or well, just not go through and manually recreate all of the buttons every time.
Let's adjust the max size here.
I'm going to put this down to about 150 so that it fits in there pretty good.
I've got my new game button and I think I want to just drag this up just a little bit.
Actually, let's let's dock this to the top here.
Alt.
Oh, sorry.
Got the wrong object selected.
We'll go grab the button.
And I'll just grab the position Y.
Let's just drag it up here.
I'm gonna put it right above that little guy's head.
You can put it wherever you want on your screen.
I just didn't want it covering up this guy's head.
So, we've got our new game button here, and it has a load level button script.
I'm going to remove that component, and we're going to add a new script.
That'll be a new game button.
So, we'll right click in our scripts folder.
Here, I've got the scripts folder selected.
Rightclick, create a new C script.
Let's call this new game button.
Again, no spaces.
Capital NG and B because we're using our Pascal case for class.
We'll open up that new game button.
That didn't open it.
Oh, there it goes.
It opened up.
And in our new game button, what we're going to do is first delete the update method.
And then we're going to register for our button click.
And on a button click, we'll tell our game manager to fire off a new um a new game essentially.
And there are two ways that we can do this.
The first way is let's create a public void method named um start or let's call this uh create new game.
I I like that better.
I don't want to have the word start in there.
And then in here we can call game manager.instance new game.
Now the instance exists but new game does not exist on our game manager.
So we'll click on it, hit alt enter and generate it.
We don't need it to do anything yet.
We just needed this to be our hookup for it.
Know that hey somewhere in that game manager in this new game method will create the new game.
We'll we'll deal with how we do that later.
For now, let's deal with hooking it up.
So I'm going to save.
We'll save our game manager script as well.
In fact, let's go down to that new game method here and write out a log.
We'll say debug.log new game called just so that we know that hey new game was called.
I'm going to make this public as well just because I don't like the internal keyword.
And I'm going to get rid of this private keyword too because I just realized it was there and I don't need it.
And the private keyword is the default.
So it's kind of redundant to have it there.
Let's go back to the new game button.
So we've got this create new game method here.
And we need to hook this up in the editor.
Let me show you two different ways that we can do this though because I think that it's important that you understand that there's one way to do it and then there's a completely different way to do it that you're going to see many many times that might also sometimes be better.
So let's go into Unity.
We'll go find our new game button.
We'll add the new game button component to it.
That was already searched for.
And then in my button script here, if I expand that out, that's the one that was created automatically when I made a button.
We have this on click.
And right now it's got an actual value in here that's missing.
If I hit minus that'll go away and it'll say the list is empty.
The reason that that was missing is because it's referencing an object that's not there anymore.
So what we'll do is hit plus and then I can take my new game button and drag that right in here.
Technically it doesn't actually matter.
I could drag in this button or anything else.
It's really just referencing the game object.
It's referencing this specific thing when you drag that in.
any component will do that cuz then when you hit the no function button, you'll get the popup of all of the components.
So there's the game object, the wctck transform, which is the thing up way up the top, the canvas renderer, the image, and the button, and this new game button.
All of them have things that we can access.
Like I could turn off the game object.
I could game object and say set active and set it to false.
Then when I clicked, it would just turn this game button off.
Let's let's do that real quick.
Let's just hit play, disable this button, and watch that happen any second now.
There we go.
The button turns off.
Not what I want to do, though.
But I can register again anything.
What I want to register instead is new game button and choose the create new game, which was just off screen, of course.
So, let's go try that one more time.
So, new game button and create new game.
Now, this will call the create new game method.
Let's try it out.
Any Any Any second.
Load it up.
Load it up.
We should see it in our console log.
When I click it, new game called.
That worked.
Great.
So, now I want to show you the other way that you can register this so that you don't have to go into the UI and hook these things up kind of more manually, the way that you can do it from code.
So, I'm going to remove this registration.
We're going to go into the new game button script.
And inside of the start, we're going to say get component.
and we're going to get oops I spelled that wrong.
We'll get the button component.
And if that doesn't auto add the using Unity Engineui up at the top, you'll need to go up there and add that or hit alt enter on it.
It just kind of auto added it as soon as I typed it.
You might have noticed that.
And then we want on this button to add a listener to the onclick event.
So it has an on click here.
We type O N with a lowercase O and then do a dot and we can do add listener.
What this will do is allow us to pass in a method that we want to be called whenever they click, just like if we did it in the inspector.
So here I just put in the name of my method, create new game, and add the semicolon.
Oh, I've got to put a W in new.
There we go.
Put a semicolon in.
Save.
Control shiftB.
Do another build.
And now if I jump into Unity, I'm going to get the exact same behavior, but now I don't have to write in these on clicks.
I find that this is really handy if you have a script that's specific for like a button or something else that needs to use a button and is going to register for this so that you don't have to go through that extra process of hooking it up and you don't have to worry about going in and checking it later if that registration gets somehow removed by a designer that's doing something else.
Plus, it's important to note that they can still add in extra clicks here.
So, I can click and get that new game called, but I can also have my designers go add something in here, like maybe they um let's say that when they click it, I'll do something stupid like change the text color.
They select the text and let's find our color.
Where's that at here? There's There's so many things here.
We'll just find the Let's find the alpha.
There we go.
And we'll set the alpha to well, maybe 100.
So we click let's go to there we go.
It's it's zero to one.
So we got a 0.5 or a 0.1.
There we go.
The text alpha went down to 0.1.
I can set it up to a 31 which is just going to be a one.
So you kind of get the idea.
We can add in extra things here without having to worry about them breaking the functionality of that new game button.
All right.
So now that we've got our new game button in, let's save our scene.
Go into plastic and say that we've added that.
and we'll get ready to modify our data structure next.
So, added new game button to main menu and hooked up in code.
We'll check that in.
Now, we're going to dive into our data for our saved game so that we can start saving them.
In our game manager, we've got the new game method that just right now logs out new game called.
We'll leave that in for a moment, but let's think about what needs to happen when we create a new game.
The only data that we have right now for our game is our player datas.
If I hit F12 on it, remember that's a list of player data objects.
And the player data objects right now store the coins and health.
We'll of course store more information with these later.
But these are the two things that we care about right now that we've actually saved off.
So we need to save our player datas into some sort of structure or some sort of format that we can reload later.
And then we need to be able to create a new set of player datas when our player chooses new game.
And what we want to do here is bundle these player datas and all of the future stuff into an object that'll store all of the data for our game.
And we'll call that a game data object.
Let's go to the player data class.
I'm going to control-click on it.
And right below player data, I'm just going to add in a new public class called game data.
We'll add on a list of player datas.
a public list of player data and we'll call this player datas and initialize it to a new list by default.
With that, we'll add the serializable attribute so that we can see it all in the inspector and so that we can serialize it in just a moment.
And then we'll go back over to our game manager.
Our game manager has this list of player datas.
And I want to get rid of this now and replace it with a single game data.
So, we'll get rid of the list of player datas here and just put a game data_ame data.
That's going to give us some errors.
And I find that one of the best ways to figure out what code needs to be changed is to do a control shiftb and do a build and get all of my errors down below.
It'll tell me the spots where the code no longer works because I've deleted something.
It says here the name player datas does not exist and does not exist and does not exist here.
See, it's on line 52, 55, and 57.
But I don't need to care about that.
I can just double click on them to go to them.
So, we don't have our player datas anymore, but we do have a game data that has player datas on it.
So, instead of calling player datas, we'll call underscoreame data data data dot player datas.
So, you see that now we're referencing the player datas on our game data object instead of a list in our game manager.
We'll copy this game data.player player datas, put it on my clipboard with control or command C, and then paste it over these two remaining player datas.
I'll hit control shiftb.
My build is successful, and my data should still work exactly the same as it did before, but now I've got it wrapped into this game data object.
Let's just go verify that real quick.
Make sure that I've built, go into Unity, we'll press play, and we'll hit the new game button.
Oh, the new game button right now doesn't load us into a new game.
So, let's just play.
make sure that we don't have any errors at the very least.
Looks good.
And then let's go hook it up so that our new game button throws us into level one.
We'll go into the new game button.
Go to the new game method with F12.
And right after we call the new game called log message, let's say scene manager.load scene.
And we're going to load level one.
Now, if your scene manager doesn't show up, of course, make sure that you go up here and you got your using Unity Engine.cene management statement there.
This got automatically added.
So, you want to make sure that if it doesn't auto add, you go add it up there at the top so that it turns blue and you don't have an error.
All right.
Now that I've got my load scene, let's just go in and play one more time.
Make sure that our data looks good.
And I get a player that has six points of health and no coins when I start a new game.
Let's check that out.
That's what I expect to see.
So, I load up.
I've got six health.
I can take some damage.
Let's go get a coin real quick.
Got four coins.
Let's go into level two.
Got five health and four coins.
We'll go back into level one.
Five health and four coins.
I should be able to die now.
Let's let ourselves die.
And he says now four.
Boom.
I'm dead.
And now if I hit new game, we come back in.
And well, I've got four health and I've got well actually I've got no health, sorry.
And four coins.
So my new game isn't clearing out or resetting our player data.
And that's our next step.
So let's go into our new game called method.
And right here before we call our load scene, let's say underscore game data equals whoops equals new game data.
So, we're going to be creating a new game data object whenever we call new game, which makes sense, right? We're creating a new game.
We should be creating a new object for that data.
So, let's minimize our editor again.
Try it one more time.
And now, we should expect to see that when we hit new game, we get a fresh character.
But when we kind of bounce between levels, we have our same character data.
So, we hit new game.
We'll go uh grab a coin.
Switch levels.
I'm at six there.
Let's go switch levels again.
We'll go take some damage.
Let's see.
Three.
I'm just going to go into level two again.
We're just going to make sure everything is good.
Looks right.
I've got my three health and my six coins.
And if I go over here and die, we should get right back to the menu.
And then new game gives me a fresh character with no coins and full health.
I can bounce around and I've got the same thing happening.
That's a seven, guys.
A seven looks a lot like a one.
All right, so now we can see that things are working and the new game system is starting to come together.
Next up, we're going to have to figure out how to save and load.
So, let's go into the project or the plastic SCM window.
So, we've set up a new game system.
Um, well, game data and new game system.
Added game data and the new game system is hooked up.
And we'll hit check in changes.
With our game data in place, it's time to dive into saving and talk about how we're going to save data, how we format that data and how we can store it off locally, what we can do with it.
So, let's start by taking a look at our game manager script.
I'm going to go into the game manager and what we're going to do is add a save method.
We'll talk about how this works.
We'll implement it and then we'll dive into the actual data.
Let's go into the scene handle scene loaded and right below our else statement.
Well, two lines below so that it's not included in the else statement.
Let's say save game with an open close parenthesis.
We're going to call a method named save game that we're going to generate right now.
Let's hit alt enter on save game.
Create a new method.
I should get a private void method right here.
I'll delete that private keyword.
Again, it's just redundant.
And then delete that throw exception because we don't want an error.
we want to actually save our game.
So, the first thing that we need to do when we save our game is determine how we're going to serialize the data.
And serializing data is essentially taking data that's in our game or in memory and converting it into some sort of savable format, some sort of text format or a binary format that essentially looks like text.
It's characters that you're just not going to be able to understand.
We're going to start with the JSON format though because it's one of the most popular ones.
It's one that a lot of people are familiar with.
It's extremely easy to understand and debug and it just gets the job done for most things.
So to do that, we're going to use the JSON utility method or the JSON utility class and its convert method.
We'll do this right here on line 45.
And I'm going to say string text, which is going to be our JSON text, equals JSON utility.
You can see it auto completing capital J and a capital U dot to JSON.
And we want to pass in our game data.
Not game manager, but our game data.
Because our game data object is marked as serializable.
If we go to the game data here, it's got that serializable attribute and our player data has a serializable attribute.
The JSON utility should be able to convert this over to a bit of text that's formatted that we can understand and that the computer can understand to reload it later.
Now, let's go down one more line and say debug.log and we'll log out that text.
Let's save.
Go into Unity and see what this does and then take a look at that data in another tool real quick.
So, I'm going to minimize.
We'll press play.
And then as soon as my game starts, we should get our new game called.
And right down here, you can see my log that looks a little bit weird.
It's got some brackets says player datas coins zero health six.
If I select this line, and I just copy this first part right before the debug log, the second line, I don't want that second line.
Just copy this line.
And I'm going to go over and find myself a nice JSON formatter.
Got a whole bunch of JSON formatter options.
I'll go select the first one and I'm going to paste in my JSON data.
JSON, by the way, stands for JavaScript object notation.
It's something that's used a lot in JavaScript code, obviously, but also just in networking, um, sending data across and for storing and saving and serializing data.
So, here's the formatted version of my JSON.
You see that we've got the braces here and this is kind of the outer game data object.
Then underneath it, it has player datas and I can collapse or expand that.
And it's got one player data object.
This right here is the brace for the single player data that I've got that has zero coins and six health.
Let's go in and make some changes to find some more things.
Go maybe get another player in here.
Run over here, get a couple coins, and then I'll even take some damage.
And then we'll load another level.
Let's do that.
So, we'll take some damage or here, let's I'll let myself die.
We'll get to the main menu.
I'm going to clear out my log.
So, I got nothing in here except for my new entry.
There we go.
I've got my player data entry.
I'm going to copy this top line.
We'll go back into Chrome.
Go back to our JSON formatter.
We'll go back and paste this JSON in.
And now you see that I've got my player datas, but I've got two objects underneath it.
my first player and my second player.
And each one has their data.
The first player has eight coins and no health.
The second player has zero coins and six health because this player got himself killed.
This player never picked up any coins.
All right, let's minimize.
And now that we've got our data in the right format, let's talk about how we can save that data out.
So, we're going to go back into our code.
And right here on line 47, we're going to use the player pref system.
We're going to do this as an initial one.
Then we'll talk later about some other ways that you can save data.
But the easiest way, the way that works across just about everything is to use the player prefs set string.
And then we need to give it a name for our game or a name for our data that we're saving off.
So I'm going to call this game one with no spaces right now.
And then we'll add a comma and our parameter that we want to save off, which is our text, which is our just our JSON saved text data.
So, this is going to save all of our game data off onto our system locally.
Let's save.
And it's going to save it all into this game one.
So, every time we save, we're going to be resing over the existing save game.
Let's press play, see what that does and where that data is, and then we'll talk about loading and all of the other things that we need to do for this.
So, let's play.
We get in, we press the button, we've got some saved data, and it still wrote out the same log.
But where did our actual data go? Let's take a look on Windows.
First, let's go to our project settings.
We'll go to edit and we'll find the project settings here and select the player settings.
And we need to make sure that you know your product name.
This should also be what's up at the top, but you've got your company name here and product name.
Don't change them now because we just saved data.
Just copy out your product name and let's open up the registry editor.
If you search for reg, you should find it.
If you're on a Mac, there's slightly different instructions and I'll put the link down there for the instructions, but you can essentially find this data in a folder on a Mac just the same.
So, here I've actually already found it in my registry, but let's just go back here and do a quick search.
So, say you've just opened up your registry.
What you can do is hit find and then put in the name of your project.
Hit find next and you should have your project appear pretty soon.
Now you might see first a couple things about um most recently used applications or something like that.
So let's let it search find our data and then we'll view that data, take a look at it and make sure that you're able to find yours as well.
Again, if you're not on Windows, it's going to be in a different location and that location is going to vary from device to device.
So let's actually let's pull that up while our search is running.
So here we've got there it is the player prefs data.
So you can see on MacOSS it's stored in the library preferences folder in a file named unity company name which is going to be that default company unless you changed it.NameP list and then on Windows it's in our registry.
On Linux it's in this uh folder Windows Store apps and Windows Phone apps.
They're all in totally different places as you can see, but that data is available on the page and we'll link that below.
So here we've got our first thing.
Oh, the most recently used app.
So it's just showing us that we've run Unity with that.
It's it's got that stored off.
So I'm going to hit the button again, search a little bit more.
Now, you can also just browse directly to the location, but I find it's usually just easier to search for it um than to expand it out, especially when I'm explaining it to people.
Having to explain the difference between current user and current machine and all that stuff um and then the weird structures that are relatively arbitrary in the registry seems confusing.
So, we'll let it keep searching and any second now, it should find our project with the um the save game data.
So, any second now, come on.
searching, searching, searching.
And here it is.
So, it found my alien blaster under default company under Unity editor under Unity under What is this? Let's just go.
We'll go collapse it all down real quick.
I just want to make sure that we find it.
We can see it.
So, oh man, this is Oh, here's here's where we can find it.
Let's go select it.
Alien Blaster.
So, you can see the full path to it is actually right up here.
That's the easier way to see it than trying to expand and collapse.
So, what do we have in here? Well, we've got our game.
Oh, where I accidentally renamed it.
I put a space in mine and then resaved it.
So, it has game one.
And if I double click on it, you can see it's got our data here.
Here's the binary version of it or the hex code version of it.
And here's the text.
It's got that player datas, the coin, and the heel stuff.
So, that's where it's saving our stuff.
And now, what we're going to do is save out multiple games and start reloading them.
Let's go back into Unity, though.
I don't need reg edit open anymore.
I don't need to see that.
Just wanted to show where it was.
And then let's figure out how we're going to do our loading next.
Back in the game manager, let's add a load game method now.
So, we're going to go to right below our save game, add a void load game, and we're not going to take any parameters yet.
Instead, what we'll do is call player press.get string.
And we're going to pass in game one.
I fixed my game one so that it no longer has a space.
And we're going to assign that to a string.
So we'll say string text equals player prefs.get string and passing game one.
That's going to give us back this JSON that we just saved out.
Now to convert that JSON into a game data object again, we'll say underscore game data equals JSON utility.
And instead of using two JSON, we'll use from JSON.
We give it the type.
There we go.
it's going to autocomplete and just work.
So, first thing we're giving it here is the type of object that is in the text, which is a game data.
If we put the wrong thing in, it's going to give an error and not be not know what to do.
And we do have to specify it because this method doesn't know from the text what that object type is.
Then, we give it the parameter of the text and it's going to convert that into a game data object.
Now, we need to hook this load game method up.
So, let's make it public.
Save it off.
And then we'll go add a load game button.
So, I've got my new game button.
Let's go open that new game button script.
I'm going to delete out this comment with shift delete.
I don't need that extra comment in there.
And then let's turn these into expression body methods.
And then create a load game button as well.
So, I'm going to go to line nine, hit alt enter, hit to expression body method.
Because it's a oneline method, it just shortens it down.
Doesn't need these braces.
That's all it's doing is saying, "Hey, this method only has one line.
Don't add the braces." Just put it onto one line.
Make it nice and simple.
Do the same for the create game.
And again, you put it right before the right after that first brace, and it'll give you that popup option.
Or you can just manually type out that statement.
So, I've got my new game button, and I want to make a load game.
Let's copy the new game button.
Select it all.
Ctrl + C.
Go down below, paste, and replace the word new with load.
Now, when we load a game button, I don't want to call create new game.
I want to call load game.
So I'm going to rename this method.
To do that I'll hit CT controllr and call this load game.
You can also type on it, hit F2 usually brings up the rename.
Oh, F2 is not my rename button.
You can go up here though and find your rename option in the uh is it in edit now? I don't know where it's moved around.
Just rightclick and hit rename there.
Control-r.
It's different depending on what options you choose when you set up, but that should be the default.
So, we've got our load game button, and I want this to load a game, not call new game.
So, we'll replace the new game part with load game.
And then, finally, we need to move this class to its own file because we can't add it to a game object if it's part of if it's not the first class in the file if it's part of another classes file.
So, we'll hit alt enter, choose move type to load game.cs, which is going to create a new file.
Put that in there.
We'll save it off.
We should have a load game button appear here.
any second.
It should appear as a script down below.
There it is.
And then the final thing we want to do, oh, let's minimize that.
Just popped up on its own, is go to our new game canvas and let's make a new button.
I'll go to the scene view, duplicate the new game button.
Let's move it down a bit.
So, expand out the rec transform.
Just grab this Y value.
I'm just going to keep dragging it until it's somewhere down below that guy's head.
I'll rename it to load game button.
I'll remove the new game button script and then add the load game button script.
Remember, that's going to automatically register for the uh See if I can drag it in here somewhere.
Let's get it to pop on.
There we go.
Right at the bottom.
That's going to automatically register for the on click and call load game.
And then the final thing I want to do here is just change this text.
I don't want it to say new game.
It's not a new game button.
It's load load game one.
Let's just say it like that.
And then maybe shrink the max size of the text down to oh 140.
So it fits in there pretty good.
We'll save.
Let's press play and see if I can save or create a new game.
Make some little data changes and then reload my game.
So here's my new game.
I'll go grab a couple coins.
I'll go take a little damage.
I'll go to five.
Let's go to five.
Four health.
Go.
Five coins.
Four health.
We'll go into another level so that our game saves because remember we save when we load a level or load a scene.
Now let's hit play again and let's watch the logs because there's something important in that last statement that I think you should note.
Oh, let's do it one more time.
So we press play with the logs clear and notice that we also save as soon as we load into the level.
So as soon as I start it up in my game, we're actually rewriting it.
Let's go take a look at that again.
That's this line right here in our handle scene loaded is calling save game even if we load our menu.
So now we're just going to move this save game call so that it only gets called if we're not in the menu.
We can do that by adding some braces for the else.
So add a brace before and after the player input join behaviors changed.
And then move that save game call with Ctrl X and paste it right up here onto line 40.
So now if we load into the menu scene, we won't save.
Let's go back into Unity.
And actually, let's make one more change in the load game.
Let's make sure that we actually go into level one once we've loaded up our data so we can see it.
So, just like we do in new game, we're going to call load scene level one.
I'll copy that line 82.
And we'll paste it right here as 57.
We'll save.
Let's go in, press play.
We should no longer see a load on the initial startup.
And we should be able to save and load our game data.
Let's clear.
We'll press play.
Now, our first game data, if I just load, is going to be a default new value.
So, it's not really going to be useful, but um let's let's just do new game instead.
I feel like that makes it a little bit more clear.
We'll go get a coin.
We'll go take a damage.
And then we'll load a new scene.
We'll go into scene two so that we save our game.
Stop playing.
We'll play again.
And then we'll load our game and watch that data.
So, here's our saved data.
We see we had one coin and five health.
I hit load game.
We've got one coin and five health.
One coin and five health.
Everything is working pretty good.
I'll go up to another level.
I got five coins.
Now we'll press play one more time.
Hit load game.
I expect to see five coins.
There we go.
And if I stop again and I do a new game, I expect to completely wipe that out and have new values.
Let's just go verify that we're not crazy.
Yep, looks good.
No coins and full health.
All right, let's stop playing.
go to plastic is that we added support for a single saved game.
Saved game and we'll check that in and then we'll work on adding support for multiple save games.
To save multiple games, all we really need to do is give our games unique names and then save off the list of unique names that we have for our game so that we can recreate a UI and allow our players to pick which one they want to load.
So, let's start by going into our game manager script.
And when we create a new game, let's give it a new name.
Right here, you'll see in the game data, we create a new game data object.
And here, let's assign a name to it right afterwards.
So, on line 83, we'll add a new new line.
We'll say game data.
Let's see if I can spell that right.
Data.game equals.
And here, I want to use a timestamp.
I'm going to use the current time formatted neatly so that it just shows the date and then the minute and the hour and the seconds.
So to do that we can say date time let's see date time dot now which is a C method to string and then this allows us to pass in some formatting.
If you just do that you're going to get a kind of long string but we can pass in some formatting and choose which type we want.
So there's the general long date.
There's a general short one that kind of cuts out the seconds.
There's a full long date that shows like all of the text.
I'm going to go with the general long date format though because I think that that probably works well for what I want and it's going to look good in my UI.
So, I'm going to add a semicolon there.
Just put that capital G there so it knows how to format.
And then we need to generate our game name property.
So, I'm going to hit alt enter and hit well let's hit generate field.
I don't want it to be a property.
We'll hit F12.
And then we'll go rename re change let's not rename it change this to be public instead of internal.
So now our game data has a game name on it.
Let's go back to the game manager and when we save our game let's save it based on the current game data's name instead of the game one that I've got here.
So instead of saving to game one we'll replace this with our underscoreame data name.
Now, we can't just load_game data.gamename because this object doesn't exist when we're trying to load.
So, we're we're creating it from this.
So, we need to find some other place to save off all of these game names.
And in the save game method seems like a pretty good spot to do it.
So, we'll create a list of all of the game names that we have.
Let's do that up at the top.
Actually, let's create a new list.
I'm going to make this a public list.
So, I think I'll put it right after my public static instance.
public list of string and I'm going to call this all game names and then we'll initialize it to a new list of strings.
Okay, we've got our all game names.
Let's go down into the save game and here let's add our game name to this list of all games.
So say all game names dot add and we'll add our game data.gamen name.
Now, we don't want to add that name if it already is in the list, though, because we could end up adding it multiple times.
So, we're going to add another line here right above it.
I added a couple spaces just to clean things up.
And we'll say if all game namescontains, and then we do an open parenthesis, and we'll put in our game data.game name is equal to false.
And then we'll run this line of code.
That way, if we resave our level multiple times, we don't end up with that game name in the list multiple times.
So, we've got our all game names here.
We need to now save that off into our player preps.
So, I'll add another line here.
Actually, let's just duplicate line 54 with control D.
I'll put in all game names for the key here, this first value with a quotation mark.
So, this be all game names.
And then we'll paste in our all game names.
But if I just do this, it's going to give me an error because set string takes a string, not a list of strings.
So now we need to combine all of these names into one big string or one big piece of text.
And we'll do that with some comma separation.
We could use whatever character we want, but commas are a really common way to separate things.
So we'll use a commaepparated list.
I'm going to go down here and add two new lines.
And I'm gonna say string, commaepparated game names equals string.join.
And this is going to join a bunch of strings and add in a delimiter.
And if I hit tab, you'll see that it's actually knows exactly what I want to do.
Quotation marks around the string or around the comma here.
And then another comma outside the quotation marks and all game names.
This will give me a commaepparated list of my names.
And I'll put that in there for my player preps.
Save that off.
And now every time I create a new game, it's going to add that name into my all game names list.
Now I can't see that.
So I want to add in one more log entry so we can see it every time we maybe restart our game.
Maybe right at the end of awake.
Let's load in our all game name.
So say all game names equals player prefs.get string.
And we'll put in our all game names.
And if I just do it like this, we're going to get that same error.
So remember what the error was and how that happened.
Here's a quick challenge.
See if you can figure out how to convert this string back into a list of strings.
If you're not sure how to do it, do a quick Google search.
Say, how do I separate a comma or convert a commaepparated list of strings back into an actual list of strings or list object of strings in Unity or in C.
If you can't figure it out, don't worry.
I'll show you in just one second.
But I feel like that's a fun and interesting challenge for you to give a try.
So go ahead and try it and let's continue on and go through the answer.
So we've got our strings here and we can't assign it to all game names cuz that's the list.
We want the comma sep.
We want to assign it to a temporary value.
That's the all game names instead or all game names commaepparated.
So I'll say string comm, list is equal to that.
And then all game names will be equal to commaepparated list dot split and we'll split it on that quotation mark.
And then we finally need a dot to list.
What's going to happen is the split will return back an array of game names.
So it'll give us back all of the game names in an array format which is very much like a list but doesn't support adding and removing things.
So then we just call the two list on the array that it gave us and it converts it to a list and assigns it to all game names.
I can save that off.
And the last thing I want to do actually is just log out our commaepparated list.
So let's say debug.log and we'll log out that commaepparated list with semicolon right here.
So we can see all of our game names.
We can't log out a list of strings, but we can log out that nice separated one.
So let's go back into Unity, press play, and I'm going to make a couple new games.
I want to get a couple new games in there.
So, I've got a little bit of data data data and then we'll take a look at what that data looks like and then figure out how we can add our buttons to do the loading.
So, we've got our console here.
I hit new game and I've got a new game created.
Let's hit play.
Stop playing and play again.
And this log entry should no longer be blank.
The first one right here was blank because I had no game saved.
So, there's my first game 217 2023.
And you can see the time stamp.
And if I hit new game again, stop playing, play again, you'll see that.
Oh, what did I I didn't stop playing.
Let's stop playing and play again.
And I should get another one.
That's a couple seconds later.
See that? The one 15 seconds later.
And every new game that I do is going to create a new entry into there.
So, I'm going to have one new game created.
It'll save off my actual game data into the game object and it's going to save off into the game list.
Let's go take a quick look at that registry one more time.
So you can just see what that data looked like.
Got my registry editor here.
And here you can see I've got my all game names.
If I double click on it, I can see the text there.
It's again gets that weird format, but you can see I've got my first one, then my second one starts after that, comma, and the third one starts there.
And the game names are actually right here as well.
So you can see the games are saved off just as a timestamp for their key.
And that's where I can see I can open up any one of these and see the data for that game.
So my games are saving, the data is saving.
My final step now is to build a UI so that I can pick which game I want to load.
Before I do that though, let's go into plastic and commit that we are now saving all game name spot game right game names list to player press and we'll check that in.
Oh, popped up an error.
Let's do it one more time.
It was refreshing that asset.
Hit check in again.
And there it goes.
You see it updated right after there.
We're good though.
So, we'll continue on.
Now, let's build our load level panel.
We're going to go into our new game canvas.
And I think what we'll do is just duplicate it and let's create a load game canvas.
We'll disable that new game canvas temporarily and then expand out the load game canvas.
We can do these as panels, by the way, instead of canvases, but I like separating them out.
It makes it a lot easier to understand what's going on and to figure things out.
and it's easy to adjust back and forth.
And we can get some nice performance benefits from keeping them separate like this.
So, let's take a look at our load game canvas.
We have two buttons on it.
I don't want either one of these buttons really.
I kind of want the load game button.
So, let's delete the new game button.
And let's create a new panel in here.
We'll right click, choose UI, and choose panel.
I'm going to center this so that it's not so um big.
So, it's kind of in the middle.
Let's do a center right here and make it oh 600 wide.
So, I've got this nice centered panel here where I can put all of my buttons.
I'm going to take the load game button and drag it on to be a child of that panel.
I'm going to rename this panel to games list panel.
It's got all of my games, or at least it will.
And then let's go modify our load game button.
So, our load game button here is a little bit taller than I want.
I'm going to shrink it to about 100 high.
And then, let's see.
We've got our load button script.
Let's go turn this into a prefab next.
So, go to the prefabs folder with our load button kind of shrunk down a little bit.
We'll drag our load game button in and make it into a prefab.
Now, we're going to go to this games list panel.
We're going to create a new script for it that's going to use that prefab and instantiate one for every saved game that we have.
To do that, we'll create a new script for our games list panel.
Go to the scripts folder, rightclick, create a new C script, and call this games list panel.
We'll assign that to our games list panel by selecting it, and then just dragging it on.
Ah, my code editor popped up for me.
Nice, but not what I wanted right now.
So, as soon as it finishes, we will collapse that shader down and drag the games list panel right here onto the games list panel in the inspector.
Now, let's open up that script and add a place for our load game button prefab.
I'm going to delete out my start.
Well, let's delete out u let's just start up here.
We'll delete those in a moment.
Maybe we'll start by adding a serialized field.
And this is going to be of a load game button.
And we'll call this button prefab.
Let's call this load game button.
No, let's just call it button prefab.
Keep it nice and short.
There's only one button type that I've got on here.
Now, when we load this object up, maybe when it enables instead of it starts, I want to go through and set up all of the buttons.
So, I will delete the start and update.
We'll select all the way 9 through 19 and delete and add an on enable so that when this thing turns on, that's when we do the loading.
So, that way every time we turn it on, we can get new sets of buttons if we've got new levels loaded.
We don't want to just do it once when we start the game up or when we lo Well, actually, technically, we could probably just do it once when we load the menu up.
So, let's change this to start.
We'll change it back to start instead of on enable.
It'll simplify things.
We won't have to clear up the buttons.
So, we're not going to get any new buttons, new menus or new games until we go back into the menu anyway.
So, we've got our start method here.
And what we want to do is loop through all of the games that we have saved.
So, we want to say for each var game name in game manager.instance doall game names.
Now, this should already be filled out because this is loaded in our awake of the game manager.
If this was in the start of our game manager, this would be a problem because it may or may not be ready.
Since it's in awake and this is in start, not in on enable or awake, we know that all game names will have been filled out before this ever gets called.
That's because awake and on enable get called before start.
So, we're going to loop through each game name and we want some braces here because we're going to do more than one thing.
The first thing we're going to do is instantiate a button for each game.
So say v button equals instantiate which is the method to create an object at runtime.
And we're going to pass in our button prefab.
So this is going to spawn our button prefab on the UI.
But first before we do that, we need to give it one more parameter which is the parent that it's going to have.
And we want the parent to be this game list panel.
So we'll just say transform to pass in our transform.
It really wants not a component object but a transform to be the parent.
So we pass in our own transforms.
Now we've got a button here.
Next thing I want to do is assign the game name to the button.
So we'll say button dot set.
Let's just say game name.
Let's let's make a method.
Set game name.
And we'll pass in our game name.
No, we'll just assign the game name.
Let's do it like that.
Game name equals.
And we'll just assign it as the game name.
Now, we could do both ways.
This will make it so that we're setting the property instead of calling a method.
It's a little bit simpler and there's really not a good benefit in using a method right now.
So, we're going to go with the simpler way.
We'll hit alt enter and we'll generate a property for it.
So, I hit alt or enter right there.
And now, if I hit F12, I should have a public string game name.
So, this is the game name for this button.
Now, oh, you know what? I lied.
I do want to call this set game make a set game name method.
So, let's change this.
We'll call set game name and we'll pass in our game name parameter.
Then we'll hit alt enter and we'll generate a method for that.
I'm going to get rid of that extra spacing there.
Hit F12 and let's go take a look.
So, the reason that I want to do that is because if I just set this game name here, it's not going to update the text.
But if I set the game name as a private thing and then update the text in my set game name method, I'll get a nice UI update.
So, let's delete out line seven here.
And on line 15, let's say underscore game equals game name.
We'll generate a private field for that.
So, now we've got just a private string that can't be read by other things.
And then let's update our text mesh pro.
So, we'll say get component in children tmp_ext.
That's going to be the text object that's a child of this button.
And then we need our open close parenthesis to get the object and dot to reference a property on it or a method.
We want to reference the set text method and pass in our game name.
So now we're saving off the game name in this method, which is why we used a method instead of a field or a property.
And then setting the text here.
Well, that's really why we're using the method instead.
I'm going to change this to be public just so that it matches and get rid of this private keyword that I don't need so that we're consistent.
We'll save.
And now if I go into Unity, I should be able to see my buttons appear.
But there's one thing I want to modify first before we do that.
First, let's uh save this.
Save our games list panel.
And then go back into Unity.
And we're going to add a component to make our buttons stack up.
So, if we go to the games list panel, we can add a layout group.
We can either do a vertical layout group, a grid layout group, or a horizontal layout group.
I'm just going to go with a Let's go with a grid layout group for now.
And we'll set the cell size to 600 grid layout group.
Kind of auto controls the size of all of the buttons and everything.
Makes it really easy to work with.
We'll save.
And then we can delete this load game button that's a child of our games list panel.
Go make sure that our games list panel has the button prefab assigned, which doesn't.
So I've got my games list panel selected.
I'll hit the search button.
See if I can find my asset.
And look at that.
It found it.
If yours can't find it though, you can just go down to the fold.
Oh, it actually found the wrong thing.
So, we're not going to use that.
Don't use the search box cuz I didn't realize it searched in the scene and it found the wrong thing.
So, instead, we want to look at assets and you'll see that it has none.
Let's go down to the prefabs folder, though, and just take the load game button and drag it on.
We don't want to be spawning this disabled one here.
That's not the right object.
We want to be spawning and referencing the one down here in the prefab.
So, select your games list panel, click on the button prefab.
Whoops.
Let's see.
Click on the button prefab, not the script.
and make sure that it's selecting this one right here.
Now, if I save and press play with this canvas up, I expect to see all of my saved games pop up here.
And there they are.
I can click on one of my saved games and load right in.
Let's go over here, maybe take a little bit of damage on the saved game.
What is this? Game two.
The second one there.
I lost track of the time.
We'll force it to save.
Let's stop playing.
Go back in and make sure that we're loading the correct data.
I should see my health be at two when I click on this game right here.
Oh, and I don't.
And the reason for this is pretty simple.
So, I want to leave it as a little challenge at first.
See if you can figure out, taking a look at the load game button, why we're not loading the proper game.
Go ahead and view it.
See if you can figure out what's going on.
And then I'll run you through the solution.
You can build the solution if you want, but if not, don't worry.
I'm going to show you in just a second.
Just go ahead and pause and take a look at it.
it.
it.
Okay.
So hopefully you noticed that what happens is we call load game and we go into our game manager load game method and then we load game one.
Every time we load, we're not actually using the game name of that method or of that button.
So we need to make our load game method take the game name as a parameter.
So first thing I'm going to do is copy our game name and add that as a parameter to my call to load game.
That's going to give me an error saying that no overload for load game takes one argument.
So I'll hit F12 and we'll change that.
We'll add a parameter to load game.
Say string game name.
And then instead of calling get string on game one, we'll call get string on game name.
We'll save that off.
Go into Unity.
And now we should load the proper game.
Oh, we have an error here.
Let's make sure that I've not typed anything.
Do a quick build.
Oh, I didn't build.
That's why my file wasn't saved.
So, it wasn't calling the proper method.
Now that my build is done, it should work.
Let's hit play and then try loading that game again and see if we have our modified health.
So, here we go.
Let's go.
We'll go grab a couple coins.
Make sure that we're save because we weren't actually saving to the correct game.
We were saving to a blank game.
We'll go take some damage.
One, two.
I've got seven coins and two damage.
We'll leave the level.
Load the level.
Press play.
And then reload our game.
And here we go.
We've got our saved data and everything's working right.
So, let's go into plastic and say that we added support for multiple saved games and checkin.
Our saving and loading system should be working pretty well now, but the menu system is a bit of a mess.
So, what we're going to work on now is an update to the menu system so that we can navigate between canvases and even delete our saved games so that we don't end up with a whole bunch of them that we can't manage.
Seems like an important thing to allow our players to do.
So, I'm going to stop playing and we're going to take a look at our canvases.
We've got the new game canvas, which is not on right now.
I'll enable it.
And then we have the load game canvas, which we can't see anymore.
If I want to bring this load game canvas in front of my new game canvas, I can adjust the sort order on the canvas.
Just turning it up to a higher number like one.
But now I can't see my new game canvas anymore.
So what I'm going to do is disable the load game canvas with the sort order set to one.
Then we'll change this load game button so that it enables the load game canvas.
It's pretty simple way to set it up.
We'll expand out the new game canvas and go to the load game button.
And then we'll scroll down and remove the load game button script.
Hit the plus on the on click so that we have a new listener whenever we click this button.
And the target for the thing that we want to run code on when we click the button is the load game canvas object.
So I'm going to drag it right in and then choose from the function list.
We'll choose game object and set active.
What this is going to do is call the set active method on that object which will turn it to either active or deactive.
Right now, it's set to deactive because the checkbox is off.
If I set the checkbox to true here, then when we click this button, this active checkbox right here will turn on and the UI will pop up.
Let's go and test that out.
So, I'll play.
Turn that load game canvas off.
And as soon as I click the load game one here, it should pop up my menu.
There we go.
I see the load game canvas appearing.
I'm going to stop playing now.
and let's add a back button so that we can go back out of load game mode.
To do that, we're going to turn on the load game canvas.
I'm going to go to my load game button here and duplicate it with control or command D.
And then I'm going to drag it down on top of the load game canvas.
Now it appears because it's on this canvas and not the new game canvas.
New game canvas still has its own button.
If I turn off my load game canvas, you can see there's still the button there, but the load game canvas has one as well.
I'm going to select this load game button, and I'm going to put it right up here in the corner by clicking on the recct transform tool, holding alt and shift, and clicking the top left corner.
Now, I also want to shrink this down a little bit cuz it's going to be a back button.
I want it to be a little bit smaller.
Make it maybe a height of 100.
And then rename it to back button right up here.
Just rename and hit enter.
Now, the next thing I want to do is change the text because it says load game one.
So, I'm going to expand out the text here, the child of the back button.
Go select it.
And as long as the text mesh protext is expanded, I should be able to write right in here or type right in here.
And I'm going to put the word back with a capital B.
It's still all in uppercase mode, so it doesn't matter how I case it here.
But I like to case it correctly so that if I decide to change the font, it'll still look right.
Now that I've got my back button, I'm going to go to the back button object again, scroll down, and find the onclick listener.
All I have to do is uncheck this checkbox.
Save my scene and press play and watch what we've got.
Right now, the load game canvas is going to be up by default because I turned it on by default.
But I can go back and turn it off.
And I can go back into the load game menu just by hitting the load game button.
Now, as a last thing to make this a little bit fancier, we could add a little icon here.
Maybe something that shows that we're going back, a back indicator or an arrow.
And to do that, we can just right click on the back button, go to UI, and choose image.
We'll get a new image that's sitting right on top of my sprite.
If I go to the scene view, you can see it right here.
I could drag it over or move it, but I like to use the recct transform tool instead.
So, click the recct transform tool, hold um actually, yeah, alt and shift, and then click the left side.
That's going to move it right over here to the left.
And I just need to pick a sprite for it.
Now, there is a pretty good sprite that we can use already in our pack.
If you just search for sprites and search for the word left, you should see a sign left.
And look at that.
It I think it fits pretty good.
I want to shrink it down just a little bit though.
So, let's adjust the height to be maybe 80 by 80 instead of 100 by 100.
So, it's not going over the edges.
I think that looks pretty good.
So, now I'll just disable the load game canvas.
press play and make sure that we've got the flow that I expect except for I've got the number one after my load game text here.
That's the only thing that I think is an issue.
Let's see.
Go back and forth.
Back buttons looking good.
And I can load into a level.
I'm going to stop playing.
Make sure that I've saved my scene and type in a commit message that we added.
Menu navigation to load game canvas and check it in.
Now, we're going to give the player the ability to delete their saved games.
We're going to go into our load game canvas and enable it and then go find our prefab for our games.
So, we've got our load game button right here.
Just double click on it and open that prefab.
What I want to do is add a little button to the right of our load game button that is like an X or delete game or something like that that the player can click on.
Maybe we'll give them a confirmation later and then they can delete that game so that it doesn't show up anymore and we don't have a giant list of saved games.
Should be pretty easy to accomplish.
What we need to do first is rightclick on our button and choose UI and then choose button again.
We want this text mesh pro button right here.
And it's going to add a new button right on top of our existing one that looks kind of ugly.
I'm going to call this delete.
Let's see if I can spell that right.
Delete button.
and then I'll move it over to the right.
If you didn't name it over here, you can always rename it right here.
Let's go to the rect transform tool.
I'll hold alt and shift and click to the right.
I'm going to adjust the size to be 100x 100 so that it matches with my button.
Then move the position X over 100 more, the exact size of my width so that it lines up perfectly and I've got this button just off to the right.
Now, I want to change the color of this to be red since it's my delete button.
And then change the text as well.
I'm going to scroll down.
Oh, actually no.
I need to go over to the delete button, select the text, and then change our font asset right here.
So, here we're going to choose, we could go with uh the bangers one or something else.
I think I'm going to go with Robbo this time, though.
I'll choose the surf.
Let's go with the drop shadow and a white.
I'm going to change the text to be a big capital X and then click the auto size.
So now I've got this big X right here that I can click to delete a game.
Next thing I need to do is hook up the delete game button though so that it actually does something.
To do that, we'll go up to the load game button.
And on our load game button script, we're going to add in a new method.
One that'll allow us to delete a game.
That way our delete button can just reference this and we don't have to write a whole bunch of extra code, add a bunch of extra scripts or anything like that.
So keep it nice and simple and accomplish the task.
So, we'll open up our load game button and right below our load game method, let's add a public void delete game.
This will call into our game manager.
So, we use the game manager.instance just like we do with load game.
And let's call delete game.
Pass in our game name.
And we don't need a true or any other parameter like it tried to give me.
So, this should be good.
We've got a delete game method that'll call into our game manager, our current one, the instance of it, and tell it to delete the game.
Now, delete game doesn't exist, so it's got a red underline.
I'll hit alt enter and just generate a method for it.
And I'll completely ignore that method for now.
I'm going to hit control shiftb so that all of my files build.
If you don't do that and you just save this, your game manager file might not save and you may still have a build error as soon as you jump over there.
So, make sure that you saved your game manager and your load game button at the very least or you do a build with control shiftB or whatever your hotkey is.
Now, I'll jump back into Unity and we'll go to the delete button.
Scroll down.
It has nothing in its onclick listener.
I'll hit the plus button.
We'll drag our load game button, the parent into the target.
So, this none object right here.
And then for our function, we'll choose load game button.
And we're going to choose the delete game right down here on the bottom.
Now, if I go back, save my changes, I should now expect to see that my buttons appear with a little red X next to them.
And when I click them, it deletes the but the game.
Let's press play and see if that's the case.
So, we play.
I've got my buttons here.
Let's go back real quick.
Go back to load game.
Yep, still got my buttons here.
I'm going to hit X and get rid of this uh 115616 one.
I click it and well, look at what I get.
method or operation is not implemented game manager delete game.
So if I double click on this see that oh yeah we haven't actually implemented the delete game method and that's what this does the throw not implemented exception it just gives you that error saying hey this method hasn't been implemented which just means that you need to go do it and it's really just kind of a warning or notice to the developer hey you um haven't done this yet you autogenerated it and you forgot to get to it.
So instead of doing nothing, it gives you some warning to let you know there's some development probably needed here.
So we need to delete our game.
To delete our game, we just need to call player prefs.delete key and pass in our game name.
And then we also need to delete our game name from our all games list and save that.
So we'll say all game names do remove.
This is how we remove something from a list.
And we'll pass in our game name.
And then finally, we'll save our all game names list.
So to do that, let's go up, scroll up to the part where we save game names, which is right here.
So on 59, 61, and 63, we're saving the game names.
62, we're actually saving the game data.
So let's move this up a little bit.
I'll select line 62, hit control X or command X, and I'm going to move it right up here.
Um, right, let's do it right above line 56.
So we'll add a new 56 that saves the game.
Then all of this code below will be for dealing with the game names list.
And these three lines here, 61, 63, and 65 are what I need to save all of the game names.
So I'm going to delete out 62 and 63 now just to clear it up.
Get rid of some extra spacing.
Copy these lines 61 through 63 that save the game names.
Creates the commaepparated list from that list and then saves off that list.
We'll scroll down and paste it into delete game.
Save my file.
And now if I go into Unity and I delete a game from here, you're going to see that the game will get deleted, but my UI isn't actually going to update.
So, let's try it out.
Let's see what what that's like.
So, I go in, I hit the X button, and I think the game is gone.
It didn't show an error here.
And if I stop playing, or let's see, if I go back and back, nothing happens.
But if I stop playing and play again, I should see that that game has disappeared.
And the reason that it's still in the UI is that we haven't done anything to remove it from the UI.
So, we need to have a way to make our UI update with our games.
And that's what we'll do in the next section.
For now, though, we're going to go into plastic and commit our load game deletion.
So, say added a delete option to the load game button.
And first, I want to make sure that I've saved my scene here as well.
get all my changes in and check in.
in.
in.
This lesson is going to be a little challenge.
What I want you to do is finish up the functionality of this button.
Make it so that when I click the X, our game gets deleted and the UI element is gone.
If I go back and I go load game, you see that it's still gone.
I come back in, press play, I expect that element to still be gone or that saved game to still be gone.
So, what I want you to do is just recreate that so that you can delete them.
And if you end up with a situation where you delete all of them and have nothing left, but then you press play and you get a blank entry, don't worry about that.
We'll talk about that in a moment.
First, just worry about getting the X to work so that it actually removes it.
And what I want you to think about when you're doing this challenge is simplicity.
There are a lot of ways to do this.
There are many, many different options for ways that you could set this up.
And you can get extremely complicated or extremely simple.
I generally recommend that you air on the side of extremely simple until complicated stuff is needed.
So go ahead and give it a try.
Pause the video and then in a moment when you're ready, unpause.
And I'll show you the solution that's I think the simplest and what you should go for in this scenario at least.
All right, let's stop playing and well, we don't even need to stop playing.
Let's go take a look at how we've actually solved this.
It's very, very simple, like I said.
And if you looked down below, you may have cheated and already seen the answer.
But all we really need to do is call the destroy method on our game object.
Right after we delete our game in the delete game method of our load game button, remember this is on that button that's placed that we want to remove.
We call destroy.
It'll remove itself.
The layout group is going to automatically adjust.
Now, there are lots of other ways that you could do this.
Again, I recommend staying with the simplest until you need something else.
So calling destroy, not having a whole big system for managing and updating those makes a lot of sense.
They only get added when we hit the or when when we load in and we've got some saved games already and then they'll get removed later.
The next thing I want to do is give our players the safety of a quick confirmation so that when they click the delete, their game doesn't instantly get deleted, but they have to click one more time, maybe in a slightly different spot to make sure that they don't accidentally go, "Hey, I'm trying to load my game and ah whoops.
I clicked and deleted it.
So, let's do that by going into our button.
We'll find our load game button prefab.
Open it up in prefab edit mode by double clicking the prefab.
And then let's find this delete button.
We've got delete.
And what I want to have is a delete that pops up a confirm and a cancel.
And then have this button do like the actual or this functionality here be the actual delete functionality on the final button.
So, I'm going to duplicate this delete button.
I'm going to call this confirm delete.
And I'm going to move it over to the right 100 pixels.
So let's go to 200 on the position X.
And then we'll expand out the text and change the text from saying just an X to confirm delete.
I think that looks good.
It's very obvious what we're doing here.
Now I'll go back to my delete button and I'm going to remove this on click thing.
Instead of it updating or calling delete game on our load game button, we're going to call enable on our confirm delete button.
So, I'm going to take the confirm delete button, drag it over the load game button, find the game object, and choose set active.
We'll set that to true so that we can enable this button whenever we click the X.
Now, I also need a way to go back like a cancel or a um disable or deconfirm.
I guess it would be just cancel, I think, would be it.
Let's let's duplicate our delete button again.
We'll call this cancel button.
And then we'll change the text.
Well, first let's change the color.
Let's make it like a gray.
And then let's change the text to say cancel.
And then the final thing we need to do is go to this cancel button and then make it set the confirm delete.
Uh well, actually, what do I want it to do? If I cancel, it should set confirm delete to not enabled and it should set itself to not enabled so that it hides both of these buttons.
I guess we also need to go back into the delete button and make it show the cancel button.
So, we'll go to the delete button, hit plus, and we'll drag the cancel button into the target for the second one.
Choose game object and set active and set it to true.
Now, the last thing I need to do is go find these two buttons, confirm and cancel.
I'll hit control and select them both and uncheck them.
That should disable them both.
If I go back out of prefab edit mode and let it save, I should now have the functionality that I expect.
Let's go test it out and debug and make sure that didn't mess anything up or miss a reference or anything.
Still got to get rid of this blank game when there's no game.
But for now, let's go create a new game.
I'll just run over here and let it kill me to I really need to add a quick die shortcut so that we can do this faster next time.
Let's let it kill us though.
And we've got our new game.
I'm going to hit the X.
And there's a cancel and a confirm.
I'll hit cancel.
It doesn't go away.
So now if I accidentally click this, I'm pretty safe.
I've got to click this and then go over here and hit confirm delete to get rid of the game.
There we go.
I've got my confirmation.
So I'll stop playing.
go into plastic and say that we added delete confirmation to saved games and check them in.
Now, if you're wondering how to get rid of this blank game that keeps showing up when you don't have any saved games, then you're in luck because in this section, we're going to dive into debugging it, seeing what's causing that, and going through the process of actually tracking down the cause and solving it.
So here you can see that blank game that only appears if by the way if I have no other saved games.
So let's stop playing play again with it deleted.
Make sure that it's gone and that I'm correct in that assumption in my observation.
And if I delete this one, come back in and press play again.
I expect that that bad game is going to show up again.
Let's check it out.
See if that's the truth.
Yep, there it is.
And then let's talk about how we can track this down.
If I look at my games list panel, see I've got that one load game button right here.
It obviously has no game name because I don't have a saved game there.
If I stop playing, that should disappear.
It's not a placed prefab that's already there or anything.
And all we really have to look at is our games list panel cuz that's the thing that's on here that's dealing with our load game button.
So, let's take a look at that script and then see how we can use some debugging to track down the cause.
I'm going to open up the games list panel.
And right here, we've got our only method.
In the start of this method, we loop through all of our game names.
We instantiate a button for each game.
And that's it.
So, what's happening here? Well, what we can do, we could guess and try to figure it out.
I already know the answer, so guessing probably isn't that helpful.
And if you don't know the answer, guessing is usually wrong.
So, what we can do is guess or test and verify.
So to test and verify in our code editor, I'm using Visual Studio right now.
You can do this in Writer or just about any code editor, you'll click over here to the left and add a breakpoint.
Right here on this bar is the break points area.
And on any line of code that's an actual executable line of code, or even on some of these where it's a brace at the end of the brace, I can add a breakpoint where my code editor will stop execution and show me a bunch of information about what's going on.
To make that happen though, I need to attach.
And let's shrink this window down just a little bit.
You can see what happens at the top.
To attach, I just hit the F5 key, which I actually have a uh a little Star Wars speeder on just to make it nice and easy for me to hit all the time cuz I hit that key all the time.
And then once it's done attaching, it should look like this.
I have a pause button and a red stop button.
I'll go back into Unity.
And now I press play.
And what should happen, assuming everything works right, is it will kick me back over to the code editor as soon as this buttons or as soon as this panel's start method calls.
There it goes.
It worked.
Now, sometimes things break and it'll just sit there and hang forever.
If that happens, you need to come back into Visual Studio, hit stop, and probably restart Unity and restart your code editor.
Occasionally, it gets bugged out, freezes, and just stops working.
Um, this happens with just about every code editor.
happens with every ed engine I've used as well.
So, just be aware of that.
If it doesn't kind of pop back over quickly or you can't hit play, make sure that you hit that stop button.
Maybe even close the debugger.
Sometimes debugging just causes issues.
But this time it worked perfectly.
So, let's take a look.
You can see here that I'm looping through my game names and it definitely found one because it stopped on line 13.
It's showing me right here.
The yellow is the next line of code that it's ready to execute.
It stopped right before it executed it because I put the break point there.
And it wants to instantiate a button.
And then it wants to on the next line, if I put my mouse over the game name, I can see it's got a game name of blank.
So, it would set it to a blank game name.
That leads me to believe, yep, this game name right here is blank.
And I'm guessing if I mouse over the all game names thing, here you go.
You can see it says there's a count of one.
There's one game in here.
And if I expand it out, the entry in zero.
So the first entry in our index or the first entry in our list or array.
I think it's a list here that we have at index zero is completely blank.
So we have a blank game name in there.
So now I got to think like well well how do I have a blank game name? That's I mean that's good to know but that doesn't help me solve the problem.
I need to figure out why my game name is blank.
So the next thing I'll do is just um remove this break point and hit F5 so that it continues on execution.
and it'll just let the game finish loading.
And then I'm going to stop playing cuz that was interesting, but it wasn't helpful enough.
I want to find out what's filling out all game names and what's breaking that.
So, I'll go to my all game names in my game list panel, and I'm going to hit shift F12 or rightclick and choose the find all references right here.
My hotkey for shift F12.
Yours could theoretically be something different.
I'm going to drag it up here.
And you can see down in the bottom right, I've got all of the references to my all game names.
Most of them are in game manager except for this one in the games list panel.
So, where's the part where we set or add things? Well, we've got one where we add right here um and double click on it in the save game.
But that's probably not where things are breaking is my guess.
We can add a breakpoint here though if we want.
So, just go over here, add a breakpoint so we'll be ready to check it.
There's also a spot right here where we assign it all game names equals something.
So, let's add a breakpoint there as well.
I'm still in debug mode.
So, I'll go back into Unity and we'll press play and I expect to get a break point or have it stop at that break point.
Pop open the code editor and let me track down the problem.
So, here we go.
Now, we're in the let's see, let's minimize these bottom windows real quick.
We are in the awake method.
We've got our commaepparated list from player press get all names.
And you can see that oh, our commaepparated list is blank.
So, we've got nothing.
We log that out and then we get all game names by calling split on this.
Let's hit F10.
F10 will step us ahead one one line.
So, it's essentially going to run this line and go to the next line.
I hit and here we are.
I can look at my all game names.
Now, if I put my mouse over it, I can expand it out and see that oh yeah, it gave me a blank one.
And it's giving me a blank one.
It looks like because the split or the list that I'm splitting is blank.
So, because I'm giving it an empty string, it's giving me an empty game name.
So, I've got a couple options here.
First thing I want to do, though, is stop debugging.
So, I'm going to hit this little red square so that I can start adding code.
It can't really change the code while I'm debugging.
So, I'll stop that.
And I'm going to remove my break point there because I don't want it to stop there anymore.
Now, there are a lot of ways that we can fix this, but I think that the easiest way is to just remove any blank game.
So, we can just say all game names.
remove and we'll just remove any blank entry.
Now, if there are multiple blank entries, that's not going to catch it.
But we don't have a scenario where we get multiple blank entries.
And I don't expect that to be the case.
We're only getting the blank entry because the commaepparated list could be empty or null.
So, we've got to deal with it here.
But, we shouldn't have to deal with multiple in there.
And we probably don't need to make the code any more complicated than that.
We should be able to save, go back into Unity, and see that we no longer get a blank game if we have no games.
Let's check that out.
So, I press play.
We're no longer attached.
Make sure that you've hit that little red stop button so you're not getting broken or paused.
And look at that.
No blank game entry.
If I hit new game, come back in.
I expect my game to be there.
But I'll not get that blank um null entry anymore.
Just double check that.
Yep, looks good.
Confirm my delete.
Press play.
Play one more time.
I should expect to see no bad new entries there.
Look at that.
And there we go.
So again, one of the key things here is just to make sure that you attach.
You hit F5, add your break points at the spots where you want to break.
Here I actually need to remove this extra break point.
And if things break, just hit the stop button.
Consider um restarting the code editor, Visual Studio or Writer, whatever you're using.
Or restarting Unity.
Sometimes things break, they bug out, and it just gets frozen.
Remember, your game will stop execution.
And you can use F10 to step over things.
And you can also use F11 to step into methods.
We haven't talked about that yet, but we might dive into that later.
All right, for now I'm going to go back into Unity, go to my plastic window, and we'll update our game manager or say that we've updated our game manager to fix the empty games.
So, fixed empty game showing up in the game list.
Before we dive back into gameplay, I want to finish cleaning up our menu system just a little bit.
We've got our load game canvas here.
And right now it's on by default.
I want to turn that off by default.
But before I do that, I want to make a change to the background so that we can tell pretty obviously that we're on a different scene or a different canvas and just kind of add some different visual feel.
And there are a couple different options that we've got here.
The first is that you could just grab another background like the one that I've got down below.
You should be able to grab that background, pull it in, and import it and have it look just like this.
Let's go select that background and assign it.
So, I've got my background under the load game canvas and I should just be able to drag in this background object.
This background, well, it's a sprite or texture.
Let's go select the texture.
So, you can see the default settings that I've got here.
It's as a sprite and it's just set to all of the the normal standard defaults.
Now, if I go back and forth between my scenes, I should see a pretty good visual notification or distinction.
It's going to be pretty obvious that I'm on a totally separate menu.
New game is different.
Load game.
Okay.
Yeah, totally very, very different.
Now, this works good.
It looks great, I think.
I mean, I kind of like the art here, but there are some things to remember and think about if you're building out a bigger game and you want to target a mobile platform or something, you do need to start kind of being a little bit conscious about the size of the the textures and files that you're using here.
Here, these ones aren't too huge.
They're about 1 megabyte, but depending on your game, you could end up pulling in some 4K textures here that are a lot bigger or something else that's even even crazier.
Um, and you're going to want to think about that in terms of memory size.
When you start building out a game for different platforms, the more memory that you use, the more likely you are to run into problems.
Now, if you're on not on mobile, you're just targeting desktops and you're just targeting um well, really, if you're just targeting desktop, you're probably totally fine.
Don't need to worry about it at all.
But if you're targeting mobile devices or you're targeting consoles, you do have to pay some attention to this stuff.
You don't have to worry about it too much when it comes to your menu things cuz it's pretty easy to change them out later.
So, my general recommendation is go with something pretty and nice.
And then when you get to the point where you're like, "Oh, I need to start saving some memory or some space for textures and I need to start deleting out some of these bigger images because I want to put in some characters and this kind of is a trade-off for my budget." Then you can do something like this.
Go to your background and instead of using this big image, we could go find something like a brick.
Change it over to tiled mode.
And now I've got like this brick wall background might work just fine as well.
So I'm gonna leave mine as a brick wall background for now.
I'm going to disable the load game canvas and then I'm going to go to my new game canvas and fix that text there that says load game one because that has been driving me a little bit crazy.
Um so I've got new game or load game.
Let's say h should I just say new and load? Uh we'll just leave the word game in there for now I think.
Let's see.
Is there anything else that I wanted to change on my canvases? I don't think so, but I'm going to double check.
Nope.
I think it looks good.
So, we'll save.
We'll go back into plastic and say that we cleaned up the canvas.
I don't know why this uh this material keeps trying to check out.
I'm just going to let it change.
I don't know what the change actually was.
So, let's do a diff real quick.
We'll right click, hit diff.
I'm going to guess.
Yeah, there are uh find differences.
Interesting.
something changed on it and I'm not sure what.
So, I'm just going to let it commit.
We've got a updated main menu.
So, now it should have a perfect normal flow and we can get back into gameplay development.
Now, we want to add a lot more functionality to our game, and I want to make sure that we can do that without really messing with your levels so that you can start doing some level design and building things when you're getting some spare time and having fun, but still experiment with and have a place to build out our new things.
This is exactly what we do in a normal AAA environment.
We have some sort of development environment set up where our designers and code teams can go play around with things and make their own stuff.
In just about every game I've ever worked on, there are special levels set up for the designers to do exactly that.
Sometimes each designer will have their own level, and some MMOs, some designers have their own zones where they just build out all their own stuff.
And sometimes it's just a shared one.
In this case, we're just going to build a sandbox where we can experiment, build things, put things together, and try out our stuff without modifying levels and without having to put things into our existing levels.
So, we're going to start by just taking level one and duplicating it or saving it off as a sandbox level and then building upon that.
So, we'll go into level one.
I've just doubleclicked and opened it up.
We'll go file, save as, and I want to make sure that I'm in my scenes folder.
And I'm going to call this sandbox with a capital S and a lowercase B, just all one word.
Now, I want to clear this out a little bit.
There's a lot of stuff in here that I don't want to have just by default.
I want to start it off with just platforms because that's what I'm going to work on.
So, I'm going to find the flag, the spikes, delete all of those.
I do want to keep my player input manager.
I don't need these coins, so I'm going to delete them.
And the same with the springs.
I don't need those either.
I'm going to go down to my environment.
I do want to keep most of the environment, primarily the platforms, though.
That's the part that I care about.
So, I'm going to make a new subfolder here or a new folder in my root, which is just an empty game object.
And I'm going to call this platforms.
I'll right click on the transform and reset it so that it's all zeroed out.
And I'm just going to take the platforms, one of each.
So I've got a two, a four, a six, and a five.
And I'm going to drag them onto my platforms object.
I'm going to rightclick or actually let's go over to the transform.
We'll right click and reset their positions and transforms and all that.
So right click and reset their transform essentially.
And then we're going to go to the position Y.
And I'm going to use a special function.
So with all of these selected, I'm going to put L and then an open parenthesis.
And I'm going to put a let's start with zero and then a comma and a 10.
What this is going to do is linearly split them out or space them so that they're from 0 to 10 m up.
Now, if I look at the position here, I see that that's actually giving me some kind of odd numbers.
getting like 33 um 66 and 0 and 10, which is what I should expect, but that's not really what I want cuz I want these to be more rounded numbers.
So, instead, I'm going to do it again, but this time I'll pick a number that's divisible by 4.
So, I'll go maybe 0 to 12.
So, do L 0, 12.
And now I should get nice whole numbers.
So, I've got a 12, a 4, an 8, and a zero.
And now that's nicely lined up, and I should be able to jump up those.
But let's make it so that they're split off to the right as well.
So, select them all and for the X position, we'll do an L.
And we'll just go zero, comma, and let's do maybe 12 again.
There we go.
Now, I've got some split out little platforms that I should be able to jump up.
Let's save our sandbox scene.
I want to press play.
Just make sure that everything is working before we add any new functionality.
Make sure that we don't have any errors.
Nothing's popping up in the console.
Just this serializ thing.
We can ignore that.
But no regular errors.
I can jump up and I can make it up onto my platforms and kind of test these all out.
So now I've got a spot where I can test out all of my different platforms.
Let's stop playing and create the new platform that I want to make.
Actually, let's commit our sandbox level first and then we'll do it in the next section.
So go into plastic and say that we added a new sandbox level for experimenting and testing and we'll check that in.
Now, we're going to create a new platform.
I want to start with a one-way platform.
It's an easy one to use and something that's really popular in platformer games.
So, to create a one-way platform, we'll just take one of our existing platforms.
I think I want the four wide.
Let's find that grass four wide.
And I'm going to duplicate it.
Sorl D.
I've got a second one.
And I'm just going to move it right down here kind of next to my player.
So, it looks like it's at a about a - 7 and a zero.
I'm going to rename this to one way grass platform 4.
It's going to be four wide and one way.
And then we're going to add in a newer.
So I'll collapse my sprite renderer and box collider temporarily.
We'll hit add component and we want to find this platformector.
If you search forector, you should see there are quite a few different types.
We've already added a buoyancy and now we're going with the platform one.
So add the platformector and you can expand it out and see that it's got a couple options.
It's got a one-way option, which is what we want.
And it has a rotational offset for having different tilts and different ways that you can get in through the platform.
But for now, we're going to leave it at the defaults.
And then zoom in a little bit.
If I look right now and press play, I should not be able to jump through this platform.
It's not going to work by default.
And you can see right here why there's a little warning saying theector will not function until there is at least one enabled 2D collider with used byector enabled.
So, I'm going to find the box collider and we'll hit used byector.
Now, if I jump up in through the middle, I can land on the platform and it looks pretty cool.
But, there are still some issues.
If I jump on the sides, my head hits on either side.
And I don't like that it looks the same as the other platforms.
So, we're going to make two more changes.
Let's stop playing because if I change anything else while we're running, it's not going to save.
Notice that used byector option is no longer there.
So, I'm going to stop playing.
Check the used byector.
And now look at that.
We can see the arc.
And then let's deal with the corners.
Why can't we jump up through the corners? That's because the other corners are done with separate colliders.
We have a polygon collider for the right and the left.
And while this is nice and gives us the little bit of rounding that we have there.
We don't need it for these one-way platforms.
There's absolutely no benefit.
There's just a downside.
There are two ways that we can fix this.
One thing we could do is add a composite collider.
When we do that, we'll have to add a rigid body, set it to static, and then it gets quite a bit more complicated.
Or we could alternatively uncheck autotiling, set the size here to be four.
So now that it lines up exactly.
If I set this to like a five, you can see how it goes over the edges.
Get the little It's very difficult to see with the green on.
Let's go into platform edit mode.
Actually, let's turn this into a prefab first.
We'll set it to four and then we'll turn it into a prefab so we can view this in prefab edit mode and then see it I think a little bit better.
So I'm going to go to the prefabs folder.
We'll take our oneway grass platform and I'm going to drag this in so that we have the the bigger icon mode.
It makes it easier to find a white space to drop onto.
Then I'll drag my oneway grass platform down here and I'll hit original prefab.
And now I've got my oneway grass as a prefab.
I'll double click on it to open up in prefab edit mode.
Double click again.
And now if I go and modify that collider.
So I take the size here, this X, and drag it up.
You should be able to see.
Okay.
Yeah, it's covering the edges at four.
It's actually right at the edge.
So I'll put it at four.
And then we just need to go down and make sure that we've removed the colliders from the two children.
Don't need those on here anymore.
The two polygon colliders from the left and the right because now this parent one is doing it.
We're not using autotiling, but that's totally fine because this platform is the size that it is and it's not going to change.
We'll go back, save, press play.
And now I should be able to jump through on both of the sides.
Let's verify that.
And then let's shrink this thing down so that it looks visibly different.
So run over here, jump up, and look at that.
I've got a nice one-way platform that I can go through on the sides and anywhere else.
I have to jump all the way up to the top of it, though, to make it through.
So let's stop playing and do the final part, which is the visual change.
I'll go back into prefab edit mode.
We'll hit that little arrow there.
And then let's shrink this down.
Instead of using the fullsized grass sprite, let's use the half one.
So I click on it.
It should show me the sprites down here.
And then I'll find the grass half mid and drag it in.
We'll go find the two children.
So we got grass half left.
Oh, this is right.
I've got the wrong one selected.
Let's go drag in half right.
And then for our left, we'll drag in half left.
Now there's one issue left, which is that my collider no longer matches up.
My collider is now bigger than my sprites.
I'm not using autotiling.
So, I need to modify the size of this.
First thing we'll do is set the size to half what it was.
So, instead of one, we'll go to 0.5.
And then we need to move it up.
Now, the amount we want to move it up, we could kind of figure it out by dragging it up and down.
But if you just think through the math, it's probably about half of five or.25.
There we go.
That looks pretty good.
I've got my collider right.
Remember, it doesn't matter exactly where that bottom is cuz I'm jumping up through it.
So, I think this will work.
Let's go back, save, and then let's find this platform.
And I want to just duplicate it one, two, three times.
Go select it.
But I need to make sure that this is collapsed.
So, when I do this selection, if I select it like this, and I put in my values that I want, L um 0, 12.
It's going to split out those children, too.
So, the children will get messed up.
And you can see those children right here are not in the correct place.
In fact, they're way up here, way, way, way above.
So, I need to make sure that when I do that, let's hit control-z and undo.
I collapse this one here.
Select just the parents.
And then I'm going to put in L 0, 12, and got to put my closing parenthesis.
And there we go.
Now, I've got four platforms stacked up neatly, and I should be able to just keep jumping up through them.
Let's press play, run over there, and do my jumps and see if I get all the way up to the top.
Whoops, I missed that one.
Didn't Didn't hold my jump long enough.
And it seems to be working.
So, I've got oneway platforms in and working.
I'll save my sandboxing.
Oh, got to stop playing.
Save my sandboxing.
Go to plastic and say that we added oneway grass platforms.
We can, of course, add more one-way platforms.
We just have to modify this prefab for our different sizes and different textures.
Let's hit check in, though.
Our next platform type is going to be a moving platform.
Something that the player can land on and move along with.
To get started, I want to use maybe these planet platforms.
I think that these look different enough and will be an indicator that this platform is going to move.
You could use whatever you want, but I think that this one kind of fits well with what I'm thinking.
So, I'm going to start by dragging a planet mid right out onto platforms and creating a new platform from scratch.
I'll name this moving platform six.
I'm going to make it six units wide.
I'm going to move it over here to the right holding control so that I get that quarter by quarter snapping.
And move it over to oh, let's just type in maybe an 11.
There we go.
And then I'll scale it up.
So to do that, I'm going to change the draw mode again from simple to tiled just like we did before.
And since I want this to be six wide and I want to have end pieces on it, I'm going to set a width of four.
Now, it does say that the tiling might not be right because it's not set to full wreck.
So, I'm just going to go set it to full wrecked on all three of the ones that I'm using.
I know it's not an issue, but I'm going to set it anyway.
Let's go find it right here instead of tight full wreck.
Just got to find the right drop down.
And then that should get rid of that little warning.
And I can add in my right and left.
So, I'll take the right drag it on to be a child of the moving platform.
Did it drop on? Nope.
Let's try that one more time.
I drag.
Let's try drag it and drop it.
There we go.
Got it in the right spot.
Now, notice that it's right here in the middle though.
It's at 0 0.
It says -1, but that's because it's offset from this thing's positive 11.
I'm just going to take this planet right, hold control, and drag it over so that it gets right into place.
It looks like at about 2.5.
I do the same thing with the planet left, drop it onto the moving platform.
Got to mix.
Get that drop right.
There we go.
And then hold control and snap it over.
into place.
Now I'll go to my moving platform.
I want to modify or actually I need to add a collider.
So add a box collider 2D.
Expand it out.
And then let's set the size to be right.
You can see right here the green is pretty small.
We're at one unit by one unit.
This is supposed to be a six wide one.
So a value of six seems about right.
Look like that just hit the edges.
And you can see if I grab and drag it up, it's going just past the edges and just inside.
So we want to set this to six.
Now I've got my platform.
It should just work as a normal platform.
There's nothing special about it.
Basically recreated the six platform.
Let's just go double check that though.
Make sure that I'm not crazy before we start making it move.
So we'll run over here any second now.
Soon as it finishes completing the domain.
There we go.
And run over.
It was completing a domain reload.
I just finished in the middle sentence.
There we go.
It can land on the platform.
Looks good.
So now I want this platform to move.
We're going to need a new script for that.
We're going to create a moving platform script.
And to do that, we'll go into the scripts folder, rightclick, choose create, and choose C# script.
Call this moving platform with a capital M and a capital P.
Again, no spaces in our script names, and we'll hit enter.
That should open up the code editor.
Probably won't go to the right thing, but it does look like it got my moving platform file opened here.
Now, if it doesn't happen for you, you of course just go back into the editor, double click the file again, and it'll probably find it.
Or you can go over to the right into the solution explorer, and then find it down here.
You might have to expand out your assets and scripts, but it should be there.
All right, now that we've got our update and our start method here, it's time to start writing code for our moving platform.
Well, first thing I want to do actually is delete my start method because I don't want to do anything at the beginning of the life cycle of this moving platform yet.
What I want to do instead is keep track of two positions, a starting and an ending position, and then move this platform between them.
I'll call those positions, I could call them like left and right, but then if I make a platform that goes up and down, it might not make sense.
So, I'll call them positions one and position two.
We'll make them serialized fields.
So, I'll start with a serialized field of a vector 3, and we'll call this underscore position one.
I'll duplicate it with control or command D.
and now have a position two in the update method.
What I want to do now is move my character between the left and the right or position one and position two some percent of the way.
So let's start by just making it so that we can control this in the editor.
And we'll say transform.position equals and we're going to get a position in between position one and two.
And to do that, we'll use the vector 3.lurp method, which does a linear interpolation, which is going to give us a value from position one to position two based on a percentage across.
So we'll put in position one as the first value, position two as the second value, and then our third value right there is a float or a parameter for the percent of the way that it's gone across.
I'm going to add an underscore PCT which will be percent or let's spell it P E R C N T say percent across.
I'm going to make it a big long variable name.
We'll add a semicolon and then we'll generate a field for that percent across.
So hit generate field and then I'll take the serialized field attribute and replace the private keyword with that cuz don't need the private keyword and that will make it show up in the inspector.
Now I'm going to add a range attribute range.
And we'll go from 0 F to 1 F.
And that's going to turn this percent across into a slider.
Let's save.
Go into Unity and attach this moving platform script to the platform.
So as soon as it finishes reloading everything, I should be able to select it, go add my moving platform.
I'll minimize the box collider.
Notice we've got this percent across me or percent across that we can fill in here.
But my positions right now are set to zero and zero and zero zero zero.
All zeros all the way along.
So if I just press play right now, it's not really going to do anything except for pop over to 0 0.
Let's just press play and verify that I'm not crazy.
And that that's the case.
Should go right to the center and just kind of pop into here and stay there.
And now no matter what I do with this slider, it's not going to change anything.
Nothing's going to happen.
Let's stop playing though and put in some values here.
Let's say that position one is our current position.
So 11 on the X and zero everywhere else.
And then position two, let's just move it five units to the right.
So we'll go a value of 16.
Now I'll press play.
And now it should start off in its initial position because that's position one.
And then let's go to the scene view so we can see it better.
As I drag the percent across, you'll see that it's going to go across to the right to position two.
Watch that value interpolate from 1116 all the way over.
And when we get to a full value here, now one thing that's kind of interesting is I could also adjust the y position.
Like maybe make the second y position be three units up or 3 meters up.
Now as I drag this, it's going to go up and to the right.
Pretty cool, right? And if I did like a negative three, it would go obviously down and to the right.
I could adjust this to be like a maybe let's not go with a negative, but maybe like a four.
And then suddenly it's going to go down and to the left.
You can kind of get the idea of how this is going to move based on the value that we put in here.
So, we're going to put in a value between zero and one and have it go initially just back and forth.
So, it'll go from the left to the right basically by moving this percent across value up and down.
All right, let's stop playing though and let's go into plastic and do a commit because we've got a moving platform that we can manually control.
We're almost to the point where it's automatic and I think that this is a good check-in point.
So, we'll say added a manually controlled moving platform and we'll commit.
Oh, we've got one error that popped up.
If that happens, just hit check in again and it should save.
There we go.
Before we make this platform move on its own, we're going to add some gizmos so that we can easily control where it's moving, the starting and the end position, and make it easy for ourselves and I guess game designers, if we have any on our team, to set these up without it being some big tedious process of trying to find exact positions and type those in.
So, we're going to start by opening up the moving platform script.
And down at the bottom of our script, let's see if I can get over to the left.
There we go.
We're going to add an ondraw gizmos.
This is going to allow us to see exactly where our platform will start and where it'll end and even see the current position of it along the slider.
So, if we move that slider, we see where it would be.
So, we're going to start with setting the gizmo color to red.
We'll do that with gizmos.color equals color.
It's a lowercase R and a lowercase C, but other uppercase G and C there.
A little bit confusing and a little bit unconventional, but that's the casing for it.
Next, we need to get our box collider and figure out how big it is so that we can draw a box that matches the size of our box collider.
So, we'll say var collider equals get component.
And we don't want to just get a collider.
We want to get a box collider 2D, which is what all of our moving platforms will have.
Next, we'll draw a gizmo.
So, we'll say gizmos.drawbox.
Or is it draw cube? I always get that mixed up.
It's not a box, it's a cube.
And we need to give it the position.
So our first position will be position one.
And then a size.
For the size, we'll use the collider.bounds size.
Now we'll duplicate that and do a another one for position two.
And save.
This should give me two boxes that show up as gizmos in the inspector.
Let's go see.
Well, in the scene view, not so much the inspector.
And they should show at the positions of my um my thing.
So there we I got one box to the left and one to the right.
And that reminds me that I want a wire box, not a regular cube.
So, we want a draw wire cube.
There we go.
Wire cube.
That's what I was looking for.
Let's save.
We'll go back in.
We should see them no longer be these big blocks that make it really hard to see what's going on, but instead be some normal cubes.
There we go.
I can see that's the start position and that's the end position.
If I move the start position over to maybe like six, oops, not 63, six, I can see that the block is perfectly aligned right there.
Now, I'm not seeing the current position based on a percent across.
I do kind of want to have that as a gizmo.
But I also wanted to show that if I move these positions up, like I put this up at like a two, you can see that it's going up and above and have this platform going across.
Let's go back into the platform and add another wire cube that shows the current position based on that percent across.
So to do that, we're going to copy line 15 or at least the right half of line 15 and we're going to use that as the position.
So we'll say var current position equals and then paste.
So we'll get the position based on the percent across.
Then we'll just draw another wire cube at that position.
So I'll copy line 23, paste it down to 26, and use current position instead of position 2.
The final thing I want to do is change the color so that we have some indication that this is the one based on the percent across.
And to do that, I'll copy line 20, paste it here as the new 25, and change the color to yellow.
Everything after the color change, we'll draw in that color.
So we just have to modify it right before we change it.
So now I should get a box that's going to show right here since percent crosses at zero in yellow.
And as I draw drag it across, I can see it moving over to the other line or the other the other square, the other edge.
Now I've got my box, I think, pretty much working.
If I press play, I can drag that percent across and it should move across just exactly to those two positions.
Let's just double check that.
So, I drag it and yep, it looks like it's going back and forth between those two positions.
But I want to do one more thing because I don't like having to go in and type these positions in.
Let's say that I want my second position to be, I don't know, up here or something, right? Right in this spot, and I want to get this position.
I could, of course, I go in and copy this and paste it in 11.75 and then paste in an eight.
And that'll kind of work.
But I'd like to add a shortcut so that I can do that a little bit quicker.
And to do that, we're going to go back into the moving platform.
And I think I'll do this right down below on draw gizmos.
We're going to add a method to set position one and set position two.
So make a public void set position one and it's going to be an expression body method because it's only going to do one thing.
So we're going to use the lambda statement which is the equals and the greater than.
And what we'll do is say underscore position one equals transform.position.
Now I'm going to go to the beginning of the line here with the home key and we're going to add some braces and add an attribute.
We're going to add a context menu attribute so that we can rightclick and pop this up by just right clicking on the inspector.
So, right or add that left brace.
There we go.
And we're going to add in the keyword context menu.
And then we need to open parenthesis.
And we'll put name of set position one and then close close parenthesis and a closing square brace.
So now I've got this here.
This could be on a separate line.
I could also do this one line above.
Whoops.
Let's see if I can if I can move that properly.
Cut.
Paste.
There we go.
So, I can do it one line above like this or I can do them as a oneliner so that it just kind of fits.
And I prefer to just do it as the single oneliner.
Then I'm going to duplicate it with control D and do the same for position two.
So, I'll just change these ones to twos.
And let's save.
Now, if I go back into Unity, I should be able to just move this thing to where I want it to be for that position.
right click and then set that position to kind of lock it in.
So, I'm going to drag it over and say I actually just want it to be across the water.
So, it starts on one side.
Maybe it even goes from that platform and then docks over to this platform.
Now, I'll right click on my moving platform and choose set position two.
And now my second position is going to be over there.
And I can see that it's going to move back and forth between these two spots.
With that done, I'm going to save my scene and then go into the project view and turn this into a prefab.
So, in my prefabs folder, I'll take the moving platform 6, drag it down, let it become a prefab, and now I should need to save my scene one more time to get rid of that star.
We'll go back into plastic and we'll commit our moving platform with gizmos or manually moving platform with gizmos.
Next step is to automate its movement.
So, we'll say manually moving platform with gizmos and we'll check that in.
Now, we're going to make this thing go back and forth on its own so we can see how our player works with it.
and then make our player work perfectly with it.
So, first thing we're going to need to do is open up the moving platform script.
And when we use the percent across, what we want to do now instead of just uh having it be manually modified by our serialized field or by the inspector, we're going to need to modify it over time or we're going to need to pass in a value based on time.
And to do that, we can use time dot time.
But time dot time is a value that goes from zero up to however many seconds that we have.
And what we really want is a value that goes from zero to one and then back to zero every second.
And luckily there's a method in Unity, well a method in the math library that does exactly this.
And that's the math f.
Pingpong method.
So what we can do is add a new line here on 15 and assign our percent across using that pingpong method.
So say percent across is equal to math f.pingpong and we'll use our time which is that zero to however long we've been playing value.
And then we need to give it the length to pingpong across.
So since we want a value from 0 to one, we put in a one.
Now this will give me a moving platform that moves all the way across um relatively fast.
If I want to get some speed control over that, I can multiply times a speed value and then generate a field for it so that I can modify this and figure out how fast I want it to go per platform.
So I'll take my serialized field, replace the private, and then set a default value of one.
So we know what that default is.
Then we can speed it up or slow it down, and we can have independent control per platform.
So let's go try that out.
All right, here we can see the platform moving back and forth.
Let's go to the scene view and check it out.
I can modify the speed.
Set it down to a nice 0.1 and it's going to go really slow.
I could turn this up to a one or there's an 11 or a one or a two.
And you can see I've got total control over how fast this thing's moving.
Let's go jump on it though.
Let's see if I can get up there.
Jump.
Jump.
I will make it.
I think.
See, did I make Oh, I missed the platform.
Okay, I'm going to make it onto it this time.
So, we jump onto the platform and look at what happens.
The platform moves and we can kind of follow along with it, but we're not moving with the platform.
We're moving up with it because it's kind of pushing us up and we'll move down and kind of fall down with it, but we don't get that left to right movement that we kind of probably want on a moving platform.
So, let's stop playing and fix that because that's the final thing that we need for a moving platform.
To do that, we're going to go into our moving platform script and we're going to add in two more methods.
First, I think I'm going to move these set position context menus up to the top.
Let's get them right up here so they're kind of out of the way.
I'm going to get rid of that update comment because I don't need it.
And I'm going to get rid of the private keyword.
Minimize on draw gizmos.
And then I'm going to add an on collision enter 2D.
What we want to do in this method is check to see if a player hit us.
And if so, make that player our child.
So we'll say var player equals collision.getcomponent or I know I need to get the game object.
So game object.getcomponent or we could also use the collider.getcomponent.
This would be the same either way.
We're going to get the player component.
And then we'll say if player is not equal to null then we want to set the players transform parent.
Wait.
Player.t transansform set parent equal to our own transform.
Now we'll do the same on the on collision exit.
So I'm going to get rid of that private keyword.
I'm going to copy this method.
Just control D and duplicate it.
And then I'll change enter to exit exit.
We get the same exact There we go.
We get the same exact structure, but instead of setting the parent to our transform, we're just going to set it to null or clear out the parent so that we're no longer parented to this this platform.
Let's stop or stop editing our code, start playing, jump on that thing, and see what happens.
Although, first, I think I want to move this.
Well, let's leave it up there.
I was thinking I want to move it down.
I think I'm just going to move my player up so that it's easier for me to run onto that platform.
Or maybe I'll just move this platform here over to the left.
I don't know.
Maybe I'll just hit play and run and jump on it.
I guess we'll see.
One editor update later and now I've got my platform working.
I've set it to 0.1 and I stick to it as long as I'm touching it.
I can walk right off of it or walk onto it and it just kind of works.
Let's see.
Get to the edge.
I can walk off.
Kind of little jump to make it back on.
But you can see my platform is working.
So go ahead and check this into plastic.
I just accidentally committed without recording.
So you're not going to see me do it on this one.
But just go through your change set, commit it.
I called this working moving platform with player sticking.
Now, we're going to add a new type of platform, one that our players can destroy.
And we'll start by going to our tiles folder and finding one of the bricks.
What we're going to do is create a standard brick like you would see in Mario that our player can jump up, hit, and destroy.
And then we'll add some other ways to destroy bricks as well.
So, we're going to start by just taking a brick.
And I'm going to drag it right out here.
Maybe next to this platform.
I'll fix the position to be a flat -3.5 and a zero so that it's perfectly aligned here.
And then we're going to go modify it a little bit.
First thing I want to do is rename it to brick.
I might name it brick brown, too, just so that it matches cuz we have a gray one, but I think I'll leave it as brick for now until I decide that I want to have a gray brick as well.
And then we'll add a box collider 2D to it.
Next, we're going to need to add a script for this thing so that we can make it destroy or make it get destroyed when we hit it.
Specifically, when we hit it from below, though.
So, we're going to create a new script in our scripts folder, and we'll call that the brick script.
So, rightclick, create a new C# script, and name it brick.
I generally like to name things after what they're going on until they get to a point where they become more abstract and they're used for multiple things.
Then, I might go about renaming it.
But since this is just a brick, I'm going to add it as a brick script for now.
It didn't open up my brick script, so I'm just going to double click and force it to open.
So, I've got my brick script here.
And what I want to do is deal with collisions from the bottom only.
So, I'm going to get rid of start and update cuz I don't think that I'm going to need those.
And we'll add an on collision enter 2D method.
On collision, enter 2D will fire off whenever we hit this brick with our player or anything else.
So the first thing we probably want to do is check to make sure that the thing hitting it is a player.
So we'll say var player equals collision.game object.get component and we'll get the player component.
This should give me back a player if we have one and if not we just want to return.
So I'll say if player is equal to null.
So if we don't have any player then return and do nothing.
So if we do have a player we'll continue on.
Otherwise, we'll do what's called an early exit where we'll just check to see if we have a player.
If we do, we'll save them off.
Otherwise, we bail out and don't run any code.
Return is just going to make it exit this method without running any of the code after it.
I'm going to get rid of that private keyword.
And then we'll add in the next bit of logic.
So, the next thing that we need to do is check to see if the player hit the brick from below or if they hit it from above or the side.
Really, we just care if they hit it from below.
And to check that, we can use the dot product.
First though, we need to get the normal of our collision.
So we'll say var or let's say vector 2 and be a little bit more explicit here.
Vector 2 and this will be our normal is equal to collision dot contact zero normal.
You can see it's going to autocomplete.
So this is the angle that we collided at.
And what we can do with it is use that vector 2 dotproduct.
Let's take a look at it right here.
And it takes in two different vectors.
So give it a left vector and a right vector or the first one and the second one.
And what it's going to do is return a one if they point in the exact same direction, a negative one if they point in the opposite direction and some value in between if it's close.
So if I give it a right hand side of up and a left hand side of a vector that's down because our our normal was down, then it's going to give me a negative one.
If I give it a right hand side of up and our normal was up, it's going to give it directly straight up and down, it's going to give us a one.
If it's at some angle, it's going to give us some value greater than zero and probably some value greater than 0.5 depending on where what the exact angle is.
So let's take a look at this in practice.
So I've got my normal here and then I'm going to get the dotproduct and I'm going to say float dot equals vector 2 dotnormal no sorry dot dot not normal and then we'll pass in our normal and vector 2.up as our second one.
So this is going to give us that dotproduct.
Then we're going to log it.
So we'll say debug.log and just write out that dotproduct just so we can see what it is.
And then finally, we'll say if the dotproduct is greater than let's say 0.5, then we want to destroy our game object.
So we'll say destroy game object.
And that's going to destroy our brick.
Let's try that out real quick.
See what it looks like and then see if this code and logic is correct or if we might need to invert or switch this.
So we'll jump over to Unity.
We'll press play.
And I'm going to run over.
We'll go to the console tab.
Oh, that platform is moving a little fast.
Jump and take a look.
Well, I didn't add the brick script.
So, we didn't get anything.
So, I'll add the brick script to our brick.
And then we'll jump again.
And we can see that we got a one and the brick was destroyed.
Let's stop playing.
Go add the brick script in not play mode.
And then let's go land on top of that brick and see what it does.
make sure that we can jump on top of the brick and it doesn't break.
Or we can hit the brick maybe from the side and it also doesn't break.
So if I hit it from the side, you can see that the normal was a zero.
And if I go up to the top, we see that that normal is a negative one.
Here you can see I got a negative.5 or whatever when close to that when I was jumping sideways.
And if I come at it at an angle, you see that we still looks like we still got about a one on that normal because we hit perfectly flat up and down.
So, that looks good for destroying our first brick.
Let's turn it into a prefab, though.
So, we'll go into the project view.
Go into our prefabs folder.
That's starting to get a little bit full, but we'll split this out soon.
And we'll take our brick and drag it in.
Now, it's a prefab.
And we'll save off our sandboxing.
I'm going to go to plastic and say that we created a brick that gets destroyed from hit with hits from below.
So added brick that destroys when hit from below and check in.
Now we're going to add some visual indication when our brick is destroyed.
Beyond just the brick disappearing, let's add some particles of little bricks flying away.
And to do that, we're going to need to create a new particle system.
We'll go to game object and choose effects and particle system.
I'm going to name this brick break particles.
And then we need to first create a material so that we can assign our texture here and get this showing up.
If you look down at our particle system underneath the renderer section, you'll see that the default material is here.
It's the sprite lit default.
And that's not really helpful.
We need an actual material that shows some sort of a block.
And if we look at the particles folder here, you see that we actually have a broken little brick brown object or texture that we can use.
So I'm going to create a new material that uses that brick brown.
We'll rightclick and choose create.
And we're going to choose material.
Now, we need to give this a name.
I'll call it brick particle.
And then we need to choose the material shader type.
So, there are a couple options here for particles.
First thing we need to make sure that we do is go to the universal render pipeline because that's what we're set up to use.
And then go into the particle section.
Here we can choose lit, simple lit, or unlit.
I would often choose lit, but what we need to do actually doesn't work right with the lit particles because I want my bricks to eventually fade away.
And right now, that only works with the unlit shader.
So, I'm going to choose the unlit shader, which will work totally fine for what I want to do.
And change the surface type from opaque to transparent because I want to be able to fade away the alpha and make these things just kind of smoothly disappear.
Next, we'll assign the texture.
So, I'll take this brick brown and drag it right into that base map.
And then it hasn't updated here yet because we haven't assigned that material to our brick particles.
So I'll go select the brick particles.
We'll expand out that mesh renderer again.
Just click again on the big bar here, not the check box.
You don't want to turn it off.
And then drag the material over to the material section.
Now you see a bunch of bricks going flying up in the air.
There are a couple things that I'd like to change though.
First, I'd like these to fly off in just kind of a burst instead of all at once or instead of consistently.
So, I want them kind of like blast off all at once, not in a in a consistent stream of them.
So, we'll go to the emission section and change rate over time to zero and hit plus to add a burst.
Here, we can control the number of things in the burst by adjusting that count.
But before we do that, let's change the shape that they're bursting out at.
Instead of them going up and out, let's make them go all directions.
We'll expand out shape and change the shape from cone over to sphere.
In fact, let's go to the scene view real quick before we do it.
So, you can see the cone right here that it's using.
If we change this over to a sphere, you'll see that now they go off in all directions.
Now, I also want to shrink these things down.
I don't like the size of them at all.
They're way too big.
So, I'm going to go find the start size up here at the top and change this to about a 0.5.
I'm going to change the start lifetime to about 75 so that they go pretty quick and they can disappear over time.
Then we're going to go do that disappearing over time part.
So that's underneath color over lifetime.
If I expand out color over lifetime, I get a popup here.
And well, first I've got to turn it on.
I'll get a popup when I click on this.
And if I go to the top right bar here, I can adjust the alpha at the end of the life cycle.
So I drag this all the way down to zero.
And then my brick particles should start pretty good and then disappear halfway along.
Now, I don't want them to disappear right away.
So, I'm going to add another point right up here where the alpha is all the way at 255.
So, they don't start blending away until about halfway through their life cycle.
To do that, I just clicked up at the top.
And I think I'll drag this over even more to probably around like 80%.
In fact, I I might even just type in an 80 there.
So, at the last 20%, they'll just fade away.
So, there's my bricks.
They're looking okay.
Let's change that.
I'm going to pick put that to 60.
I want to change this a little bit more, though.
I want to make these things rotate and kind of spin randomly and maybe even shrink over time, too.
So, to do that, we can find the rotation over lifetime.
Expand that out.
And if I leave it at just a default of 45, you see that they'll all spin the same.
I want them to be somewhat randomized, though.
So, I'm going to choose the random between two constants from the drop down there.
And put a negative 180 and a positive 180.
So, that way they'll all spin totally randomly.
And it'll be a little bit, you know, varied, I guess.
So, let's watch it in here.
See, they all kind of spin.
Looks good.
The last thing I want to add in here is a size over a lifetime.
So, I'll expand that out, check the box, and do exactly the same.
I'm going to hit the drop down, choose random between two constants, and put a let's go with a 0.1 or 0.5 and a 0.1.
So, we can go anywhere from our initial size to all the way down to 0.1 depending on uh what we randomly pick for that particle.
So, now I've got some particles that I think look okay.
They look pretty good for when I destroy a brick.
The next thing I need to do is assign them to my brick.
So, we'll go to the brick.
We'll go open up that brick script and we're going to add a serialized field at the top for a particle system.
So, I add a serialized field.
Call this particle system.
And I'll call this brick particles.
Now, when we hit our brick, we want to spawn some brick particles so that our player can see them um as well as destroying our object.
So, I'm going to copy the brick particles.
And right here on line 19, we'll add some braces because we only want to do this if we're actually going to destroy the object.
We don't want to call this code if we're, you know, landing on top or something else.
So, if that product is good and we should be destroying our game object.
Before we do that, we will instantiate a particle system.
So, I'll paste in my particles at our transform position and we'll use the quatian identity for the rotation.
And again, that's just the default rotation value.
It's like passing in um nothing or just face the normal default direction.
So, we're just going to give it that.
Save.
Jump into Unity.
And let's go see if we get a particle system that appears and shows up when we break a break a brick.
So, hit play.
Oh, I've got to assign the brick particles.
Here's what I'll do.
While we're playing, I'm going to drag this brick particle in here and assign it.
run over here, jump and hit it and see if it actually works.
Okay, so that worked.
We got the brick there, but we still need to make this into a prefab and uh probably make it so that it doesn't keep looping.
I don't know if you saw that appearing there.
So, next steps are just go into our prefab folder, take our particles and drag them in.
Then go find our brick and assign the brick particles to them.
Then we should probably apply the overrides to our brick script.
And then finally, let's go adjust that brick particle one more time.
So, I'm going to delete the placed one here.
Go double check that our brick doesn't have the reference to the placed one.
It's actually referencing the prefab.
Then, we'll go open up that prefab.
And I want to uncheck the looping option because I don't want this thing to loop.
I want it to kind of destroy itself or clean itself up.
I'm also going to change the duration from a five to a one because the lifetime is 0 75.
So, this thing should end at about a one.
And then I can probably figure out a way to clean that up.
So, let's go back, save, press play, go one more time, break a brick, make sure that it works, and that I only get one particle, and then we'll do a commit.
So, run over here.
Let's go land on top of it first.
Seems good.
Hit it from the side.
Seems good.
Hit it from below.
The brick breaks and disappears.
So, it's looking good.
Let's go into the plastic setup and commit our changes.
First, I'm going to save my sandbox scene, though.
Make sure that it shows up in here.
So, we added brick break particles and we'll check that in.
Right now, when our player jumps and breaks a brick, you'll get a particle system that appears and shows the particles, but then it never actually clears itself out or goes away.
So, this is fine if I've got a single brick, but if I added hundreds of bricks and destroy them all, my hierarchy is eventually going to get filled up with a bunch of different particle systems that are no longer running.
And that doesn't seem like a good idea.
It seems like something that we should definitely clean up.
We want to keep the hierarchy clear and cleaned up of all these objects so that we don't have to traverse through them.
It'll speed up the game just a little bit, but also make it a lot easier for us to manage things.
So, what we're going to do now is a small challenge.
What I'd like you to do is write a single script, a simple script for your brick particles that will destroy them when they're done playing their particles.
Now, there are multiple ways that you can go about this.
I'll show you my simplest solution right after we go through the what the actual challenge is, but I'd like you to come up with a solution that cleans up the bricks and just destroys them for now.
We'll talk about pooling them and putting them back into a pool later.
So, don't dive that far ahead.
Instead, just get rid of the bricks after they're done so that we can put as many as we want in here.
We'll spawn bricks and then they'll despawn.
And later we'll talk about some of the benefits or optimizations that we can do to make that even better.
So go ahead and take this challenge on create your brick particle script and then see if you can figure out how to clean it up.
All right, I'll assume that you've either gone through it now or decided not to and just want to see the solution.
So we're going to rightclick create a new C script and I'm going to call this brick particles.
Let's fix my caps lock there.
brick particles and then I'm going to assign it to my actual brick particles.
So I'll go find my brick particles, which is my prefab right in here, my brick break particle, and then we'll assign it.
So I've got my brick particles script, and it's now attached to my brick particles.
I'll open up that script, and what we want to do is destroy this object after some amount of time.
So, we'll in the start method, I'll just say destroy.
We'll pass in our game object, and then we'll give it a parameter for the amount of time to delay.
And the amount of time that we want to delay is just going to be whatever that particle systems lifetime is.
So, I'm going to add a line up above to get our particle system.
I'll say var particle system equals get component particle system.
There we go.
And then for our second parameter, I'll paste in that particle system variable.
And here we have a duration, but that's not what we want to use.
If I put that in, you'll see that we get a little deprecated message saying the duration of particle system in seconds read only.
But right below it, it says particle system.duration is obsolete.
The duration property is deprecated.
Use main.duration instead.
So what that's saying is this used to be the way to do it, but they've changed it and now you want to actually access it through particle system.
That'll get rid of the error.
fix the problems and make everything work.
I'll get rid of this update method and that extra line at the end.
I'm even going to get rid of these two using statements that I don't need.
All I need is that using Unity engine.
That's why they were light gray.
So, the light gray ones, I can just delete those out.
I'm going to save, do a build, and now I should have particles that clean themselves up after whatever the duration of that particle system is has expired.
So, let's go check that out and see if that's the case.
I should now be able to Well, let's duplicate my brick.
So, let's put two bricks here side by side.
Go break them both and make sure that I end up with no particle systems in my scene after the 75 or 1 second or whatever it was that I I set my thing to.
There we go.
Looks good.
My particle systems are self-destroying.
So, let's go back into plastic.
Make sure that I've saved my scene.
I've got my second brick here.
So, we made particles or brick particles self-destruct.
Now, you might be wondering, should we make this more generic for other particles? We'll do that later.
Once we have some more particles, we can probably rename this to self-destroy particles or something else.
But for now, we only have brick particles, so we'll name it for the thing that it is, and it's easier to find that way, easier to manage, and then less abstract until we actually start to use the abstraction.
So, check that in.
Another brick issue that I want to address is the way that our player deals with hitting multiple bricks going up.
So, I'm going to duplicate our first brick, hold control, and move this up one meter or one unit.
So, it's at a one on the Y.
I'm going to press play, run over, and I'm going to do a big jump where I just hold and jump up into the bricks.
Let's see what happens.
Come over here, and I hold space.
Oops, I messed that up.
Let's try it again.
Let's go back over to the right and try it one more time.
I hit the uh the grass there.
So, it messed up my demonstration.
Let's go destroy this other brick off to the side.
There we go.
And then do a big jump.
So, you can see here when I jump up and I hit things, I just kind of go right through them and I continue on.
And what I like to happen instead is if I jump up and hit one of those blocks, I want it to kind of knock me back down just like it does like in a Mario game.
You break a brick and you get pushed back down just like you hit your head on anything else.
So, let's make that change.
Now, what we can do to change that is simply go into our brick and when we hit with a player, what we'll do is tell our player to stop their jump.
So, right here, when we've actually taken a hit from a player, we'll say player.stop jump.
Now, how we're going to implement that stop jump, we can figure that out later.
We just know that when we hit this collision, we definitely want to cause it to stop jumping.
So, we'll hit alt enter, generate a method that's right now going to throw an exception, and then we'll hit F12 to actually go look at that method and figure out what it might want to do.
So, to stop a jump, let's go look at our code.
How do we currently stop a jump when we release the the jump button? So, if I let go of my jump, then our jump stops.
And how does that happen? Let's go find it.
Let's see.
Where's our code? um right here.
So, we're checking to see if they're still pressing the value and the jump end time is greater than our current time.
So, here we're just checking to see are they still holding it down and do they still have some jump time left.
Now, it'd be hard to override whether or not they're still holding it down.
And we probably don't want to lie to ourselves about that.
We don't want to go in and change this input action and say, "Oh, yeah, they're not holding it down." But instead, what we could do is just set our jump end time to the current time so that uh their jump has to end right away.
So, we'll just go down into our stop jump, modify this to say jump end time equals time.
We'll make this public instead of internal just because I like the consistency of the the wording there.
And then we'll go into Unity and let's try it out.
What I expect now is that my jump should end the second that I hit my head.
Now, I have not stopped myself from double jumping.
If I wanted to do that, I could also just set my jumps remaining back down to zero, but I think that I kind of want to leave double jumping alone right now.
So, I'm going to jump and oh, I still didn't get knocked down.
Let's go make sure that I've actually saved my code.
So, go back into Unity.
Oh, and I didn't save it on the brick.
There we go.
Save the brick so that it actually calls stop jump.
That's why that little star was there.
So I'll press play one more time.
So again, an important reason that I usually hit control shiftb and do a build when I'm in the code editor.
So that way catches all of the code files that I've changed, not just whatever the one that I have open is.
So here, let's do a jump.
I'm going to hold it again and got knocked back down.
Perfect.
That's the behavior that I expect to see.
So save my scene.
I've got that new brick in here.
go back into plastic and say that the player gets or player jump stops when breaking a brick.
And we'll check that one in.
Now, we're going to add lasers to our game.
Before we put lasers in our player's hand, I want to put them on the floor with some switches that we can use to toggle on and off.
To do that, we're going to need to grab the KennyL pack that has all of the requests.
This is the platformer art requests pack.
I'll link this down below, but you can grab it and then open it up and you should find inside there's a tiles and a vector folder.
I'm going to go into the tiles folder.
What we're going to do is just copy this entire entire folder.
In fact, what I'll do is actually go up one level.
I'll copy this tiles folder.
I don't need the preview or the vector ones.
And then I'm going to go into my project folder.
So, find my project folder, go right into the art subfolder, and I don't want to put it into the tiles folder.
Instead, I'm going to create a new subfolder called um let's call this lasers.
It's requests, but I want to call it lasers because that's what it actually has and it is my lasers.
I'll hit show in explorer in that folder.
We'll go into the folder and paste in the tiles subfolder.
So now I should get that other folder of tiles right in here.
There we go.
And then finally, I'm going to go into this folder.
I think actually what I want to do is select everything.
So, I'll go in the folder, Ctrl+ A, and I'm going to hit Ctrl X, go up one level into the lasers folder, and paste all of my files into here.
Now, I can get rid of this extra tiles folder and just have a lasers folder with all of my files in it.
There we go.
The paste just finished.
My tiles subfolder should be empty.
I could have also just selected all of those files from the zip and pasted them in as well, but I did it slightly different, and I just wanted to show show that process.
So, here I should get my lasers all importing.
So, it's going to be lasers and beams and other things.
I need to make sure that I set the pixels per unit here.
You can take a look at these and see that these are actually set to 70 by 70 on all of these textures.
So, what I want to do is select the first one, go down to the last one, hold shift, and hit select.
And I can see that, oh, one sprite is selected.
So, I need to go find the one entry that's not correct.
And if I can't tell what it is, the easiest way to do it is to just drag this list down.
And I should be able to see the one entry that looks slightly different.
Let's see if I can find it.
I have not found it yet.
But I can also just scroll through here until I see it change.
Why am I not see Okay, maybe.
Let's go start to end.
I am not finding the one that's bad.
Do I have one expanded? I'll just hit the down arrow until I find the one that shows no.
Oh, here it is.
It's this one right here.
Ah, laser blue vertical was expanded.
That was causing the problem.
So, with it collapsed, I'll hit home, shift, end.
That should select them all.
Perfect.
And then I'm going to set that pixels per unit to 70 so that it matches with these sprites that I've just pulled in.
That should make it so that each sprite is still 1 meter by 1 meter.
Let's go check that out.
I've got my sprites set and I'm going to take um let's see what's a good one to grab.
Let's do this blue laser.
No, let's take the yellow laser switch.
I'm going to take it, drag it right out here.
Yeah, I can see that looks like it's about one cube by one cube.
In fact, it should be exactly one cube by 1 cube.
So, drop it out.
I'll fix up the position to be a four and a negative 3.5, which is just where my ground is.
And then I'm going to rename this to laser switch.
It's defaulting to the off position.
That's the one that I grabbed the off.
So, it's off to the left.
And I expect that when I push it to the right, I want to make it change to that.
And then turn some laser on.
The next thing I'm going to need to do is create a script for this.
I'm going to need some sort of a laser switch script or a toggle script or something like that.
I'll go into the scripts folder, right click, rightclick, and choose create car script.
We'll call this laser switch since that's what we're putting it on.
And then once that script is created, as soon as it finishes, there we go.
I'll go minimize the code editor and I'm going to assign it to my laser switch.
Let's go select it and assign.
Now, there are a couple things that I want to do with this switch.
I want to change the graphic and then I want to make it toggle or do something.
And I want to have it interact when I walk through it.
So, if I walk forward through it, it'll turn on.
If I walk backwards through it, it'll turn off.
I could also bind this up to a hotkey or something.
So, I could toggle it on and off.
But, I'm thinking right now it's just like walk through it, walk to the right, it turns on.
Walk to the left, it turns off.
So I can accomplish that by opening up my laser script.
And first I'm going to add some references for the two images that I want to have the on and the off images or the left and the right sprite.
So I add some serialized fields here up at the top.
I'll do serialized field and this will be a sprite.
I'll call this underscore left and then I'll duplicate it and make an underscore right.
So I've got two sprites there.
I'm going to delete this comment about the start method.
In fact, I'm going to rename start to awake because I want to just cache and save a variable, which will be our sprite renderer.
And I tend to cache and save variables in awake so that they're ready for anything else that might need them later.
So, I'm going to put it underscore sprite renderer equals get component and we'll give it a sprite renderer type.
There we go.
That last one.
one.
one.
Now, hit home, alt enter, and generate a field for it.
So, we've got that sprite renderer.
I'm just going to go to the private keyword and hit enter so I can get a new line and get rid of it all at once.
And then we're going to look for an on collision or an ont trigger stay.
So we're going to delete the update method and we're going to add an ont trigger stay 2D.
What this will do is fire off or get called every frame we have something inside of our trigger area.
Now we're going to add a trigger area in a moment.
It's very simple.
It's just like adding a collider.
But we can do some extra in or get some extra info with this because we can stay inside of it.
We can now look at the player and see what direction the player is moving and then turn ourselves on and off based on what direction that player is moving.
First thing we need to do though is make sure that we're actually colliding with a player.
So we'll say var player equals collision.get component and we'll get a player.
Now, this is able to get me the component from the collision because it's named collision, but this is actually a collider 2D.
The the name of this variable by default, I think, is terrible.
It should probably be collider, but it's named wrong or named oddly, so you can still get that component.
If this was a collision 2D, you would have to get the game object or the collider object first.
But since it's a collider 2D, you can get it right away.
Now, if we don't have a player, we want to return and do nothing.
So, we'll say if player is equal to null, then return.
We're going to do another one of those early exits because there's no player here, nothing to read.
Next, we want to determine what direction the player is moving.
And to do that, we're just going to read or access the rigid body.
So, we'll say var rigid body.
Let's see if I can spell it right.
RID body equals.
And here we'll do player.get component.
And we'll get the rigid body 2D.
Once we have that, we should be able to tell what direction the player is moving.
So, we can say if rigidbody velocity.x is greater than zero.
So, if they're moving to the right, then let's uh turn it to the right mode or turn it on.
So, we'll say turn on.
I'll hit alt enter and generate a method for it.
And then if they're going to the left, which would make their velocity dox less than zero.
So zero means they're not moving at all.
Positive X means they're going to the right and negative X means they're going to the left.
So if they're going to the left, we'll just turn it off.
And to do that, I'm going to duplicate lines 25 and 26.
I'll select them both.
Ctrl D, click right here, and hit enter.
And then add the word else.
So else if the rigid body velocity is less than zero, so switch that greater than to a less than.
Then we'll call turn off.
We'll generate a method for turn off as well.
Make sure that you don't rename turn on to turn off.
But we just want to generate a new method.
And now we've got a turn on and a turn off method.
The final thing that we'll do in this section here is update our sprite so that our sprite renderer shows either the left or the right sprite depending on if we've turned on or off.
So in the off mode, we'll set our sprite renderer sprite to the left one underscore left.
And I'll copy that line down for turn on and we'll set it to the right sprite.
So now we should get the toggle happening when we run through it and having it switch our sprite back and forth.
But before that happens, we're going to need to add our trigger and assign our two sprites.
So first, let's assign the sprites.
We'll go to the lasers folder.
We've got the off sprite for left and the on sprite for right.
Then we'll go add a component and we're going to add a box collider 2D.
And the important part here is that we need to make sure that we check the is trigger box.
That'll make it so that our player won't actually collide with it, but it'll instead just call back into our on trigger methods.
On trigger enter, on trigger stay, and on trigger exit.
Right now, we're just using on trigger stay.
And it should switch our sprite back and forth.
Let's hit play.
Run over here and check it out.
So, I run to the right, it switches on.
Run left, it switches off.
So far so good.
I can toggle this thing back and forth pretty easily.
Now, I just need to make it actually do something.
Before we do that though, let's stop playing.
make sure that we've saved our scene with our laser switch and go in create a prefab out of it.
I'll go to my prefabs folder and I'm going to take this laser switch.
I'm going to name this yellow laser switch cuz I might want to add multiple lasers with different colors and I'm thinking I probably will.
I'll drag that into the prefabs.
Save our scene.
Go to plastic.
So, we added the yellow laser switch and check it in.
Now, we're going to make our switch functional.
We're going to do that by turning on a laser blaster.
So, we're going to go into our lasers folder again and take this laser left.
And I want to drag it right up here to about a one and a one in my positions.
This will line up perfectly with what I want to do.
I want to make a laser that can blast this block when I turn this light or turn this switch on.
Now, I've got my laser.
I'm going to name it laser and get rid of that lowercase laser left part.
And we're going to add a new component, one that we haven't used before, and that's the line renderer.
So, hit add component and search for line, and you'll find a line renderer.
This is a nice component for drawing lines of an arbitrary size or beams or other things where the size is going to change.
We could alternatively add in a sprite and kind of manually adjust it and tweak things, but align renderer allows us to do a lot of really cool things and does it really well very easily.
One thing that you're going to notice though is that by default you're just not seeing anything.
And that's because if we expand out the positions in our line renderer, by default it starts at 0 0 to 0 01.
which means that if I go into 3D mode in my scene view, I can actually see a line that's peeking down from the center and going back one meter into our game.
That's not the view that we want, though.
We're not in 3D.
So, we need to change this around and first zero out that Z position.
So, now I should see absolutely nothing.
If I change the starting index to match my position and make this a one and a one, you start to see that there's a line at least showing up.
If I go into the game view, I can see that it goes from 1 one to 0 0.
0 0 is 0 and 1 one's right there.
Let's make it go over to the left.
So, I'm going to add the Y of one so that it stays the same.
And then I'm going to put in a3 here for the X.
So, I've got a purple beam going from here all the way over to the -3, 1 line.
We're going to write code to do this dynamically later, but we're going to start by doing it manually.
Next, we need to turn this purple line into something that looks more like a laser blast.
So, we're going to create a new material for our laser.
I'm going to right click on the laser yellow, choose create, and choose material.
That's not going to assign the texture, but it should at least give me the correct uh the correct render or the correct shader up here.
And then I'm going to go scroll up in here.
Let's see if I can scroll up.
Oh, I've lo Oh, I've got my Where did my material go? I didn't name my material.
Let's go find it.
It's named new material.
Where did it go? LM new material.
We'll call this yellow laser blast.
And what we're going to do is assign that yellow laser to it.
So, I'll take the yellow laser, the horizontal one, and drag that into the diffuse.
Next, we'll go back to the laser, and we need to assign that material to the laser.
So, we'll scroll down to the materials section, expand it out.
You should see something that looks like that.
none assigned.
And we'll drag in our material.
And look at that.
We've got our laser showing.
It is showing on top of our laser blaster, though.
And that's just because of the sprite layers that we've got set up.
Yours may or may not be showing that way.
If we go take a look at our sorting layer right now, it's on default.
I'm going to change this to be on props.
And I'm also going to change the sprite renderer up here to be on props.
I need to go find my where's that at on my sprite render under additional settings.
We go find props and then I'm just going to pull this forward one value.
So I'll put the order and layer here to one so that my laser shows up or my laser emitter, the blaster thing shows up on top of the laser and it looks a little bit better like that laser is coming straight out of there.
Now I need to go into my laser switch and make it so that my laser switch can turn this thing on and off.
To do that, I'm going to go into the laser switch code, and we're going to add in what's called a Unity event.
This is going to allow us to assign things just like we did in buttons, but to our own code.
So, right up at the top, we'll add two more serialized fields.
A serialized field that's going to be a Unity event.
And I'm going to Whoops.
Let's call it Unity event.
There we go.
And I'll name this underscore on.
Now, I'm going to add in a using statement here.
So there's a using Unity engine.events.
If I hit enter on that, it should appear right up at the top.
And now Unity event shows up.
So if you're not seeing Unity event, it wasn't looking right.
Just make sure that you've got the using statement up there.
It should automatically add it.
But if it doesn't, you can hit that alt enter and make sure that it gets added there and that you've got the correct one.
Now I'm going to duplicate this line with control D and add an off event.
And then down in our turn off method, we'll say underscore off.invoke.
And in our on method, we'll say underscore on.invoke.
So this should turn on every time that we move right and turn off every time that we move left.
Now, right now, we're actually doing this constantly.
We're doing this many, many times as we move across.
We'll deal with that later, though.
Let's first go in and make sure that it works.
So, we've got our on event here showing up and our off event.
In the on event, I'm going to hit plus.
I'm gonna drag in my laser here.
I'm going to go find the line renderer and I'm gonna check the enabled box.
I'll check that box there.
So, I selected enabled and then checked the box.
Now, I hit plus on the off and we're going to do the same except I'm not going to check the box.
So, drag the laser in.
I'll go find that line renderer, take the enabled flag and leave it off.
Right now, all this is going to do is toggle the visual effect.
It's not going to make it actually functional yet.
We'll swap that out and we'll change these references soon.
But first, let's make sure that we can actually turn it on and off.
So, I hit play, make sure that I've saved my scene, and I should be able to now walk back and forth and turn that laser image on.
It's already on by default, and off.
Oh, it didn't turn off.
The way that we have our switch set up right now is a little bit rudimentary, and it's definitely not what I would recommend longer term.
Right now, we're accessing the line renderer and turning that on.
And we really want our laser to deal with all of that.
The laser should turn its visuals on and off, deal with damaging things and all of that stuff.
So, what we're going to do is move some of the functionality from our laser switch over to the laser, make that thing a lot more intelligent, and add a little bit of extra intelligence to our laser switch.
Let's start by going to the laser and adding a new script.
We're going to go to our scripts folder, rightclick, and choose create and car script.
and then give this a name of laser with a capital L.
I'll go assign that to our laser as soon as the code editor does its whole thing.
Pops up and then I minimize it.
And then what we're going to do is make this laser script deal with turning that on and off.
And then of course blowing things up.
And like I said, we're going to modify what we call from the laser switch.
So let's open up our laser script.
And let's first get a reference to our line renderer.
We'll do that in an awake.
And I'm going to delete the start and update methods cuz I'm not sure if we're going to use them yet.
Well, I know if we're going to use them, but I don't want to spoil it yet.
So, we're going to start with an awake.
And in awake, we'll say sprite renderer or line renderer, not sprite renderer equals get component line renderer.
That should get us our line renderer.
We'll hit alt enter on the field on the the name up here and generate a field for it.
And I'm going to go delete both of these private keywords.
I'll just go to the beginning and hit shift, not shift delete, control delete and controldelete to delete out those private keywords.
Now I've got my line renderer here and I want to add a method to my laser to toggle it on and off that will just for now start by disabling and enabling the line renderer.
So let's add a public void toggle that takes in a bool which will be the on or off state and I'm going to call this state.
Now, if the state is true, we're going to set the line renderer to enabled.
And if the state is false, we're going to set the line renderer to disabled.
And to do that, we'll just say line renderer.d equals state.
I don't have to add an else or an if else or any of that.
I can just set it to true or false based on what I pass in here.
I'm going to save this off.
And then we're going to go into our Unity editor and then go modify those references in our laser switch.
So on the laser switch, instead of calling line renderer.enabled, we're going to call laser.toggle, which is right here off at the bottom of the screen.
So you might not have seen it.
Let's collapse these two.
And we'll select it down here for the second one.
Laser and toggle.
So it'll toggle on and toggle off.
I'm going to save, press play, and then I should expect to be able to run over there and get exactly the same functionality.
Let's go see if that's the case.
So, I run over, turns on, turns off, turns on, turns off.
Now, I should probably have my laser turn off by default.
So, I'm going to go back into the laser script.
And inside of our awake method, we'll just say toggle false to just turn our laser off.
Now, you might wonder why we just turn the line renderer off.
It's cuz in toggle, we're going to end up doing quite a bit more, or at least a little bit more to determine whether or not we should be updating and drawing a line renderer.
So let's start by adding it in a state or a permanent state.
So instead of just keeping this state here and using it and then go having it go away when we leave our method, let's turn this into a member variable or a field inside of our laser.
So I'm going to say underscore is on equals state.
We'll generate a field for that named is on.
And I like this name for it because it makes it very obvious.
If it's is on is true, then the thing is on.
If it's off, then it's false.
So, it's very very clear.
I'm going to delete out that private keyword that we don't need and then save this out.
Let's go back into our laser switch now because I want to take a look at a little performance issue and a little minor optimization that we can do that kind of matches what we've just done here with our is on.
So, in our laser, our turn off and turn on methods are actually getting called quite often.
If I add a log, we can see just how often that's happening.
Let's do that.
Let's say debug.log.
And here I'm just going to put in the word turn off and a semicolon.
And then I'm going to select this line, copy it, paste it down here to turn on, and put in the word turn on.
So now I can see how often these things are called.
Let's go into Unity.
We'll press play.
We're going to run over there, turn this switch on, and turn it off again.
I should expect my laser to be off by default because we added that code to the laser.
There we So, it's off.
And if I run over here, let's go to the console first.
Clear out our log completely.
Run over.
And you'll see that oh, I had 17 entries.
If I unclap, you'll see that it called turn on 17 times.
If I go over here to the left, turn off got called a whole bunch of times as well.
If I collapse, it looks like it was 27.
The reason for that is every frame that we're in this trigger, we're running this code.
The code right here on trigger stay.
So, we're checking the velocity and then calling turn on and turn off.
This part is okay.
Running this code to check to see if we're hitting something or we're in something is all right.
The get component calls are slightly less than optimal, but it's not bad at all.
The part that we probably should optimize is inside of our turn on and turn off methods.
What we could do is instead of invoking this off and toggling the sprite or changing the sprite multiple times when it's staying exactly the same, we can just say, hey, if we're already off, don't do anything.
If we're already on, don't do anything.
So, let's do that by writing some code in our turn off first.
First, I think I'll get rid of the private keyword here and that private keyword there.
We'll get rid of all these extra privates.
And then inside of turn off, we'll say if underscore is on and then I'm going to let it autocomplete and add my braces.
I'll put the closing brace at the end of my big long statement.
So if it is on then we want to call the off invoke turn the sprite to left or off and then turn or write off our debug log.
But we also want to say is on equals false.
Now I need to generate a field for is on.
It looks like it automatically generated it.
But if it didn't generate for you, you can just generate a field.
Alt enter and you should get a private bool right up here.
Or you can scroll up and just go type it.
Put it right below your sprite render and remove that keyword that private keyword again.
Now in the turn on method, we'll do the exact opposite.
So I'll just copy lines 38 and 39.
Paste them right here and then add in a closing brace and we'll say if is on is equal to false double equals false to make sure that it's not true.
So if it's not on then we'll turn it on.
So on the next line we'll say is on is equal to true.
We'll toggle it on and off.
Now if we go into Unity we should see that this method is on and is off only gets called once.
it won't toggle back and forth or it won't retole the same thing multiple times, spam out that log and then be trying to do things to our laser.
So, let's go check that out.
So, go over it turns on.
Go over, it turns off.
And now I'm getting a single entry and I can see that laser showing up and toggling its visibility there.
So, I'm going to stop playing.
We're going to go into plastic and we're going to save our changes or commit our changes to the laser.
So, laser script created to hold laser functionality and switch optimized.
And we'll check that in.
Now, we're going to modify our laser so that it can shoot an arbitrary distance until it hits a target that it can start dealing damage to.
To do that, we're going to open up our laser script and we're going to add in two new fields.
We're going to start with a direction.
So, I'll add a serialized field here.
For direction, it'll be a vector 2.
And I'll name this underscore direction.
And I think by default, I want to just aim this off to the left.
So I'll name it ve put in vector 2.
So that it automatically just goes the direction that I'm thinking.
But if I want to do a laser that goes up or to the right or anything else, I want to be able to control that.
Next, we'll add a field for the distance that I want this to be able to shoot or a maximum distance.
And that'll be a float because it's going to be a number with a decimal point.
And I'll call this distance.
And I think I'll give this a value of 10 by default.
So put in a 10 there.
So I can go about 10 m.
And we can adjust this per laser or maybe come up with a standardized distance for them or maybe make it infinite so they shoot off forever.
But for now, I'm going to go with a distance of 10.
And then we're going to add in our update method.
And in the update method, we're going to figure out how far to shoot this laser and then adjust that line.
renderer.
So, let's add a void update.
Let it autocomplete.
I'll get rid of that private keyword.
And the first thing I want to do is figure out an end point that is whatever distance away in the direction that we have.
So, I'll say var end point.
This is going to be the end of our line renderer is equal to our transform.position.
So, our starting position plus some offset, which is going to be our direction.
We're going to put this in parenthesis.
We're going to multiply direction times distance.
Now, this is going to give me an error saying that it can't add a vector 2 to a vector 3.
And the reason for that is that our transform position is a vector 3, which means it has that Z position in it.
While while our direction is a vector 2, so it doesn't have a Z.
And when we multiply the vector 2 times distance, we still get back a vector 2.
And it has a hard time adding a vector 2 to a vector 3.
doesn't know what we want to do and it thinks, hey, maybe you've made a mistake here.
But really, what we care about is not the Z position of our transform, just the X and the Y.
So, we can actually cast our transform position as a vector 2.
It's by putting vector 2 in parentheses right before it.
And what it's going to do is it will treat this transform at this position as a vector 2.
This only works if the types are convertible.
Since a vector 2 is just the same as a vector 3 without the Z, it's able to convert that, get rid of the Z, and we just get a 2D X and a Y.
So, we've got that initial position plus our direction times distance to give us our end point.
Now, we'll set the second point of our line renderer or position one.
You'll look at the indexes in a second to that end point.
So, we'll say underscore line renderer set position.
And there's a set position and set positions.
Set positions allows you to pass in an array of them.
Set position is to modify a specific position.
We want to modify the second one, which is index one.
Index zero is the first one.
And we want to set the value or the position to our end point.
I'm going to save that off.
We'll go into Unity.
And we should be able to now modify our line renderer just by adjusting the direction and the distance of that laser.
Let's play and make sure that that's the case.
We'll go select our laser as soon as it starts.
And I'm probably going to have to run over there.
Let's go turn the laser on.
There we go.
Turn the laser on.
You can see that it's blasting out a beam pretty far to the left.
If I drag in this distance, should see that the distance kind of comes in.
If I put it at three, was it three? No, it's four.
Four meters away to that block there.
Should work.
And if I change the direction to maybe a positive one, it's going to go out to the right.
I can drag this out as far as I want.
I could even go up and go at some angle or go like a zero and a one here and have a a laser that goes straight up and down.
So far so good.
We're getting our laser and it's customizable, but we probably want to make sure that it goes out to a specific target.
So to do that, we're going to add in a raycast.
We'll open up our laser and right before we set our position, after we've calculated our default endpoint, let's add a new line.
Actually, let's add one more.
And then we're going to do a raycast.
We'll ray cast out in that same direction and see if we can find another target.
Find that brick or whatever thing is off to the left or whatever direction we end up going.
So to do that, we'll assign a raycast hit.
So say var and we'll call this um let's call this first thing.
This is the first thing that that I've hit.
And it's going to be equal to physics 2D.
There we go.
Raycast.
And we want to give it our origin which is our transform.position.
Then we need to give it a direction which is going to be the underscore direction.
And then finally a distance which will be our underscore distance.
This should return back the first collider that our raycast hits.
And then if we find something we'll say if first thing collider is not equal to null.
So if first thing collider will just be true if we've actually hit something.
it'll be false or null if we've not hit anything.
So if that is not null or if we've actually hit something, that's what this is checking.
Then what we want to do is set our end point to be equal to our first thing which is it's not actually the first thing which is a little bit confusing.
It's the first things raycast hit 2D.
So it's got a little bit of info.
It's got the collider, but it also has the point where the raycast hit.
So, if I set the end point to the first thing that I have hit point and save this off, I should now see my laser blast over to the edge or over to this thing and then stop.
And then maybe if I turn it the other direction, it should go up until it hits the platform that's moving and then stop.
Let's try that out.
So, I press play play play and I'll go turn on my laser so I can see it.
And look at that.
No matter what I set the distance to, as long as it's greater than four, um, it's going to hit that object.
And if I change the direction to one, watch what happens.
And let's let's set that distance out there.
Notice that the the beam kind of goes and matches with that moving platform.
It's hitting that platform.
I'm going to put this back to a negative one, though, because now I think that we're just about lined up.
It's shooting that laser.
It's getting it at the right target, and it's ending at the right target.
We're finding the thing that we're hitting.
Let's stop playing though because there's one other problem that we've got here that we haven't addressed yet.
We're doing all of this code even if our laser isn't on.
Right now, we're running this code to do the updates and we don't necessarily need to.
We don't need to be doing that raycast and we definitely don't want to be damaging things when it's off.
And that's what we're going to do next is write some code to damage things.
So, let's make sure that we only run this code if our laser is on.
And I don't want to turn this script off because that causes some other problems.
Instead, we'll just check the is on bool here.
So, in our update, we'll say if is on is equal to false, then just early exit and return.
That's all we need to do.
We can quickly bail out and not add some braces and add extra um indentation or anything like that.
We'll just bail out if our thing isn't on.
We'll save.
Do a quick build.
Just make sure that all of our files are saved.
And then go back into plastic.
And now we have a dynamic laser that hits targets.
put dynamic laser that hits and ends at its target.
And we'll check that in.
Now, we're going to make our brick take damage from the laser.
To do that, we'll open up our laser script.
And in the part where we find the first thing that we've hit, we're going to figure out if that thing can take damage, and if so, we'll just tell it to take some laser damage.
Now, right now, the only thing that we have that will be able to take damage is a brick.
So we're going to start by just seeing if the thing that we hit is a brick and then we'll make it more generic as we have more things to damage.
So say var brick equals and here we need to get the brick component from the collider.
So we'll say first thing let's see if I can spell it right.
Collider get component and we want to get a brick.
If the brick is not equal to null.
So if brick, then we'll tell the brick to take laser damage.
Now I don't have a method for take laser damage yet.
So we'll just generate one and we'll figure out how that should work.
So taking laser damage on a brick should be relatively straightforward.
We have two real options.
We can either keep track of some amount of health or we could just keep track of the amount of time that this thing has taken laser damage.
And that's what I want to do.
We're going to add in a new field here for damage or let's call this laser damage time and we'll plus equals time dodelta time.
So we're going to add the amount of time since the last frame to our laser damage time.
I'll hit alt enter and generate a field for it.
I'll remove that private keyword and make this one internal.
Change it to public.
Now I want to add a serialized field for the amount of time that we can take.
So I'll add a new serialized float.
it's the um let's say laser destruction time and I'm going to set that to 1 second.
Now in our take laser damage method, we'll check to see if our laser damage time is greater than our laser destruction time.
In fact, I'm going to rename this.
Let's call this taken damage time underscore taken damage time.
Make that a little bit more explicit.
If that's greater than our laser destruction time or equal to, let's add the equals right after the greater.
Then we want to destroy our game object.
But when we destroy our game object, right now we instantiate a particle and then do the destroy.
So let's take that bit of code, line 34 and line 35, hit alt enter, extract it, and make a new method called explode.
This will do our explosion and kind of destroy our object cleanly and give us that particle at the same time.
I'll remove that private keyword.
Copy the explode method.
Scroll up and we'll paste it right here.
I don't need the braces for 16 and 18, though, so I'm actually going to paste it over them.
I'll select it and paste so that we just have that oneliner.
Now, we'll save and do a quick build just to make sure everything's saved, and then go back into Unity, and we should expect to see our brick blow up after 1 second.
Let's see if that's the case.
I'll press play, run over, turn that switch on, and watch our laser blast through that thing, get some particles.
Let's see them in action.
So, I run through.
Oh, there we go.
And it blew up.
Looking pretty cool.
Let's stop playing though and I want to go add a couple more bricks.
I'm going to take this brick right here and let's add a rigid body 2D component to it.
So, I'm going to add a rigid body to this one because I want to make a brick that can now fall.
I'm not going to add this to the prefab.
I just want to play with it for a moment and experiment and maybe we could make a falling brick later.
Maybe that could be the gray brick as the falling one and the brown brick doesn't fall.
Let's duplicate it though.
I've got my brick with the rigid body.
I'm going to duplicate it.
Drag it up.
Duplicate it.
Drag it up.
duplicate it, drag it up, and press play.
And just watch as all those bricks get destroyed and fall down.
Let's see.
Remember, the one on the bottom does not have a rigid body, so they don't all just start falling down.
There we go.
It's blasting through them.
It stops the second I turn it off.
It won't keep blasting, and then it'll turn back on and start blowing these bricks up.
That is looking pretty cool, I think.
Now I want to go into plastic and commit our changes so that we've made bricks break with lasers or lasers can now destroy bricks.
I'm going to save my scene even with those weird bricks that I've got here and check in my changes.
Now I want to add a visual indicator to our brick for when it's taking damage and introduce you to another new code concept.
Let's open up our brick script.
And inside of our brick, let's add an awake method so that we can cache the sprite renderer.
We'll add the awake.
Just type it out and say underscore sprite renderer equals get component sprite renderer.
I'll add a field for that.
Hitting alt enter just generate a field and delete out my two private keywords.
Now, when we take laser damage, what I want to do is just change that sprite renderer's color to something else and then make it flip back when we're not taking damage.
So, when we start taking laser damage, I'll say underscore sprite renderer color equals and I'm going to go with red color.
Next, I'm going to add in a field for how long I want to show that afterwards.
So, I want to be able to show that it's red for maybe like a tenth of a second after it's taken damage, but that's about it.
So, that it's like red and then it kind of just dissipates down.
So, to do that, I'm going to add a new field.
And that field is going to be my reset color time.
I'll say underscore reset color time equals time plus 0.1f.
So, that's going to give me a time that's 10 or a tenth of a second in in the future or 100 milliseconds ahead.
So, a very very short duration from now.
I'm going to generate a field for it, which should give me a float right up here.
Got my reset color time float.
Delete that private keyword.
And then we're going to add an update method.
I think that we'll do this.
Let's do it right after take laser damage so that it makes the most sense and the code's right next to each other.
We'll add an update.
Hit tab.
Delete out that private keyword again.
And in our update method, we'll check to see if that current time, so if time is greater than or equal to that reset color time.
If so, then we'll reset our color back down to white.
So say sprite renderer color equals color doh.
And this should work, but I want to test it out and then make a little optimization to it.
So let's go try it out real quick.
Let Unity reload.
And I expect these things to turn red when they're taking damage and then turn back to their normal color shortly after.
If I toggle the laser off.
So, let's go do that.
We'll run over here, turn the laser on and off, on and off like that.
It updates properly.
But there's still one issue that we need to address, and that's that our boxes right now, our bricks, are turning themselves white every single frame.
Let's go take a look at that and see what I'm talking about.
If we go into our brick script right now in our update, if the time is greater than that reset color time, which is going to be zero by default, it's going to set this color to white.
Let's add a log here.
Say debug.log set brick to white.
And let's see how often this is actually getting called.
I'm going to minimize my code editor, jump back into Unity, press play, and expect to see a giant spam of that message because every frame for every block, we're calling that code and just updating the sprite color for no reason.
It hasn't changed.
It doesn't necessarily need to change.
So, we could probably optimize it.
Let's take a look, though.
Look at that.
You can see, oh yeah, we're getting basically a couple calls per frame.
Every single frame, we get one call for every brick there.
So, let's modify this code a little bit so that it doesn't have to do that.
So that we don't do this code if the reset color time is reset if it's either at zero or if it's null.
And I want to show you there are two ways that we can accomplish this.
One thing we could do is say if the reset color time is zero, then just bail out of the update.
And we could set the reset color time to zero right here after after our code.
Let's let's do that.
We'll say underscore reset color time equals zero.
And here right before our code, we'll say if reset color time is greater than zero and time is greater than reset color time.
So we'll save.
We'll go back and press play.
And I was thinking about showing a different way to do this, but I think in all honesty, the simplest solution is that one.
And it makes a little bit more sense than my previously thought out solution, which tends to happen.
And I was thinking about using nullables and then I realized I don't really need a nullable here.
I can just put it at zero.
Zero will work just fine, too.
So now if I run over here, you'll see that I shouldn't be getting those log entries every frame.
Only when the brick actually turns back to white, I get one.
So here we go.
Just occasionally get a log entry when when a brick goes back to white.
But I don't end up getting these every single frame.
And I've fixed my problem.
Let's go back into the code.
delete out that extra log entry that we don't need on 35.
Save and then go into Unity and commit our changes where we've got a brick showing visual dam incoming damage.
So, we'll go to plastic soon as that's done so that bricks show damage visually.
And I'm going to make sure I save my scene just in case.
I don't think I modified anything, but I want to check just in case.
And we'll check that in.
Now, we're going to add another enemy to our game.
We're going to add one that's a little bit more intelligent and can start dealing with the laser too and interacting with that.
We're going to use the ladybug.
Although you're welcome to use the spider or mouse or something else if you prefer the visual, but I think that the ladybug is going to work pretty good for what I want to do.
So, I'm going to put a ladybug right up here on this platform away from the laser so that I can start setting it up.
I'll grab my ladybug and drag it right out here.
I'm going to fix up that position.
Looks like -6 and about a one should get it right into place.
Next, I'm going to create an animation for my ladybug so that it can just play a little walk animation while it's running around.
To do that, I'll open up my animation window.
Remember, window and animation.
Animation or it looks like control 6 is the hotkey for it.
With the ladybug selected, I'll hit the create button.
And then we're going to go up into our art folder.
And let's go find our animation folder up in the assets route.
And I'm gonna call this snail walk.
No, not snail.
Ladybug walk.
Thinking of snails.
I just saw the snails a second ago.
So, we've got our ladybug walk animation created.
And now we need to add in our key frames.
To do that, I'm going to take the animation window and just drag it right up here so that it's docked below the scene view instead of docked with my project view.
And I'll take the ladybug sprite, hold control, and take the ladybug move sprite, drag them both up onto the animator, and I should get two frames.
If I hit play now, it's going to be like this weird flashy jittery thing.
Not what I want.
I want it instead to take a little bit longer.
So, I'm going to drag it out to about the 030 or the essentially the half a second mark.
And now I've got, if I hit play, an animation that goes from one to another, but it instantly bounces back.
it doesn't kind of give me that delay before it goes back to the first animation.
So, I'll stop playing and we'll copy this starting key frame just by dragging and selecting it and hitting Ctrl + C.
Then, I'm going to go over to the 1 second mark and paste it in.
Now, if I play, I should get a nice slow animation like I expect.
And if I select all of the frames, I can grab the little bar here and drag it in to speed this up or slow it back down.
But, I think that I like the 1 second mode.
That seems about the speed that I want this guy to move at.
Next, I'm going to add in some more components to our ladybug.
First, let's add a collider.
Let's go to the components.
So, let's get rid of this animation window.
I'll drag it down.
And then we'll go add a new component.
So, I want to add in a collider first.
We'll add a capsule collider 2D.
And to make that a little bit easier for us to see, let's turn this ladybug into a prefab so we can view it in prefab edit mode.
So, here's our prefabs folder.
I'm going to just drag it down so I can see the icons and again have some empty space and take my ladybug and drop it in.
Then I'll double click on the ladybug.
And now I can see that collider much better.
So the first thing I want to do with my collider is change the direction from vertical to horizontal.
Right now that doesn't look like it did anything.
But if I change my Y value now to a 0.5, you see that I now have a nice horizontal character or capsule collider.
If I switch this back to vertical, you see that it looks the same height or the same like a circle because I it doesn't work that way.
If I want it to be a flat thing, I'm going to switch it to horizontal so it's a horizontal capsule.
Now I've got my size about right, but the offset is way off.
It's way up above where I want it to be.
So I'll change this Y offset to a negative and it's going to be half of.5.
So 0.25.
Move it right down into place.
Now I've got a nice ladybug with a capsule on it.
I want to add in a ladybug script.
So, we'll go to the scripts folder, rightclick, create a new ladybug script with just a capital L, no capital B.
It's a single word.
And then once that script completes, I'm going to add it to my ladybug prefab.
Once we're done with that, I think we could probably move out.
No, there's one more component we want to add, then we'll move out of prefab edit mode.
So, let's go get our ladybug any second now once it finishes compiling and we'll add the ladybug script.
And then the final component that we want to add, I'm going to give you a second to just go ahead and guess and add it yourself.
See if you can think of what component we might add to move our 2D character around.
Go ahead and assume you've got it.
We've added the rigid body 2D component.
So, go ahead and add a rigid body 2D and then back out of prefab edit mode.
And we should have a ladybug that we're ready to start working with.
Now, if I just press play, all I expect to see is maybe it's going to animate, assuming that the animator is turned on and checked.
Let's press play and see if that's the case.
So, any second now, we should get our little ladybug doing his animation.
Let's see.
There it goes.
Loading.
Loading.
Loading.
And our ladybug is animating but not moving.
So, I'm going to stop playing and we're going to adjust the code now so that our ladybug can go left to right or just move off to the side and then maybe turn around when it hits something.
First though, let's get a hold of a couple components.
We're going to need to use the collider component here.
We're going to need to reference the rigid body component, and we're also going to need to reference the sprite renderer component because we're going to want to be able to flip that sprite over.
So I'm going to delete the start method and add in an awake.
Inside the awake, we'll get the sprite renderer.
So we'll call sprite renderer equals get component sprite renderer and then generate a field for it.
It's giving me the first field.
Then I'll duplicate that and let's add in one for our collider.
So say underscore collider.
And here we're going to get a collider 2D.
Now, we could get a capsule collider 2D, but I want to make this code be a little bit more um extens not really extensible, but a little bit more versatile.
So, if I decide to change the collider type to a box collider or circle collider, that this code will still work.
And since the capsule collider 2D inherits from the collider 2D class, we can assign a capsule collider here and get that component just by calling collider or using collider 2D instead of using the very specific type of 2D collider.
Now generate a field for that.
Just give me a collider 2D up here.
And then the final thing that we want to get is one for the rigid body.
So I'll say underscore rigid body equals.
And again, we need to get a component, but we need to make sure very that we're very careful to get the 2D rigid body component, not a regular 3D component because the 3D one won't exist, just the 2D.
We need to add a field for that as well.
Now, we've got all three of our fields.
I'm going to delete all of these private keywords by holding Alt, clicking, and dragging over them, and then hitting delete twice.
That's the box delete or box select.
And that's one of the things I love to do when I have a lot of privates or a lot of stuff that I just need to delete out all at once or modify all at once.
I'll get rid of this private keyword here as well.
And then we'll go down into our update method.
In our update method, I want our ladybug to just move in its current direction.
So, it's either going to go left or right and then turn around if it bumps into something.
So, we'll just say that our rigid body velocity is going to be equal to our direction and then maybe times some speed.
So, we'll say times a speed variable.
Now, we don't have a direction or a speed.
So, we're going to go up here and create both of those.
First, we'll create a direction.
This is going to be a vector 2, 2, 2, which will be our direction that we're going, which is really just going to be for left and right, but we could use the x and y if we or the y if we needed to maybe to go up and down.
And then we're going to add in a serialized field for the speed.
So serialized field here that's going to be a float named underscore speed.
And we'll default it at one.
Now, if we just run with this code, it's obviously not going to move because our direction isn't set.
We've got a 0 0 for our direction.
And so our velocity would always be 0 time some speed.
So what we want to give it is some default direction.
And the one that I want to use cuz my ladybugs are going left.
In fact, most of my enemies are probably going to go left is vector 2.
So I'll set it to equal be or be equal to vector 2.
So now it should move off to the left indefinitely.
But I do want it to stop when it hits something.
Let's go just double check that it moves off indefinitely.
And then we can add in the code to check for things off to the side so that it can turn around.
So we'll go back into Unity and we'll play and we should expect to see our our little ladybug guy just go right off the edge and actually kind of keep floating off the edge.
Let's see if that's the case.
So, ladybug goes and walks and just kind of hovers off the edge spinning in circles.
So, let's fix that up real quick.
First, we'll go to the ladybug and we're going to make it so that our ladybug doesn't rotate on its own.
We'll go to the ladybug's rigid body 2D component and check the freeze rotation Z so that it can't rotate on its own.
Next, we're going to go into the ladybug script.
And in the part where we're setting the velocity, what we really want to do is set the horizontal velocity, not the vertical velocity.
If we're falling down, we want to keep falling.
And if something's launching us up, we probably want to keep going upward.
So instead of setting it to equal the direction time speed, we're going to make it equal to a new vector 2 where the x value is equal to the direction.x* speed.
And the y value is going to be our rigid body velocity.
I so that we're not overriding or changing that Yvalue.
We're just going to keep the Yvalue and modify the X.
That should stop our character or our ladybug from falling oddly and make them just kind of fall right down into the lava.
Let's see if that's the case.
So, we'll play and watch.
I expect this ladybug to just drop right down into the lava and then not die because it's not set up to die yet.
Let's see if that's true.
Any second now, as soon as it finishes reloading and we'll run over here, watch that little ladybug go right down onto the lava.
All right, let's stop playing, go into plastic, and commit our initial ladybug and get ready for making our ladybug turn around in the next section.
So, so we've added ladybug that walks into lava and commit.
Now, we're going to make our ladybug a little more intelligent.
First, we're going to make it look for targets or collisions or things in front of it that are blocking it so that it can turn around.
If it hits a wall or hits a block or something, I don't want it to keep going.
So, to do that, we're going to add some raycasts to our ladybug script.
Well, really, we just need to add a single ray cast to it that's going in the forward direction.
So, we'll open up the script.
And before we set our rigid body velocity, let's add a few lines.
And let's first figure out where we want to shoot a ray from on our character.
Let's go take a look at our ladybug right now.
So, on our ladybug, we want to shoot a ray out right from the eyeballs or right from kind of the front or the edge of this collider is even fine.
Like right here.
If we if this thing touches at all, we can probably turn around.
We don't need to go all the way up and bump.
So, I want to figure out what the point is right about here.
And to do that, we can use the collider.
I'm going to go back into the ladybug script, and we're going to create a vector 2 for our origin.
We'll say vector 2 origin.
This is going to be the origin or the starting point of our raycast.
And it's going to be equal to our transform position plus and then we want an offset in our direction.
But we want it to be the direction um times the colliders bounds extents.
But let's actually do that on a new line up above because I think that'll make it even more explicit and more obvious what we're doing.
I'm going to call this a vector 2 named offset.
and we'll use we'll assign it to our direction which is going to be either negative -1 on the x or positive one on the x and we're going to multiply that by our bounds of our collider or the extents of our bounds of our collider.
So say colliderbounds.extense and um oh yeah we want the x.
So we want that far that width off to the x times our direction.
So that's going to give us an offset either positive or negative equal to the extents.
And if you look at extents in the Unity documentation, you'll see that it's always equal to half the size of the bounds.
And this is essentially going to give us the distance from the center of our collider to the edge of our collider.
If we get the extents dox value, that's what it's giving us.
So that's why we're able to get that exact left edge.
Now that I've got that, we can you add that to our transform position to get our origin.
And we've now got a point right on the edge, except that it's giving us an error here because it doesn't want to combine a vector 2 and a vector 3.
So just like before, we're going to cast our position as a vector 2.
Now we've got a origin that should work perfectly fine and it's offset.
So we need to now add our code for the raycast.
For our raycast, we have two different options.
We can do a raycast that finds one object.
Well, there are actually a couple options, but we can do a raycast that returns one object, or we can do a raycast that returns multiple objects.
And there are ways to do multiple object ones that are even more efficient, and we'll talk about those in a little while.
But what we want to do here is actually scan or search for more than one item.
And the reason for that is that when we do the raycast, there's a good chance that we're just going to catch our own ladybug in that raycast.
We might, you know, even if we're right on the edge, we still might end up colliding with ourselves.
It it happens a lot.
It's not going to happen consistently.
And we could, of course, move this off to the edge.
But I think that getting a raycast of everything and then just ignoring ourselves is a slightly easier and cleaner solution.
And it shows you how this stuff works without having to get really tweaky with your exact variables and sliding out, you know, one 0001 further so that you avoid a collider.
So what we're going to use is the physics 2D raycast all method.
So let's scroll down a little bit and we'll say var hits equals physics 2D.cast all.
all.
all.
Now, we need to give it an origin, which we've already created.
An origin.
Origin.
There we go.
Look at that.
I spelled it right.
Then, we need to give it a direction, which we already have.
And then finally, we need to give it a distance.
So, let's call this the raycast distance.
We need to add that as a variable, though.
So, we'll add a serialized field for it.
So, generate a field.
I'll hit F12.
And we'll go up and replace the private with a serialized field attribute.
Let's go fix that s and then cut it.
So shift delete and move it right up here to by our speed.
I'm going to give this a default value of maybe like 0.2.
It's like 2/10enth of a meter out.
A little bit further than one/10enth of a meter out.
And then we've got our hits.
Now we should be able to get back a list or a collection or really it's an array of raycast hit 2D objects.
And then we'll loop through all of those and see if any of them are not our own ladybug.
So to loop through each of our raycast hits, since it returns back an array, and you can tell it's an array there, by the way, because of the two little braces right after the raycast hit 2D, the square braces say, "Hey, this is an array." And raycast all needs to return back an array.
There are also versions of it where you pass in a parameter and that gets filled.
We'll talk about those later, but for now, we're going to loop through each hit.
We'll do that with a for each loop.
So you just type for each var hit in hits.
This is going to loop over or iterate over every single hit in our array and then allow us to run some code on it.
So, I'm going to hit enter, add some braces, and then figure out what that code is.
The code that I want to do here is really to check to see if the thing that it hit was myself.
If it wasn't myself, then I want to flip my character around and just switch the direction and maybe flip that sprite.
So we'll say if hit.c collider is not equal to null and hit.c collider is not orgame object let's get the game object is not equal to our own game object.
Now we could also theoretically compare the collider.
So we could say if hit collider is not equal to the collider that we've cached here.
That would work as well.
Unless I end up adding multiple colliders to my my ladybug, then we'll run into a problem.
So, I'm going to compare the game objects instead of the colliders, and then we'll just run some code.
If I've hit something that's not me, and that code is going to flip the direction.
And to flip a direction or flip a vector 2, all we have to do is multiply it by negative 1.
So, we'll say direction or underscore direction equals, which is going to multiply it by the value after it, and we'll put in a negative 1.
So if it was 1 and 0, it'll become negative 1 0.
If it was negative 1 and 0, it'll become positive 1 and 0.
Zero is that y value.
The x is what's really flipping here.
The next thing that we need to do is flip the sprite renderer.
So we'll say underscore sprite renderer.
If I can spell that right.
Flip x.
And we want to set it to true if our direction is right.
Because our ladybug is facing to the left by default on that sprite.
We want to flip it over if our ladybug's direction is right.
So we'll say it's true equal or if direction is equal to vector 2.ight.
Oh, I got one extra equals there.
So we're assigning it and then doing a comparison.
A double equals there.
That was the error that just disappeared.
So that should do it.
Now if this happens and I find something that's not me, I want to break out of this loop.
I don't want to do this multiple times if maybe I find two colliders there.
So, we'll just add a break.
What that'll do is if this ever we'll loop through each hit.
Any hit that actually meets the condition that's not us, we'll flip it around, change the sprite, and then break out of the loop so that we don't continue on and try to find another hit.
Let's save that and go test it out.
We should now be able to watch our ladybug go back and forth as long as it's hitting something.
Although, right now, our ladybug is going to walk off to the edge.
So, I probably need to add another block over there to the edge to stop him.
Let's do that before we hit play.
We'll load it in.
I'm going to grab one of these bricks, duplicate it, and hold control and just drag it right over.
We'll save.
Press play.
And let's see if our ladybug will do its walking back and forth.
Come on, little ladybug.
All right, there it goes.
And it's walking around.
It's getting pretty close to the edge and stopping when it gets about 0 2 m out.
And I can of course turn this down to like a 0.1.
Let it get a little bit closer.
And um I can turn this up to something like a one and make it turn away much earlier so that it keeps about a meter away from things.
So it seems to be working.
I'm going to put that back to a 0.1.
adjust the speed just to make sure that that's working too.
Looks like a value of two works fine or a value of 0.5 might work as well.
Have a nice slowm moving snail.
But now that I've got my snail moving and turning around on walls, I want to commit it before I worry about making it turn around on cliffs.
So, let's go into plastic.
Make sure that we're saved up and say that ladybug turns around when hitting a wall.
And if you're running into an issue with it, you're having a problem with it, in the next section, we're going to add gizmos to help debug that a little bit more and make it a little bit more explicit and obvious where our ray is happening.
So just continue on to there and see it and hopefully solve any issues that you have.
Hopefully there are no issues, though.
It should just work.
So let's check that in.
Now, one of my favorite things in Unity is the gizmo setup.
It makes it really easy for me to tell what's going on with my characters and my other objects without having to try to figure it out and hold it all in my head.
So, what we're going to add now to our ladybug are just a few gizmos for the ray casts that it's doing.
Right now, it does a raycast forward, but we're going to need another raycast that goes downward to check for the ground as well.
And I want to make that all visualized.
And if you've run into any issues in the last section, should also help you see exactly what's going on with your ladybug.
So, let's open up our ladybug script and we're going to add an ondraw gizmos.
I'm going to do this right after awake.
I'm going to get rid of this update comment because I already know that updates called once per frame and I'll put in an ondraw gizmos.
Now, I'm going to delete that private keyword and then we're going to draw a ray or a line for our raycast.
So, I'm going to get this line this code here for our offset and our origin and I'm going to copy it into ondraw gizmos.
Then right below it, we'll do a gizmos.draw a line which will be essentially like drawing array.
It's going to give us our origin or start at our origin and then it's going to go in some direction or to a destination.
So what we want to do is our origin plus our direction times our raycast distance.
Now my direction got wrong in there.
I got the uppercase thing.
I want to lowerase my underscore direction so that we're actually drawing in the correct direction times our distance.
And now if I save this off, I expect that it's not going to work.
Now there's a good reason for it.
Let's go check it out and see what that reason is.
is.
is.
So we jump into Unity and then when it doesn't work, we'll go look at the error console.
Here it goes.
So we any second now I don't see any lines coming out of here.
Maybe it's just because it's blue or something.
But no, the actual reason is if we look at our console right here, we have an unassigned reference exception.
The variable collider of Ladybug has not been assigned.
And if I double click on it and look at the code, you might be able to figure out why.
Think about this for a moment and see if you know the reason that the collider is null here and not being found in the gizmos.
If you've thought about it, you probably realize that the actual reason for this is that our collider is cached in awake and we can't use this cached reference to it if it's saved off in awake.
So, we've got two options.
We can either move this to on validate so that we save all of these off and serialize those fields and we don't have to grab them in awake or we can just grab this collider at gizmo draw time which will work just as fine.
So, I'm going to copy the get component part right here.
Collider 2D.
Copy it and paste it over the reference to the collider.
This is good enough for now.
And until we get to the point where we've got ridiculous numbers of gizmos drawing, we're never going to notice this get component call.
Changing the way that we serialize this is probably a bigger jump than we need to make right now for there will really be no noticeable performance benefit.
So, we're going to save and come back into Unity and hit clear.
And if it recompiles, we should see it update.
Let, you know, let's go back in and let's change the color of our gizmo first.
Right here on line 29, we'll say gizmos.color equals.
And we could use yellow.
I want to use red because I think that red shows up really well.
So, we'll change the color to red.
Go back into Unity.
Let it recompile.
There we go.
And then we expect to see a laser beam or a gizmo ray just shooting right out of the front.
Let's see.
Come on.
Pop up my little gizmo.
Are my gizmo's off? Oh, there it is.
I just missed it.
I was blind because the ray is right up here.
So, the reason that it's up here, by the way, and if you were curious about that, is that we're using the center or the origin X value of our character to shoot out of instead of the actual kind of center of our sprite or the center of our collider's height.
So, there's the ray.
It just happens to be on a grid line.
If I press play, go into scene view, you should see it moving around.
Let's watch.
Let's see.
There it goes.
And let's watch it in scene view.
Now you can see that red line.
And as soon as the red line touches, it turns around.
So that's our ray that we're using.
And we've got a nice visualization for it.
Now, before we complicate this with our second ray that's going down, let's check in our code that we've added gizmos for our ladybug ray.
added gizmos for lady bug raycast and check that in.
Now let's create the gizmos for our downward raycast.
Then we can see it before we hook it up in our code.
I'm going to start by opening up our ladybug script.
And we're going to use the bounds of our collider this time instead of using our center or well actually we're going to take the bounds and we're going to do a little bit of math with it I should say cuz we are using the bounds already but we're going to use it in a slightly different way.
So first thing I want to do is just cache this collider component because I'm going to be using it in just a moment to get the bounds again.
So I'm going to cut this and replace it with collider and then one line up I'll say var collider equals and then paste.
Now I'll just get it once per gizmo draw instead of multiple times and it'll shorten out my code a little bit.
Now the next thing I want to do I add a little space there is go down here and we're going to get the bounds of that collider.
So we'll say varb bounds equals collider.bounds.
And this is going to give us the positions in world space of all of the edges or the corners of our collider and the center of our collider.
Then we're going to get the bottom left corner of our bounds.
And to do that, we're going to say var bottom.
Let's call it a vector 2.
Let's call it what it is.
Vector 2 bottom left.
And it's going to be equal to a new vector 2.
And the x position is going to be our bounds.
Minus we want the bounds.extense.x.
So this is going to give us a position all the way off to the left for the x.
Then we need to figure out our y position where we'll use the bounds dot set.
I I lied.
I said center.
It's center.x.
We use the bounds.center.y and our y value.
And we'll subtract the bounds.extense.y.
Hey, look at that.
It already knew what I wanted.
So, I'll just let it autocomplete.
That should give me the bottom left corner.
Now, if I wanted the top right corner, I could put plus here and a plus there.
Or if I wanted the bottom right corner, I could hit a plus for the X.
So I get the right hand side and the bottom would be the minus for the Y.
So this is giving me that bottom left corner and I'm going to draw a gizmo in that bottom left corner.
So I'm going to select line 32, copy it, paste it in here, and we'll go from bottom left, paste over origin to bottom left plus vector 2 down times our raycast distance because we don't care about the direction.
Now, this is going to work partially, but it's only going to be good for that bottom left.
Let's go check it out.
When our snail gets to the edge, that ray is still going to be showing on the wrong side or on that left side.
So, let's try that and make sure that that's the case first.
Oh, there we go.
You can see that little red line there.
If I hit play and watch it in scene view, I expect that red line to just stay there on that left of that character.
Let's see.
It is named bottom left.
So, it probably shouldn't be switching until we've renamed it and updated the code at least.
All right, we go into the scene view.
You can watch that ray going along.
Looks good, but it's doing exactly what I expected.
Now, we'll go back into the ladybug.
And what we want to do is determine if we're going to use the bottom left or the bottom right based on the direction.
So, we could actually just multiply this bounds.extense.x times our direction.x.
So that way it'll either be it'll get flipped over to an inverse or negative if we've switched directions.
But I feel like that's probably a little bit confusing.
So instead, what I'm going to do is create a new vector for the bottom right.
And then we'll just use either the bottom left or the bottom right based on our direction.
So if we we've got our bottom left one, I'm going to duplicate that.
We'll add a bottom right.
We'll duplicate, add a new line on our gizmos to draw on the right.
So now we'll draw one on each side when we're doing our gizmos.
But we're only going to do the one that we care about for the direction that we're currently moving.
So I'm going to add some new lines here.
And I'll say if direction is equal to vector 2.
Then we'll run these two the bottom left and the gizmo for that.
Let's cut cut that line and paste it in.
And then we'll say else will run on the bottom right.
So now we've got code that runs for bottom left or bottom right depending on which direction we're going.
Let's go double check that in our code or in our editor.
Make sure that it actually shows the correct gizmo.
And then we can start worrying about how we're going to hook this up to a raycast and check for some ground below.
But that should be probably the easiest part.
I feel like the hardest part is figuring out where these raycasts go and getting them drawn in place.
So let's play.
Watch our ray cast bounce back and forth ideally assuming that nothing went wrong.
Go to scene view and oh our ray is not switching directions.
So we are changing directions but for some reason it's not actually drawing on that that left side direction.
Let's go double check that I actually committed my code or saved my code.
Oh, here's the problem.
I didn't change the code on the bottom right to actually go off to the right.
So, we'll go select that code, change it to be a plus on the extents, and then we'll jump back into Unity and it should do the correct direction.
This is exactly why I wanted to do the gizmos because I feel like it's very easy to accidentally miss a little thing like that and then get stuck forever trying to debug it and not be able to visualize it.
So, the visualization makes a huge difference in speeding that process up.
Any second now, I've got to restart my computer.
got too many things running right now.
So, my compilations are killing me.
But as soon as I hit play, I should expect to see that ladybug switching back and forth with the gizmos shooting out of its face kind of downward down below so that we can do our raycasts.
All right, let's see.
There goes our ladybug.
And look at that.
The gizmo's changing.
We can see it back and forth.
It's looking pretty good.
I think it's time for me to go into plastic and commit that we've added gizmos for downward for our downward ray.
And we're ready to add in that ray next.
Now, let's turn our ray into an actual array or turn our gizmo into array so that we can actually have our ladybug turn around.
and we'll do a little bit of cleaning up and refactoring along the way.
We're gonna open up our ladybug script.
And the first thing I want to do is modify our gizmo code where we're figuring out what bottom corner we want to use.
Let's turn that into a reusable method so that we don't have to copy and paste this code and this direction checking code and all of that.
So, first we'll actually start by just copying and pasting it.
I'm going to copy line 36 through 45.
And then we're going to add a new method right below that returns back a vector 2.
I'm going to name this I think uh what do I want to call it? A get down ray position.
Something like that.
Let's let's go with that.
Get down ray position.
And then we'll paste in our code.
What I want to do here is instead of drawing a gizmo, I just want to return back one of these vector 2s.
So I'm going to delete out both of the gizmo lines here.
And instead of assigning a vector 2 here, I'm just going to replace this with the word return.
So, we'll return back a new vector 2 that's off to the left if our direction is left.
Although, we do have an error here saying that it can't find our bounds.
So, we're going to need to copy line 35 and paste it in here.
and then replace the collider with the underscore collider because here well actually to be honest this is going to be an issue because if we just use the collider here we're going to run into a problem of in the gizmos this may or may not work.
So let's make it so that we can pass in a collider instead.
We'll take a collider here as a parameter and now our error is gone.
Now, the last thing we need to do to get rid of our error is make sure that we return something even or in all of our paths.
Right now, it's saying that not all code paths return a value.
That's because if it's left, we return a new vector 2.
If it's right, right now, we assign a variable.
That's not what we want.
We want to return that right variable or that right offset.
Now, I don't need these braces here because there's only one thing happening in each of these lines.
So, I'm going to delete the brace.
Delete the braces.
just shift delete to get rid of them all.
Now I've got a ray position method that'll give me back array position and I want to use it in my gizmos first.
So I'll copy get down ray position and I'll just put that oh let's put it right here.
I'll say var down offset or down origin.
Let's call it down origin equals get ray down ray position and we'll pass in our collider.
I'll delete out this bounds code and delete out everything except for that one gizmosdraw line.
Shift delete.
Shift delete.
Shift delete all the way until I've got it lined up.
And then we'll replace bottom left with down.
Double click paste.
And double click paste with down origin.
Crl Krl D should fix up my formatting.
And now I've got a method that I can use to get that downward ray position.
and it should still draw that downward origin um or that downward ray in my gizmos.
Let's just go double check it in gizmos.
Make sure that it still works, that it's still showing in the right position, that our refactor didn't break something when we extracted that code out into its own method.
And if it is good, then we'll jump back in and we'll finish up with the ray casting.
So, we play, we should expect to see our character do exactly the same thing that it was doing right before, just moving back and forth and changing that uh that ray position from the left to the right, but not actually using that ray yet.
So, let's see.
We'll go into the scene view.
Yep, it's still working fine.
It's getting the position and it's swapping back and forth.
So, let's make the final change in our ladybug, which is going to happen down in our update.
First, let's add a space here after the get down ray position and update.
I don't like to have no space between methods.
I always like to have one space, exactly one space actually, between each method.
So, in our update method, before we check to see if we've hit something off to the right or we've hit something off to the left, let's make sure that there's actually ground in front of us to continue walking.
So, we're going to add a couple new lines here.
And first, we're going to just add in a boolean variable for whether or not we can continue walking.
We'll say bull can continue walking equals false.
And if we don't find any ground in front of us, we'll never set that to true.
And we'll just return.
So let's uh say if we can't continue walking, if can continue walking is equal to false, then what do we want to do? Well, we want to switch directions.
Let's copy all of this line 66 through 68.
We want to switch directions, flip the sprite render, and we don't want to break because we're not in a loop, but that's not what we're trying to do.
Instead, we just want to return.
So, how do we set can continue walking to true? Well, we're going to need to do array cast next.
So, we'll do that just like we did down here on line 63, but we'll do it on what is this 55.
We'll say var down hits.
This is going to be our downward hits equals physics 2D.cast ray cast all and we'll give it our downward origin which is going to be calculated from our get down ray position.
So I can pass in get down ray position and give it our collider as the first parameter.
And then for the second parameter we'll give it a vector 2down.
Oh, I need to add the underscore to our collider.
That's why we've got an error here.
And then finally, we'll give it a distance, which is our raycast distance.
Now, personally, I like to split this method out and give it another parameter or another variable here.
So, it's a little bit more explicit and just spells out what we're doing here.
And I'll do that by taking this get down ray position and just cutting it onto my clipboard, adding a new line, and say var down origin equals and paste.
Then I'll put down origin here just so that it's a little bit more explicit.
Again, works exactly the same, but I like to see the variables here.
I can debug it a little bit better and understand what's going on a little bit better.
Now that I've got my down hits, we need to loop through them just like we did before.
So, say for each var hit in down hits.
And we can't name this hits, by the way.
It has to have a unique name so that it's not um redefined down here.
We could, but we'd have to remove this var part.
And I like to use a separate name because I think it makes it a little bit clearer and cleaner understanding what we're doing.
So, we're going to loop through each hit and we're going to do the exact same check here.
If the hit collider is not null and it's not our game object, so I'll copy line 72 and paste it.
If it is not null and it is not our game object, then we can continue walking.
So, can continue walking will get set to true.
Otherwise, we'll just uh not ever set it to true and we won't be able to continue walking.
This should do it.
This is enough to get us walking.
Let's go test it out.
We'll jump over here.
Go find our ladybug again.
And what we're going to want to do is turn this block off so that the block isn't there blocking it.
Or the block isn't there stopping the ladybug from walking over.
Let's go find that brick, uncheck it, press play, and let's watch.
Our ladybug should now walk to one edge, turn all the way around, bump into something, and turn around again.
Let's see if that's the case.
All right, it's loading up.
There goes our ladybug walking over to the edge and turning around.
Let's go.
Let's go break these bricks, too.
So, it's going to turn around until it runs out of bricks.
And then it should walk all the way to the edge.
There's nothing going on with the laser to interact with it.
Right now, the raycast stops on it and ends there.
And our laser blaster doesn't have a collider in it, so it should just walk right through over to the edge and then turn around.
It's looking pretty good.
And I think if I turn the um if I adjust that platform a little bit so that it's slower, we can still kind of bug him out so that he'll walk on it and fall off because he won't stick to the platform yet.
But so far, I think this is working pretty well.
So, I'm going to go into plastic and commit that our ladybug now um walks doesn't fall off of ledges or doesn't walk off of ledges.
So, I'll save my scene.
The ladybug no longer walks off edges.
and check it in.
Now, we're going to make our ladybug interact with the laser.
Currently, the laser just shines onto the ladybug and doesn't do anything to them.
So, let's make a little modification to the laser script so that it can stop a ladybug in its tracks and then talk about how we can abstract that out a little bit.
Let's go into the laser script.
And in our laser script right now, we look to see if we've hit a brick.
And if we have, we tell it to take damage.
Let's add in some code to also hit a ladybug.
We'll copy lines 36 through 38 and paste them down below.
And I'm going to replace brick with ladybug.
We'll copy ladybug over the three other instances, including the type here.
So, lady, I got to spell it out here.
Bug bug with a lowercase B.
This one needs to be that capital because it's the actual type.
Now, we've got an error here.
It says that ladybug doesn't take laser damage.
There's no method on it.
So, we're going to need to add one to take laser damage.
I'm going to hit alt enter and just generate a method.
We'll hit F12 and go into that method.
And I'm thinking for the ladybug, instead of killing it like the um bricks die, I want to make it just freeze the ladybug.
So, if it hits the ladybug, the ladybug just doesn't move until the laser's off.
It just keeps them totally still.
And obviously, we could easily just change it to do death or something else.
But for now, I'm going to say rigid body.locity equals vector 2.0.
I'm going to replace internal with public and then save this off.
Now, my expectation here is that once the laser hits the ladybug, the ladybug should just stop working.
Though, I don't particularly like the code.
And we're going to talk about why that is and talk about how we can improve it in a moment.
First though, let's just play and make sure that this is the case, that the ladybug actually stops when it gets hit hit with the laser.
So, as soon as we finish reloading, we'll play, we'll run over, turn on that laser, and then make sure that it's updating or I said updating, but really it's freezing, right? All right.
Any second now, it should load up.
and we'll go flip on that switch.
So, our ladybug should be walking back and forth.
Turn the switch on.
I'm going to kind of jump over here and watch.
And look at that.
Every time it hits the ladybug, the ladybug freezes.
So, it is working.
It's doing the expected thing.
But we have a problem here, or at least what I would perceive as a problem, and that's that every time we want to add something new to our laser, we're going to be copying and pasting this code, adding a take laser damage or maybe some other type of method to this thing so that we can make it deal with laser damage.
And I don't particularly like that.
I don't want our laser to need to be updated every single time we add something else that needs to take damage from our laser.
We shouldn't have to go back in and modify it every time.
This is part of that open closed principle that our class should be open for extension but closed for modification.
Really meaning that if we add new things that interact with and use it, we shouldn't necessarily have to go in and change this class.
Now, there might be scenarios where we've done so much where we change it so drastically that we we just have to.
But most of the time, we can avoid this.
And we can avoid this by using one of two things.
Either abstract classes or interfaces.
And in this scenario, an interface is probably the perfect option.
So, we've got this take laser damage method, and both our brick and our ladybug can both implement it.
They implement it totally differently.
And really, all our laser cares about is that the thing that it's hitting can take laser damage.
So, what we're going to do is add an interface that's common and shared between our brick, ladybug, and anything else that needs to take laser damage called I take laser damage.
then we can add that on and simplify this code here.
So to do that, we're going to go into our ladybug first and we could do the extract interface option.
So if I hit alt enter, I can hit extract interface and I can choose the members that I want to have here.
There's the I or the take laser damage is the only public method that we have.
So that's the only option available.
And the default name for it is I ladybug because it's going to put an I for an interface and the default or the existing class name.
I want this to be a take laser damage interface though.
So I'm going to make it a little bit more generic by putting I take laser damage here.
I'll hit enter and that's going to generate a new public interface named I take laser damage with a void take laser damage method.
Notice that it doesn't say public here.
That's because everything in an interface is going to be public by default instead of private by default because that's the way interfaces are made to be the publicly facing interface for this type of thing or this type of object.
So now that I have this I take laser damage, let's go back into our laser and instead of calling it our code on a ladybug, let's replace this with I take laser damage.
Now, I'm going to replace the word ladybug with damageable or let's say uh laser damageable.
And then we need to also add something on line 40 because we're using an interface now and not a class, not a specific mono behavior or something that is definitely a class.
When we do our null check here, we can't just check it like this.
We have to actually say if it is not equal to null instead of if it's true.
And that's just because of the way that it does the overloading of that if statement.
If you just pass in an object, it will return true if that object exists or and false if that object is null or doesn't exist.
But with an interface, that's not the case.
We actually need to do the check there.
The overload doesn't exist like that.
So, we'll save.
And now I've got a take laser damage method on a laser damageable.
But I still have this brick one here.
And I want to get rid of the brick part, too.
So, I'm going to select lines 38 through 36 and just delete them.
But now, my bricks aren't going to take laser damage.
And that's because they don't implement the I take laser damage interface.
But I can make change that.
I can make it so that they do just by copying the interface name.
I'm going to save so I can get rid of that star.
Go over to our brick and right after the mono behavior, we're going to add a comma and add in our interface.
You may have noticed that on the ladybug that happened automatically.
And what what this is is telling us that this is a mono behavior as its class, but it implements this I take laser damage interface.
And you might notice in some other code that you write that you can actually have multiple interfaces.
I could have an I take laser damage, I take hits from above or whatever other type of interface that I want to add.
I that doesn't exist right now.
So I'm going to delete it out and save off our ladybug.
Now that we've got our ladybug and our brick both taking laser damage or implementing this method or this interface, we should be able to run into Unity and have it work.
Now, this only works because this method existed and had the exact same name.
If this was named like brick take laser damage, then we're going to get an error here.
The interface is going to say, "Hey, brick does not implement the interface member take laser damage because I renamed it to brick take laser damage." And then I would have to hit alt enter implement the interface down here and then go put in the code for the method.
I don't need to do that though because I've already implemented it.
I just renamed it and broke the name.
If I remove that brick word again, just put it back to take laser damage and that name matches the method in here.
It should work.
Let's jump into Unity, go play, and see that we get the exact same behavior but with a little bit less code.
And then we now have an interface that we can start adding on to other things that we want to deal with lasers.
If we got something that we want to warm up or move or other things that we want to just die or blow up, we can just add that interface and then have them deal with the code however the specific object wants to.
So, let's go try it out.
We run over here.
We should be able to turn that on.
Watch it go.
Seems like it works.
The bricks blew up and the snail stopped in its tracks.
Let's go into plastic SCM and make sure that we've saved our sandbox scene and say that we added the I take laser damage interface and we'll check that in.
It's time for another challenge.
I want you to try using some of the things that we've already learned to add in a new visualization for our laser.
Right now, our laser just kind of ends at the thing that it lands on.
And I'd like to modify that.
So, if we go to the laser folder, you should see some laser blast.
What is this called? Laser yellow burst.
And I'd like you to implement a laser burst that shows up at the edge of the sprite.
So, it shows up right where the laser is hitting and then pulses and gets bigger and smaller.
So, go ahead and try to do that on your own.
Whenever you're done or ready, just continue on and I'll run you through the steps and show you the the easiest, simplest solution that'll work and get this done for you.
But I want you to give it a try on your own first.
See if you can figure it out and then continue on.
So go ahead and now I'll assume that you've either done it or decided not to.
So we're going to rightclick on our laser and we're going to add in a new game object.
I want a new sprite that's going to be a child.
I'll just use a square and I should get a big fat square there.
I'll drag the laser yellow right here.
This little laser yellow burst into there.
And then I'm going to just drag it over to the side so I can see what it looks like.
If I drag it right to this position, I can tell that it's behind the sprite renderer because my sorting layer is not set.
I want to put this on props.
And I'll just set the order and layer up to a one so that it's up above my laser beam.
Now, this will work fine as long as my laser beam doesn't move, but my laser beam is definitely going to move.
So, I need to modify the code so that it can move this object to wherever I've hit my laser point.
So, let's rename this object to laser burst.
And then let's open up the laser script.
We'll give ourselves a reference to that laser burst.
So, we'll add a serialized field that's a sprite renderer.
And we'll call this laser burst laser burst.
And then I'm going to copy that laser burst.
And down in our code where we set the end point, let's just set the position of this laser burst to be exactly at that end point.
So I'll say laser burst.t transansform.position equals end point.
This should move that laser burst directly to where we want it to be whenever it's whenever it hits something.
I do want to however turn the laser burst off if our laser is not on.
So I'm going to expand out our is on code.
add some braces and before the return I'll paste in laser burst and putten enabled equals false and then down here where we set the laser burst position I will say laser burst enabled equals true.
So we'll turn it on if we've got a valid position and we'll turn it off if we don't have a valid position.
Now if we don't hit anything it's really up to you to decide.
Do you want to leave the laser burst sitting on the laser or do you want to get rid of it? If you want to get rid of it, you could just copy this line here, add an else statement, and paste it in and replace the true with false.
Now, we won't get a laser burst until it actually hits something.
Let's save, check that out, make sure that it works, and then figure out the pulsing part next.
So, we'll go in, we'll press play.
Oh, we've got to assign the laser burst before we press play, though.
Otherwise, we're just going to get a null reference exception.
So, as soon as it's done compiling, we'll drag the laser burst onto that laser burst field.
That's going to be this child right here.
And then we'll press play and watch that burst end up at our end point.
So, any second now, we'll take that.
Oops, I just clicked off the object.
Let's go click my laser again and then drag that laser burst down.
I'm going to save my scene just to make sure that I don't forget to save before I do any committing.
And press play.
And my laser burst should now appear at the end of the beam.
Well, right now it's kind of it's cheated because I moved it into that position beforehand, but whenever it starts playing and we actually see the laser beam going out, we should see that burst matching up with the end point.
All right, we're entering play mode and we'll run on over.
And that burst is showing up there.
If I get out of here, I can see that.
Yep, it goes to whatever thing it's supposed to land on.
Now, let's stop playing and add in the code so that it can pulsate.
I want this thing to get bigger and smaller over time so that it kind of feels a little bit more alive.
To do that, we're just going to modify the transform scale.
And we can do that right here on line 42.
We'll say laser burst.transform.local scale.
And we want to set it to vector 2.1 or vector 3.1 really times some variable.
And remember when we used the math f.ping pong and time dot time.
We can do the same here.
So we're going to set it equal to vector 3.1 times.
And here we'll do math f.pingpong just like we did before.
and we'll give it time dot time as the first parameter and 1F so that it goes between zero and one over a 1 second period.
Now if I just do this I'm going to get a variable laser blast that goes all the way down to 0000 which is going to cause some problems and then back up to one.
Instead of that though I want it to be slightly different.
I want to go from 0.5 to 1.5.
So, I'm going to add some parentheses here and I'll say 0.5 plus our math f.ping pong.
Oh, I think I need to add an f right here.
Be a little bit more explicit that it's a float so that I can add my float to the floating value from the ping pong.
So, this is going to give me a value from 0.5 at the smallest to 1.5 at the largest and it's going to go over one second with that iteration or that looping.
Let's try it out.
out.
out.
Hopefully, you were able to remember and use the math f.ping ping pong when you were trying to figure this out.
By the way, that's one of the key things that I want to make sure that you remember these things exist.
And remember that it's a lot easier most of the time.
We don't necessarily need to add an animation and an animator or do a bunch of crazy code.
A lot of the time we can just do a simple oneliner like this to modify things over time and do these cool little visualizations.
So, let's play.
Make sure that our laser is pulsing and then once we're good with that, we can check it in.
All right, let's see.
Here it goes starting up.
And again, my startup times are slightly slow right now because I'm copying a million files off my hard drive and just beating up my system while I record so that I don't keep running out of space while I'm recording.
All right, we press play play play and the laser is off.
So, we'll turn it on.
And look at that.
The laser is growing.
It's pulsing.
And I think that that looks pretty freaking cool.
So, let's go into plastic and make sure that we've saved our scene and say laser has or we'll say that we added laser burst to the laser beam and we'll check that in.
Now, we're going to make our ladybug both deadly and useful.
I want to make it so that our player can bounce on the top of the ladybug to get to different places, but also make it so that there's some danger if they touch the ladybug from the front or the back.
The easiest way to add in some damage would be to just add our spike script that we've already created that damages anything that touches that component.
So, let's go add a spike script right now.
Let's go double check what that spike script does so we can remember.
And just look here that we look for an on collision enter.
And if we hit a player, then we tell that player to take damage and we give it the normal so that it can bounce back.
So, let's go back into Unity now.
Now, if we play and try this out, we should expect to see that the ladybug doesn't actually run up and touch us because it's doing that ray cast.
It's finding us and turning itself around.
Now, I can still land on it and take damage, which not what I want to happen yet.
And I can kind of run up behind it and take damage.
So, it is dealing damage, but it's not dealing damage by walking into me.
So, I want to modify the ladybugs ladybug script just a little bit so that it will ignore my player when it's determining if it should turn around.
To do that, we'll stop playing and open up the ladybug script.
And then in the part where we check to see if we've found anything in front of us, which is down here, we want to do an extra check to see if the thing is on the player's layer or if the thing is is a player.
We have multiple ways to do that.
First though, I want to reorganize this code just a little bit.
Let's take the code for can continue walking, the part that's checking the ground in front of us to see if the ground exists in front of us.
And let's just select all of that and move it out into its own method.
So I'm going to take everything from 55 down to 69 which is from the part where we initially get our can continue walking our two downward variables or vectors or this is a vector and that's our raycast hit array.
So we've got our down origin and our down hits our loop and then our check here.
So let's take all of that and hit alt enter and oh looks like extract method's not popping up.
So what I'll do instead is settl x and then we'll write the name of a method and I'm thinking that we'll call this check ground in front.
We'll add the semicolon at in the two parenthesis.
Then I'll hit alt enter and generate the method.
Inside of that method I'll paste over this throw exception all of my code.
This should work exactly the same.
But now my update method is a little bit easier to understand.
I can see that in update I get some vectors.
Then I check the ground and then I do some stuff with those vectors.
So next I want to rearrange this a little bit.
Let's move the check ground in front up.
So I hit control X and move it to the beginning of my update because these two variables aren't used by that and they're not used until we get down to this code that's checking for things that are in front of me.
Next, I'll get rid of these extra spaces and I'm going to take this code that checks for things in front of me and let's extract that out as well.
So I'll select it all.
See if alt enter pops up.
Ah, there we go.
The extract method option is now available.
I'll hit enter there.
And we'll call this check in.
Oh, do I want to call this check in front? Yeah, let's call it check in front.
And then I think we're good.
I like that.
So I've liked this little refactor where both of our methods exist and the code is a little bit easier for me to understand.
And now in my check in front, I have to decide how I want to determine if the thing is a player.
I've got again two options.
I could check right here to see if the player has a or if the collider has a player component on it and if so just not do this code or I could add a layer mask here so that I can ignore specific layers and make it um just continue walking into those layers.
I'm kind of torn on it because really it's about the same either way, but performance-wise, it's a little bit better for me to do the layer mask check.
So, that's what we'll go with.
And to do that, we're going to add a new parameter to our raycast all.
So, when we do our physics 2D raycast all in that forward direction, our fourth parameter will be a let's call this a forward raycast layer mask.
So, we'll have a forward raycast layer mask and we'll hit alt enter and then we're going to generate a field for it.
I'll hit F12 and it's going to give me the wrong type.
It always does this when you generate a layer mask.
Instead of giving a layer mask, it gives an int, but we can just replace this with layer mask and then replace the private keyword with the serialized field attribute.
Now, I'm going to move this up.
So, select the whole line, hit controlX or shiftde, and then move it right up here below my raycast distance.
I'll save that off.
Let's go back into Unity.
Well, first let's do a build.
Control shiftB and make sure that the build works.
Oh, looks like Oh, weird.
Somehow I got an extra weird using statement up here.
I'm going to go hit shift delete.
And I'm going to hit shift delete on all these extra using statements that I've got up there, too.
Not sure what added that.
Something in Visual Studio must have gotten confused.
We'll do another build.
Make sure that it succeeds.
There are no errors, no missing braces or anything.
Then we'll jump back into Unity and let's go check out our ladybug script.
We should now have that layer mask.
And if I press play, it's going to do something a little bit strange.
Let's watch.
So, there goes my ladybug.
And it's walking, walking, walking.
And when it gets to that brick, it's just going to keep going and keep trying to push the brick and not not stop.
So, we're going to change the layer mask to be everything.
That'll make it turn around, and that'll also make it, of course, turn around when it gets to the player.
And then if I change that layer mask to not have the player on it.
Bam.
Bam.
Look at that.
The player is starting to take some damage.
All right, that is closer to what I was looking for.
Let's let our player die.
We'll stop playing.
I'm going to go back to that ladybug.
I'm going to adjust that layer mask while we're not playing.
Unset the player so that it's mixed with everything except for the player.
And then I'm going to go to the overrides and apply all so that our changes get applied.
Next, we'll go into plastic and say that our ladybug turns around with the forward raycast layer mask and deals damage to players or ladybug deals I think deals damage to players is probably enough.
And I'll check that in.
Oh, I haven't checked in saved my scene.
So, we'll save our scene and we'll make one more checkin.
say added sandbox scene from previous commit and we'll check that in as well.
Now let's stop this bug from damaging us on the top and do a little bit more refactoring and renaming.
We're going to go to the ladybug script and find the spikes script.
And the first thing I want to do is write the code so that we don't take damage if we hit it from above.
We've done this a few times already using that dot product.
And I'd love for you to go ahead and try to do it yourself.
Give yourself a few minutes.
See if you can write the code to ignore hits from the top.
It should be about three lines of code.
And then when you're done, go ahead and continue on.
Or if you just want, go ahead and continue on as well.
All right.
So to do this, what we'll need to do, assuming you haven't done it already, is add a serialized field with a boolean for ignore hit or let's say ignore from top, not from, from top.
So we've got a boolean there that we'll just check against.
So I'll add in an extra space here.
And then in our on collision enter, we'll check to see if that ignore from top is set.
And if so, we'll check to see if um well I if we hit from the top.
So we'll say if ignore from top and then we want to check the vector 2 dotproduct of our collisions normal which is that collision contacts zero.
And this is again an array of different contacts.
If we somehow have a collision where we have two things touching at the exact same frame or maybe we're in an on collision stay where that's more likely where we have two different points touching we'll have more than one contact but most of the time we'll have one contact at index zero.
So we've got contacts 0normal which is going to give us the direction of that contact or the direction of that collision.
The dotproduct will then compare that to vector 2 down.
So we'll compare the direction that we hit to the downward direction.
And if those exactly match, we'll get a value of one.
If those are exact opposites, we'll get a value of negative 1.
And then we'll get a value somewhere in between if they're not matching.
So zero would be completely perpendicular.
So what we can just check to see is if it's greater than maybe like a 0.5.
That way if we hit it on the edge pretty good, we don't hit it directly top on, we'll still bounce or we'll still not take damage.
Um, so if we've hit it somewhere from the top like that, we'll add in a closing parenthesy that lines up with that closing parenthesy.
Then we'll return.
That's it.
That's all we need.
That should prevent us from taking damage.
Let's go see.
So, we'll jump back over here.
We'll turn that option on for the spikes on the ladybug.
And we'll press play.
And I should be able to walk up to him, take some damage, and then jump on top of them and not take damage.
In fact, let's just jump on him first.
No damage.
And then if I let him walk up to me, ooh, take some damage.
But if I land on him, he's pretty safe.
So, it is working.
That's exactly the behavior that I want.
But now I've got an issue that I really don't like the way that this code looks.
This right now has a ladybug with a spikes script on it.
And the spikes were intended to be those spike objects that obviously completely take hits from the top.
So, having this thing be named spikes and be reused against on multiple objects.
I've got it on my ladybug.
I've got it on, I think, on my frog and I've got it on my um my actual spikes and I think even on is it on the the lava, too.
There's a lot of things.
So, I'd like to change this.
Now, I'd like to rename our spike script to be something that makes a little bit more sense for what it is.
And I want to do that without completely breaking my project.
So, the first thing that I need to do, well, let's save my scene and then go find my spike script.
So, I'm going to click on it and select it.
Go right over here, find the file, and rename this by hitting F2.
Got it selected.
There we go.
F2 or a single click should do it.
And I'm going to rename this to damage player.
Now, that's not going to do it alone because now my script is named damage player in the file, but the class is named spikes.
it opened up in the code editor to show me that.
But I if you didn't open up your code editor, just double click that damage player file and it should open up.
And if it still doesn't open up, you can always go to assets and then look for the open C project and that should force it to reload and hopefully find your project or go over to the solution explorer which is right here on mine and then find it in your list.
Once you found your damage player script, you need to find the class name right here where it says spikes.
Hit controlr controlr and name this damage player.
Need to match the casing and the name exactly with the file.
Now, if you use um rider, it'll actually automatically do that for you.
If you rename here, it'll rename the file for you.
I don't think Visual Studio does that, though.
If you just go in here and rename the class, it won't just go rename the file automatically.
But either way, we've got it matched up now.
We've got damage player, damage player.
Let's go back into Unity.
Haven't touched anything yet since I've been letting this change.
And I can see that my damage player script is still here.
It looks like it's working.
I'm going to go take a look at one of my other scenes.
Let's go look at level one and make sure that the damage player script is still on the things that I expect to damage the player.
Like uh did my lava have that? I'm trying to remember now.
I believe it did.
Yeah, damage player.
Perfect.
And it should of course not ignore from the top.
And my spikes also have the damage player script.
So now it's looking a lot better.
I think that the script makes a lot more sense.
And the last thing we need to do is make our guy actually bouncy.
But I think we'll do that in the next section.
For now, let's save.
Make sure that our sandbox is saved.
Got our damage player now checked in or ready to move.
Notice that there's a move now in here.
When we rename a C file, or really if you rename any file, it's going to count as a move in your source control instead of a rename.
There isn't usually a rename thing there.
It counts as like moving the file from one path to a new path.
So, we're going to say that we made the spikes into a damage player script and gave it an option to ignore hits from the top and check that in.
Now, let's start bouncing on our ladybug.
We've got a couple options just like always for how we could accomplish this.
We could add that bounciness factor in the material or the physics material like we did with the spring.
Maybe go select the spring material and then have it be somewhat bouncy.
But that's not going to give me the exact behavior that I want because this thing is kind of running up to things and it's going to be bouncing itself.
That's going to make this object bouncy.
And I don't really want this guy to be moving around, bouncing on things or acting bouncy at all.
I just want to be able to bounce when I land right on the top of them.
So, I'm going to undo that change and instead we're going to open up the damage player script.
And then we're going to copy it.
We're going to use this damage player script as a template to create a bounce player script.
So, I'll take all of this code from line 25 up to line six, copy it, and then go down below, hit enter a couple times, and paste.
We'll replace the word damage with bounce cuz that's what I want it to do.
And then, when I think about bouncing a player, I probably want it to bounce from the top only.
I very rarely want to ignore the top.
Instead, I probably want it to have maybe an only from top option or always be only from the top.
But I can see reasons for allowing it to bounce from other sides.
So let's add an only from top instead of an ignore from top.
In fact, let's just rename this to be only from top.
And then we'll have to change the code.
So if we're checking to see that it's only from the top and our vector here is greater than.5, then we're actually doing something incorrect.
We're checking here to see if it's uh only from top.
But then if we are from the top or I can't get my words out here that means that we'll have to reverse this arrow here to check that we're less than.5 so that if we're not from the top and we have the only from top option selected we'll return.
Otherwise we'll do the bounce.
And to do the bounce we can just call a method called bounce on our player.
Let's say player.bounce.
And then we'll pass in the normal.
And let's also give it some bounciness factor.
So, I'm going to call this underscorebounciness.
And then I'll generate a field for my bounciness.
I'm not sure if I spelled that right or not, but it'll work.
I'll add add it here and make it a float.
And then we'll make that a serialized field.
I'm going to give it a default value of something like um let's go with like a 200.
This is going to be an amount of force that's going to get added to the player.
Now, I need to implement this bounce method.
So, I'll go to the bounce right here, select it, and hit alt enter to generate the method.
It's the first option there.
I hit enter again, and my method should be generated.
I can hit F12 to go to it.
And then I just need to implement it.
Now, if you look here, when we take damage to deal with a knockback, right now, we're just adding some force in the opposite of the normal times some knockback velocity.
So, I can just copy this line, paste it right in here on 177, and instead of using the hit normal variable that doesn't exist, I'll use the normal that's passed in.
And then here, we'll use the bounciness instead of the knockback velocity.
That way, the objects that I'm bouncing off of can control how bouncy they are.
Let's make this public.
And then we'll go back into our damage player script.
And the final thing we need to do is move this bounce player script to its own file.
So select the class up here, right on the class name, hit alt enter, and choose move type to bounce player.cs.
That should move it into its own script.
Maybe even open that script up.
If it didn't, you can always go to the solution explorer and go find that script right there.
But we don't even need to do that right now.
We just need to go to the ladybug and add the bounce player component.
So I'm going to collapse everything else.
We'll add the bounce player.
I'll check the only from top option.
And let's press play.
I expect now to be able to run over there and bounce off the top of it.
And then I think we can probably add this to our spring as well if that works.
So there we go.
I can bounce.
The bounce is kind of weak.
So let's try turning that up to about a 400.
Okay, there we go.
I'm getting a nice strong bounce, I think.
Look at that.
I like that quite a bit more.
So I'll stop playing.
I'll set that value back to a 400 while we're not playing.
And then I'm going to go to overrides and hit apply all to update my prefab there.
Next, I want to go modify my spring so that my spring uses this bounce player script as well.
That way, my spring won't knock me back.
Let's go find the prefab for our spring and just drag it right out here.
Let's put it just somewhere over here to the right.
I'm going to put this at a negative -3.5 and oh, a seven.
I'll save my scene.
I'm going to press play.
Use the spring as it is existing and then we'll figure out um what we might want to change here.
Let's So, let's run over here.
Oh, I'm going to get rid of this platform first.
Stop playing.
I'm going to Oh, you know what? I'm not going to completely get rid of it.
I just want to slow it down because it is obnoxiously fast and it's making me dizzy.
So, I'll put the speed 2.1 for now, and then we'll press play.
Now, I'm going to go over here and bounce without this thing kind of knocking me in the head constantly.
So, right now, you can see that I walk up to it and it kind of is that wiggly bounce.
And if I jump on it, it bounces me some amount.
Um, but this is the maximum bounce that I could have with that bounciness.
Except that the bounciness is also based off of how far I've fallen.
So, let's stop playing and switch the script now.
So, instead of using that bounciness factor on the collider, we'll go find the spring.
We'll set that material to none.
And then we'll add the bounce player script instead.
Oops.
What have I done? I accidentally typed a backslash there.
There we go.
The bounce player script.
I'm going to give this a value of maybe 400 as well.
So, I'm not sure how how much I want springs to bounce, but I do know that I want to be able to control how much they're bouncing.
I'll check the only from top option again.
Press play.
And now I should be able to bounce right off of that spring as well.
And always bounce the same amount now instead of bouncing some amount based on how far I fell.
So, I bounce and if I jump super high and I fall down, I still bounce up the same amount.
And that's the tighter control that I wanted.
Now, of course, if you want to use bounciness, you can.
Um, if you want to use the collision data, you can also speed up the bounce based off of how fast you hit it, but or or based off of the velocity of the thing that hit it.
But I like that I have a nice tight control here because now I can say exactly how far away things need to be and how much of a jump I need to make to be able to make it across somewhere or something else.
I especially like that for things like this ladybug where now I can use the ladybug as essentially a mobile spring that I can control with the lasers by freezing him whenever he gets to the wrong or the correct spot.
So now that I've got that done, I'm going to stop playing, save my scene again, make sure everything's in there.
Go into plastic so that we added the bounce player script and we'll check in our changes.
One of the key things I wanted to teach in this course that's not coding is how to go about finding art for your actual game.
Now, there are a lot of different processes and ways and places that you can get things.
The Unity asset store is of course one of the easiest and then there are a lot of 3D art sites.
But if you want to get custommade work, the process is usually super expensive and really really time consuming.
But I found a little hack that makes it quite a bit cheaper and quite a bit easier and actually I think viable for a smaller or indie developer.
And that's using some AI generated concept art in sites like Fiverr.
Well, specifically Fiverr.
That's my favorite.
And what I wanted to show you now is some of the AI art that I've generated using MidJourney.
Here you can see a bunch of different characters that I came up with.
Just trying to come up with a nice robot that we could battle or some other different type of robotic creatures.
Got some robotic mice and other things.
You can see if I click on them, I can see the actual query that I put into MidJourney to generate these things.
And I'll show you how I did that in just a moment.
But I want to scroll up through and show you some of the cool ones that I found.
One of the characters that we'll actually be using very soon is this cartoon robot dog that I thought came out very, very cool.
I'll show you the end result of that in a moment.
But there are just lots and lots of things in here and it's extremely easy to do.
Let me show you how you generate these things real quick.
Once you log in to Midjourney, which you can do with your Discord account, you'll be in the newbie channel or at least you'll be able to join these newbie channels.
You'll see something like these newbie 106 or some other random number.
Go join that room by double clicking on it and then you need to use the imagine prompt.
You type / imagine or slash I and enter and then give it your prompt.
So say I wanted a robotic grasshopper, a cartoon robotic grasshopper that's in 2D.
I would say imagine a 2D robotic grasshopper cartoon style um video game sty may I'll just leave it cartoon style and I just hit enter and what'll happen is an image will start to appear or a set of image it'll it'll give me four images that I can choose from that I can either make variations on or upscale.
You can kind of see some of the other people's images that are going by.
If I scroll up, I can see mine start to generate.
It gets hard to scroll up if there are lots of things generating at once.
And I just let it go and eventually it's going to show me something here.
And if I like one of them, I'll be able to get a bigger better version of it or get a bunch of variations of it.
And that's what you saw on the other midjourney page here.
I haven't just typed in the command many, many times.
I found one that I liked and then I hit upscale on it or I found one that I liked and I hit the variation button on it.
Got a couple more variations and a couple more variations until I found one that I thought was good enough.
Once I find one that's good enough and let's go back into Discord real quick and see if it's finished generating so we can see what the new ones look like.
Did it generate? Where is it? Got to scroll through.
A lot of time it'll pop up or pop down at the bottom as soon as it's done.
So, oh, there it is.
And see my robotic grasshoppers.
But let's check out how we can upscale these, do variations, and then see how we turn the variation into something that we can actually use.
I really like this yellow one.
I think that that guy looks pretty cool.
So, what I'm thinking is I'll hit the upscale on it.
U4 will upscale number.
This is 1 2 3 and four.
So, that yellow one's four.
And V on it will give me variations.
I hit submit.
I can actually add in some extra context there if I want.
And then I can hit this button to just regenerate a whole new set of them.
They'll appear down here below as new images.
And once I found one that I like, what I do is I go on to the midjourney page.
They'll show up here shortly after I've finished.
And then I go select that image of the one that I like.
Maybe it's one of these bees.
And I actually did do one of these bees.
You'll see that a little bit later.
I go find the image.
And then I can uh oh, right here.
Hit the save or rightclick and just download the image.
Hit save as.
Then I take that image and jump over to my favorite art site, Fiverr.
Fiverr is not a free site, but it is very cheap, or at least relatively cheap compared to paying an artist somewhere at an actual gamedev company.
You can find outsourced artists who are interested in building things and they'll tell you their rate and a lot of the time their rate is really, really good.
Here you can see one of the artists who I sent over the game art to.
I sent the dog prototype to them and they generated and created this dog and I also sent them a cat and they generated and created this cat.
It's fully animated and available and you'll be able to download those both right below in one of the upcoming lessons after I show you how to do the import and export and all of the setup.
But you can see that this is a pretty simple setup.
At least I think it's a very easy way to get art and it's drastically drastically cheaper.
got a premium package is what 120 and I think the total cost on those was like $200 which is really really cheap when it comes to getting 2D animated art or getting any game art.
In the past I've paid up to thousands of dollars just for a single concept or a single image that's going to be the splash screen for a game.
Art gets really expensive especially if you've got to pay artists who live in very expensive places.
So, if you can find some art that you can generate or um let's cut and if you've got big studio money behind it, then that's not unreasonable.
But when you're an indie dev, that's just really not realistic.
And it makes it so that this is really, I think, the best way to get art or one of the best ways to get art.
It's my favorite way to get stuff that's custom, really cool, and matches for your game.
Just find a couple artists on here, figure out who can work well with your art style and what it is that you want, and then start giving them concepts.
Those concepts from Midjourney make a huge difference.
It makes it very easy to just con um what's the word here? Communicate.
There it is.
Communicate what it is that you're looking for, what you think is cool, and not have to go back and forth and spend hours or days of their time trying to track that down.
So, use MidJourney, generate some concepts, find a good artist on Fiverr, and I'll link this one down below, and see if you can come up with some cool stuff for your own game.
And just to be real clear, don't do that for this project.
Do it for whatever game or games you might be building of your own that you actually care about and want to invest in.
Just want to make sure that was really clear.
Now, one of the key things you're going to find out when working with artists online is that their file structure, their naming structure, and the way that they give you things is going to vary drastically.
If you've got your own art department, you've got an art lead who can manage and keep that all in line, then it's not a big issue.
But when you're working solo or you're working in a small team and you've got to outsource art or you're not just don't have somebody that's actually in charge of art, keeping things tight, it gets to be somewhat messy pretty quick.
And one of the things that I really recommend you do is set up a new project when you're importing art to make sure that you figure out what's in there, what should be there, rearrange it, and get it into a good package, and then pull it into your actual project.
So here you can see I've got a character import project.
This is a totally empty blank project.
And I'm going to pull in that cat and dog package that I was just showing you.
Now, you can see that it's got an animations folder on the root with a cat folder, a character folder, a dog, an effect, and then some prefabs, and a scene.
And there's a bunch of stuff here.
So, I'm going to import it.
Let's pull it in and see what it looks like.
And go look at my scene.
I'm going to go open up this animation scene and press play.
Looks like we've got a nice sample here that we can take a look at.
Okay, it looks pretty good.
I can see the animation's playing.
Everything is going around.
Let's go check out this dog.
If I expand out the dog, I could see the animator underneath it.
And I'm going to go double click on that animator.
And notice that it's using an animator override controller.
So, they've got it set up with a character that's got some animations.
And then this dog is overwriting it.
So this is some generic character controller.
I can double click and open that up and see it right here.
It's got idle, jump, move, duck.
A couple things.
Let's drag it down here so that we can dock it.
Select the dog and then see what it's doing.
So I can see that it's going through the idle.
And then do we have any parameters? So there's one blend parameter.
If I set that up to a one, what does it do? Add.
Doesn't seem to do anything at all.
Let's go to the layers and adjust the layers now.
So, if I adjust the layer here on the action, what is this one doing? Oh, that's the shoot.
And then we've got a hit action.
What is this one doing? If I adjust the weight here, I can drag it up.
Oh, okay.
And then he's going to keep taking hits.
So, it's got layers for the hits so that I can looks like take damage and uh shoot at the same time.
And then if I go to the mobility section, I can probably force it to start moving by finding this transition, adding a condition to the blend being greater than zero, and then go find that parameter and turn that blend back up to greater than zero.
Ah, there we go.
And now it walks.
So now we can see that it can walk.
It can't doesn't look like it's going to be able to walk and die at the same time, which I think Oh, I guess it kind of can, but be a little bit weird.
They don't really stack well.
Um, but it can walk and shoot at the same time.
And then I think that there was one other cool thing it could do, which was this duck.
So, let's add in a transition here for the blend being greater than zero.
Let's see what it does.
Go find it here.
Let's go find that parameter.
Set the value up to one.
It should go into move.
Ah, and then it goes up to the sky.
So, this is a raise up and down.
But we don't have a good animator controller for this.
As you can tell, we've got a bunch of animation going on.
The controller is a bit of a mess.
And the project structure here is definitely not what I want.
If I pull this in, all of these animation folders.
Oh, these might be okay.
We'll be all right.
And then I'm going to get these weird prefabs that are these animated characters.
They they might actually be okay, too.
Let's see.
And let's see.
What do we have in sprites? Oh, okay.
These things will definitely be in the wrong folder in a sprites folder.
So, I'm checking it out and I'm thinking I might just import everything here except for renaming a couple a couple spots.
So, let's go take a look at our project again.
If we jump back over to our main project and look at our project structure, we've got an art folder and underneath it, we have some enemies which has all of our list of enemies.
And then we've got an animation folder up here.
And we've got a prefabs folder up here.
If we pulled that one in, we'd also get a um sprites folder here, which I think I'd like to be in my art folder.
And we get some stuff in animation, which I think I I'm okay with.
So, we'll jump back over to the other project, and we're going to just take this sprites folder and move it into an art folder.
So, I'll go to the assets, rightclick, create a new folder, and I'll name this art.
Now, if you have a different project structure, of course, make this match your project structure instead.
I'm going to take the sprites and drop that into here.
And then I'm going to open it up and I'm going to rename this from sprites to enemy sprites.
And then I want to expand that out.
And I want to just make these folders be uppercase.
So the cat's going to be uppercase C, dog's going to be an uppercase D, and effect will be an uppercase E.
I think I want to rename the animation folders as well.
Um, I'm not sure that I want to keep this animator controller in here.
Although I think that um, well, let's see.
No, I think that we'll probably just delete out the animator controller and we'll add in a brand new animator controller for it because when we pull this in, it's going to have all of the stuff on here that I don't really want it to do.
So, I'm going to delete out that character subfolder.
We'll rename this dog folder with a capital D and rename the effect folder with a capital E.
The last thing I want to do is check my prefabs and just rename these so that they are cased correctly and don't have underscores.
So this is a bullet.
This is a cat bomb.
I'll just name this cat bomb.
And then I'll name this dog laser.
And we'll name this dog with a capital G and cat with a capital C.
Now I think I've got everything neatly lined up.
The last thing I want to do is rename my animation folder here to dog cat animation.
Although now it's not going to work anymore because I've deleted that animator folder.
Let's hit reload.
Let it reload that.
If I press play now there's no more animator controller on them.
So they're not going to animate.
They're just going to do exactly that just like I expected.
And then the final thing I need to do is export this as a package.
So, I'm going to rightclick and I'm going to choose export package.
And then I get to choose all of the files that I want to include in this package with my newly restructured format that doesn't include that extra character folder.
Oh, you know, I also want to get rid of these override controllers.
So, let's stop playing and go delete those as well.
I'm going to go find that cat override controller, delete it.
And I'm going to go find that dog override controller and delete that as well.
Go back into the assets, rightclick, and export.
And this is why we go through that process.
So, I want to find all of the stuff that I'm not going to use and just get it deleted out of here.
This effect is for that laser.
I'm not sure if I'm going to use that, so I'll leave it in.
And we've got the prefabs here for everything.
And I don't need these settings, so I'll uncheck those.
I don't need the sample scene.
Don't need this universal render pipeline setting.
I think that looks good.
So, I'll choose the export option.
And I'll call this dog cat clean.
And I'm going to put this into my Alien Blasters root folder and not inside of the assets folder so that I've got my package here.
In fact, I think I'll make a new subfolder in here for my um art packs.
And then I'll save it right into there.
Once that's done, I'll import that pack into my actual project.
Once that's done, I'll open the Alien Blaster project and go import that.
So, I'm going to go through assets and import package and custom package and then just go find my dog cat clean.
This should show me all of the things that I've got.
So, it's going to say that there's already an art folder, but it's okay cuz we're not add or not replacing anything.
There's already a prefabs folder, but that's okay because none of the files in there getting replaced either.
They're all new.
So, I'm going to hit hit the import button, and I expect that all of my characters are going to now appear here.
So, I've got inside of my animations folder, a folder for my dog, my cat, and effect.
Oh, I've messed up my name of this folder, though.
So, I'm going to take all of these and drag them into anim.
Oh, you know what? I'm going to actually take these animation ones and move them into animations because I like that name better.
It's plural and it makes more sense.
Let's get rid of the default animation folder that I had or the previous animation folder.
And now I've got my cat and dog, which have all of their own animations cuz they have multiple.
And then I've got my other characters that have very few.
They don't need a subfolder yet.
So, let's take a look at our prefabs.
Now, the prefabs are also updated.
It doesn't show in here that there's something changed because it's not a new folder, but you can see it right here in the prefab section.
Or if we go to plastic and see all of the new files that we've got.
Let's go back into the project view, though, and we take a look at the dog.
Got the dog right here.
And I want to make this be our next enemy.
So, I'm going to drag it right out here.
But he's looking pretty huge.
Now, before we go about adjusting him and resizing him or anything like that, let's save off our scene, go into plastic, and say that we've imported our cat and dog.
Want to get these all committed before we start making changes and modifying things.
And we'll check that in.
Now, we're going to set up our dog.
But before we do, I noticed that I have a commit down here in plastic showing my art packs folder.
And that's because I accidentally put it in one folder too low or one folder too deep.
So, I'm going to hit open in Explorer.
Pop open the window here, this art packs folder.
I didn't want it to be in my Alien Blasters folder.
I want it to be one folder up in my project.
So, I'm going to paste it up there so that it's not actually in my project.
It's not something I want to be part of the project.
It's already included in there when I've imported it in.
So now I should be able to go back in and see my pending change gone.
All right.
Now that I've done that, let's go modify our dog.
The first thing I want to do is shrink this dog down a little bit.
But I don't want to do that on this root dog right here.
Instead, I want to go down to the base object that has the animator.
And I'm going to set the scale here to about 0.5 on the X and a.5 on the Y.
Now, if I go change the pixels per unit, that will shrink everything down on this setup of textures.
But because of the way that the character is set up with all of these different body parts, if I do that, the animations are all going to instantly break.
Let's go take a look at that real quick.
I'll show you what that looks like so that you can see and then we'll go through the scaling.
So, if I went to the dog and I changed all of these pixels per unit to maybe be 200 so that it shrunk down and see I get small sprites, but everything's separated and far apart.
And if I press play, actually, I don't think there's an animator on here, so probably nothing will happen at all.
But if I did press play, all the parts will animate, but they're just going to be offset in the wrong spot.
So, we're going to undo that change.
Hit apply.
Set them all back to one or 100.
And then we'll change the scale here of the child object instead.
And then we're going to flip this around as well by changing the rotation to 180.
I want all my enemies to face the left by default.
At least most of them.
This one definitely.
And I want to have that I just kind of want that to be the default direction.
So that way I'm running to the right and the enemies are to the left.
I of course have dogs that are flipped around, but I'll do that by flipping the base parent object instead of this child one.
So now I've got my dog there and I want to make him animate.
I don't have an animator controller because we deleted out that override one and the character one that was there to kind of show off what it could do but didn't make sense for what our character was actually going to do.
So I'm going to go into the dog folder, rightclick, choose create, and we'll create an animator controller here.
I'll name it dog and we'll assign it to our dog.
So, select the dog and oh, got to select the base object though, the one that has the animator, and drag it on.
Then I'll double click.
That'll open up my animator window.
If yours is docked up here or over here or somewhere else, just dock it down below so that you can see it.
Actually, you know what? Dock it.
Dock it up here instead.
I lied.
Dock it up at the top so that you can see the animations instead.
Now, with the animator window open, let's take the dog idle or idle dog and drop it right into the blank canvas.
That should be our default animation.
And I don't want this dog to walk forward right now.
I just want it to go up and down and shoot lasers.
That's my thought.
I don't want him to be moving.
I want him to be a kind of a standing still but up and down blasting um target that's kind of a problem like that and acts differently than some of the other enemies.
So, I've got this idle dog animation, and the animation I want to go into is the rising dog animation.
So, I'm going take the rising dog animation and drag it out as well.
Next, I'll create a transition by right-clicking on idle dog, hitting make transition, and then choosing rising dog as the target.
So, it'll transition between idle and rising, and then I'll make a transition back from rising to idle.
Now, if I go into my scene view or into my game view and press play, I should expect to see my dog just going up and down back and forth between those two animations.
Let's see.
There he goes.
He's up and he's down.
If I take my animation window and just drag it down, we can actually see it kind of happening as he goes through the idle.
Up and down, up and down.
And he's playing his animation just like I expect him to do.
Now, I also want him to play his laser blast animation.
and I want him to play that constantly as well.
So, what we're going to do is add a new layer.
We'll go to the layers section.
We've have this base layer, which is dealing with our going up and down.
Let's hit the plus button and add a new layer and call this attack layer.
In our attack layer, we're going to add in two more animations.
So, I'm going to take my animator and I'm going to drag it up.
I think I'll dock it up here so I can see all of these windows at the same time.
I've got the base layer that has that movement on it or the idle and the rising up and down.
Use the middle mouse to pan around.
By the way, go back to the attack layer and I'm going to add first a blank state.
So, we'll rightclick and choose create state and choose empty.
This is going to be a default state that does absolutely nothing.
And then we'll add a shoot dog state or a shoot dog animation right below it.
Drop that in.
And then we'll add a transition.
Let's zoom in a little bit.
Right click, make transition, and drag that down to shoot dog.
I'll right click and make a transition back up to that blank state from shoot dog.
And then we're going to go on to the transition for shooting.
And I don't want this to necessarily shoot constantly, but I'm going to start it off shooting constantly and then add a condition.
So before we add in our condition here, let's go to the layer, hit the little gear, and drag this weight all the way to the right.
I'm going to save.
Make sure that I've saved my project as well.
Press play.
And I want to watch my dog and make sure that he's animating, going up and down, and shooting at the same time.
I think it looks like he's doing it.
Let's make this thing uh nice and big.
I'm going to stop playing and let's rightclick um and hit maximize.
There we go.
And play.
And I can see my dog is going up and down doing what he's supposed to do.
Now, there is an error here saying base animation event has no function name specified.
So, there's an error that we need to address.
And I want to start adding some control over this so that maybe we can control when our dog goes up and down.
But first, let's take a look at what that error is.
Now, if I stop playing and I unmaximize my game window and I go down to the console window, we can see that it says base animation event has no function name.
And it's saying base because that's the name of this object.
And it's saying that there's an animation event that's playing that has no function name specified.
So, one of these animations has an animation event on it where it's trying to call into code, but it doesn't know what code to call into.
And the animation that's doing that is the shoot dog one.
We can take a look at the shoot dog animation by double clicking on the motion here, and we'll get the animation window, but I need to go click on the base character to actually see it.
So, if you don't click on that, you're not going to get it to show up.
And now once you have this animation window showing up, if you don't have the correct animation showing, you can just hit the drop down and find shoot dog.
Here I can scroll through and actually see the animation playing on my little dog.
There you can see it lighting up on him.
But I can also get to this point right here where this little bar is.
And that bar is indicating the animation event.
So, right at this point of the animation is when it's supposed to do something, which is probably the time when it's supposed to be spawning that laser so that it visually matches.
And if I look at the function, you see it says no function selected.
So, I need to add a function here that we can call into from our animation event because I want it to tie in exactly with what the animator and the artist had set up so that it looks right and feels correct.
And to do that, I'm going to go to my dog, the base component here, and we're going to add a new script.
So, let's take this animation window, dock it down below, go to the project window, and go to our scripts folder.
We'll create a new dog script, name a new C# script named dog.
And we're going to at first attach it to this base object.
Not to the dog because that won't get the animation event call back, but instead to the base object.
And we'll talk about how we can adjust that in just a moment.
First though, we're going to drag the dog onto here.
And now, if we go back into the dog or not back into, but first into the dog script, we can add a public method that we can now call from our animation event.
So, say public void shoot.
And it doesn't have to do anything.
We can just uh let's write a log debug.log shooting and add a semicolon.
Now, if we go back into our animation event in the animation window.
So, go find my animation window and make sure that I've got my base character selected.
It's my animation window.
With that base character selected, go find shoot and we'll go find that animation event and hit the function dropdown.
And now shoot is an option because shoot is at the same level on this same object.
Now, let's press play.
We should no longer have that error.
And every time he shoots, we should see a little log down in the console.
I'm going to drag the animator window down here.
Take the console window here.
Hit clear and watch.
And every time it goes up and blasts, we should expect to see some sort of a log.
Oh, there it is.
Shooting.
Shooting.
The editor just hadn't updated my log entries.
There we go.
It's adding one entry each time he he goes up and shoots.
So, now it's working and I'm ready to tie in the actual shooting part.
But I want to stop playing and go commit my changes because I've just added quite a bit to my animator.
Um, these changes for our files here.
These meta changes are actually not changes.
What happened was we modified them and then changed them right back.
Or at least I did.
So, I'm going to go select them all.
Rightclick.
Well, first let's just go double check that I haven't selected anything that's not an image here.
Okay.
Yep.
I'm going to go select all of them except for that sandbox file.
I don't want to select that.
the ones that are not new, the ones that I've changed that were just the sprites.
Right click and just hit undo because there was no actual difference there.
And then I'll commit my changes that we've added the dog animator controller and check it in.
Now that our dog is animating properly and even calling that animation event, let's hook it up so that he actually does damage to the player and let's use that laser effect that we have.
We'll stop playing first and I'm going to go find my dog laser.
It looks like it's right here.
If I take a look at it, it's this big long laser beam.
I think this will work perfect for a weapon that can just hit the player and knock them up, do some damage, and kind of keep them at bay.
be really cool for a horiz or vertical level where we're going up and you got to dodge things, I think.
So, I'm going to go find my dog now and expand them out.
If I go through the hierarchy of my character, you should be able to find this blaster sprite.
That's the one that's showing up.
Then, when it kind of animates and pops out, I don't need to enable it because it's not going to show up.
All of the children and everything else are all disabled as well.
Or I think they might be just off in position and tiny tiny scale.
Let's see.
Oh yes, they're scaled down to zero.
So if I scale it up, you can see that they get nice and it's that laser thing right there.
So I'm going to leave that scale at one for just a moment.
And then we're going to take our laser blast and drop it into there.
We actually have to set the scale up to one because if we don't, when we drop in our laser blast, it'll get scaled down to a zero.
So let's go find that dog laser blast.
Where was that? Should be in my prefabs.
Dog laser.
Here it is.
and I'll drag it as a child of the blaster.
I'm going to reposition it with W.
So, just move it over so that it's right on top there.
Looks like about a.465 or maybe a negative.4.
Maybe or.5.
That looks right.
I said negative.
There was no negative there.
So, about a.5.
I go back to this blaster.
We can set that scale back down to a zero now.
And then even disable the object like it had it before.
Now, if I press play, that laser should appear.
When I blast, the laser should just kind of show up.
I don't need to spawn anything.
It's just going to enable.
There we go.
It's popping out.
And it enables pretty much instantly.
Looks pretty good.
It blasts and then it blasts, then it blasts, and then it blasts.
Now, I want this thing to do damage.
So, if I run over here, right now, the laser doesn't do anything to me.
So, let's make a change to our laser again.
We'll go to the laser object, go expand it out, and expand out some more.
First, let's turn this thing back on so we can view it.
Turn on the blaster.
Set the scale back to one.
And then, let's find the object that's the beam.
So, it looks like it's this 21 object.
We've got the one one is or one two is that circle.
One is this tighter circle.
and 22 is this bigger area outside or the kind of glow around the beam.
I'm going to go select the actual beam object which is just this sprite renderer.
And then we're going to add a component to it.
We'll add a box collider 2D.
Box collider 2D should allow us to knock back players and and hit players and do damage to them.
The next thing we just need to add is a damage player script.
So, we add the damage player script that we just created or just started kind of generalizing.
add it to our box collider.
We'll save.
Press play.
Let's run over, hit that laser, and see what it does.
Oh, look at that.
I'm getting knocked back.
I get shot.
I get bounced.
If I hit the top of the laser, I'll kind of bounce off of it.
Let's see.
Can I Can I hit the top? I'm not very good at that.
There we go.
And I can bounce off of it and start taking damage.
So now I'm taking damage from my dog without having to really write any custom code for it.
And this is generally what I want to do, unless I have some special use for the dog where I want it to do something else.
But right now, this collider is automatically growing.
It's adjusting.
It's not the most optimal thing, but I don't expect to have more than two, three, four dogs on the screen at most.
But it's adjusting.
It's going to knock me back and hit me automatically without me having to do raycasts or figure out anything else to to get this code working.
So, I'm going to stop playing.
And also, it's worth noting that we added that animation event call back on our dog.
We haven't even needed to use it yet.
And it's important to note that we didn't just dive right in there and start writing code because we don't always need to do that.
That's not always the best thing to do.
In fact, we may never even need that animation event.
The way that things are hooked up, the way that the animator set it up and created it might not be ideal for our code.
And you're going to find that often is the case that the animators and designers aren't necessarily setting things up in the simplest way.
They're setting things up in the way that they've done it before and know how to do it.
So, here we go.
We've got our dog with a working attack.
I'm going to go into plastic.
Well, first I'm going to update my prefab.
I'll go to the dog overrides and hit apply all so that that one gets applied.
And I'll go to the laser.
Oh, I don't need to apply the laser.
It got applied on my dog prefab.
I think we're good.
So, we'll say that dogs deal damage with lasers and check that in.
Oh, got to recheck it in.
We got that error that pops up on occasion and do a check in.
So, I hit check in again.
And there it goes.
For this next section, I just want to do a small assignment.
I want you to do a little experimentation with the NPCs that we have so far.
We've got our ladybug that we can bounce off of, assuming that you made a ladybug and not a spider or something else.
We've got the dog going up and down.
We've got the frog jumping back and forth that we're going to replace with a laser grasshopper.
And you've even got a cat that you could start pulling in and importing and possibly coming up with some ideas for.
It's got a few attacks, but I think the key one is the grenade launch, which we'll dive into later.
But for now, I want you to take the characters that you already have set up and do a little bit of experimenting with a new level.
Make a level three or whatever level you're on right now, the next one, and build something going vertical so that you're going up instead of to the side.
Use the dogs and the ladybugs as possible tricks or ways to go up and down.
and even play with maybe using multiple lasers.
Perhaps create a blue laser and a yellow laser and a red laser and have them in different spots so you can maybe toggle your ladybugs to get up and down.
If you're able to build something cool, then make sure that you export a WebGL build and share it with us all in Discord.
You can go check out and see what it is that you built and, you know, get it in front of people, get some feedback, and have a little bit of fun with it because I think that people build all kinds of really cool things when you start giving them a little bit of tools.
It's amazing to see the kind of creativity and the ideas that start popping up.
So, go ahead and do that.
Have some fun with it.
And then if you're up for it, share your experience and share the results of what you've got, like I said, in Discord or email them over to me.
Now, we're going to make a slightly bigger change to the game.
We're going to replace our player character so that it kind of lines up with the visuals of the robot and the other characters and so that we can go through the process of building a player where we can modify and change out those visuals pretty easily.
So, the first thing we're going to do is pull in the robot package.
You should be able to down that download that right below.
Download that down below.
You get the idea.
So, grab the robot package and drag it into the project.
This is another one of the packages just like the dog except this time I just pre-organized it for you so that you don't have to watch me go through that process.
Same exact thing though, just found the robot in my temporary project and then I exported that to a robot project.
By the way, when you're exporting things, you can also just select specific prefabs or objects.
And that's what I did here.
I just selected the effect and the robot and exported just those.
So, here you see I've got a robot, an explosion, and a blue bullet.
Those are the ones that I'm going to use for my character.
So, I can have a character that runs around and blasts back at these things.
So, let's hit import.
And we should get our new character pulled in.
I think it went so fast that I didn't even see it.
All right.
Yep.
We've got an explosion, a bullet here, and a robot here.
So, let's go to the scene view, and we're going to go find the robot first.
Before I actually pull anything into the scene view, let's just go double click on the robot and see what it looks like.
So, here it is.
You can see we've got this little character with a weapon, an antenna on its head, and uh it looks like a bunch of different little parts.
It's built up of a bunch of pieces.
I can turn the pieces on and off and see this is not just a single sprite.
It's actually just a full-on animated character.
It's got a character controller here that is using that character controller that we saw before.
And then it has some idle and jump and run and duck animations.
They're not hooked up right now, though.
So, if we go put them in game, we're not going to see any of that happening.
Let's go take a look at the animations folder.
I think that Oh, I'm already in it.
See, we've got dead, a duck, we've got a hurt, an idle, a jump, and oh, three jumps, a run, and a shoot.
So, let's get this character hooked up.
Let's grab the prefab in the prefabs folder for the robot, and we're going to make it a child of our player.
So, I'm going to drag it onto my player.
So, click and drop it right onto the player.
Now, you see I've got this giant robot sitting on top of this little tiny player.
The first thing that I want to do is scale this robot character down because it's way too big.
Now, if I just go in and start modifying the pixels per unit, you saw what happens with the dog.
The whole thing will fall apart.
Instead, I can just scale this character right here to about 0.5 and.5.
I'm going to move the position down, the Y position, just by holding, clicking, and dragging so that it lines up perfectly with the bottom.
But it should be about negative one.
And a negative one should line it up just about perfectly.
I might have to move it up just a little bit though once I see the collider.
Yeah, it looks like maybe it does need to go up just a tiny bit.
Right about maybe like a negative.9 or 85.
I mean it we'll see how it looks.
Oops, I meant 0.95.
We'll see how it looks once it's animating though.
So I'm going to go with a negative.95 and a.5 on the scale.
Then we'll go back to the player.
I'm just gonna disable the sprite renderer.
So, sprite renderer is not showing up.
And right now, the capsule collider doesn't actually align with my character.
So, I think I'll um increase the size of that as well.
Let's go find our capsule collider.
And we're just going to grow this.
So, I'm thinking it's going to be closer to 2 m tall and a zero.
Yep, there we go.
So, that's about right.
about 2 m tall and a zero on the offset, which by the way is about the size of a normal game character, at least in 3D games.
I think that that looks good.
I could probably extend out the X size, but I think I I'll keep it tight like this for now.
I'm going to save and then press play.
And let's watch our robot run around.
And theoretically, everything should still for the most part work except for animations and visuals because we've not no longer using that sprite renderer.
We're no longer using this animator.
Let's see.
Um, and yeah, our character is going to do his whatever his default animations are.
So, I can run around.
I can jump.
I can see that my layer is a little bit off.
Um, your layer could be completely off.
We might have to adjust that before you can see it.
But, it looks like the character is partially working.
This is nice.
So, I'm now ready to start setting it up so that it animates properly.
Well, and to start fixing these these layers, let's finalize this by turning this into a prefab or updating this prefab and modifying the visual layers.
So, I'm going to go to the robot.
I'm going to open up the prefab for the robot, this child prefab.
And then we're going to find all of the sprite renderers in here.
So, I'm just going to scroll down and select this sprite renderer.
I'm going to hold shift and hit the down arrow until I get no something that's not a sprite renderer.
So, it looks like this hand is not a sprite renderer.
So, I'm just going to control-click that off.
Then, I'm going to control-click the rest of the way until I find things that are not sprite renderers.
Those ones I'll just turn off.
That hand is not a sprite renderer, but these children are.
I'm going to find everything that has a sprite renderer.
Looks like that's it.
So, everything except for these two hand objects.
And then I'm going to change the layer to be our player layer instead of the default.
I'm going to go back out of this prefab, save our robot prefab that's a child of our player prefab.
Then I'm going to go to the player prefab, go to overrides, and we're going to apply these three things that we've disabled the sprite renderer, we've modified the capsule collider, and we've added the robot child prefab.
We'll hit apply.
And then I'm going to save my scene and go to plastic and commit that we swapped the robot visuals.
We haven't fixed the animations, but we've done the visuals.
So say swapped robot visuals, not animations, and check in our changes.
Now, we're going to dive into the animations of our player, this robot specifically.
Right now, he's just playing the same animation over and over, which looks like an idol.
and a chute.
Let's go take a look at them.
The animator for this robot is underneath the robot and on this base object.
Looks like the name of it is Robo, which is, I think, a terrible name, but that's actually an animator override controller.
That's using this character one.
I can tell because if I double click on it, it says animator override controller.
And then it references this character controller.
Let's go to the character controller and open it up and see what it has.
So, here's our controller and I've got the robot with the animator selected.
Again, we've got one parameter named blend.
And if we go to the layers tab, we'll see that there are three different layers, mobility, action, and hidden.
I don't really like the names, but we can modify these.
Let's hit play real quick and watch it in action again.
So, on the layers, I can modify the action layer to stop it from shooting.
The shoot action is happening right there.
I can go to the hit layer if I want.
I could drag up the weight and make it start taking damage and dying.
Doesn't do a very good job of not looping back over though.
Obviously, I'm not going to want to control it that way, but we can change it later.
And then in our mobility tab, we've got quite or layer really.
We've got quite a few different options.
We've got a duck, we've got a run, and we've got a jump.
We have one parameter here named blend, and that's actually for this jump blend tree.
So we can blend between our jumps so that we can have a nice smooth jumping animation.
But we can't even get into our jump yet because we don't have any transitions.
So we need to go up to the mobility level of our or our mobility layer.
And here we have a bunch of transitions set up to go from one state to another.
But there are no conditions to allow this to happen.
So let's stop playing, add some parameters, and set up our conditions.
First, I'm going to rename our jump parameter.
This jump blend is named blend, and I think that's too generic and really easy to get confusing what's going on there.
So, I'm going to call this jump blend with a capital J and a capital B.
Then, I'm going to add in a parameter for speed.
I'll make that a float.
And this will be for how fast we're going or for if we're moving.
In fact, you know what? Let's just change this instead.
Since we're not going to be blending anyway, let's use a bool for our movement.
So, let's add a new boolean and let's call this move.
We'll add another new boolean and we'll call this one jump.
And then another one for ducking.
I was thinking of adding a float, but really that only helps if we're doing some actual blending between different animations.
Otherwise, a bull makes it quite a bit simpler, makes a lot more sense.
So, for our idle tor run transition, we just need one condition.
We need a condition that move is equal to true.
For our run back to idle, we'll select the transition with that arrow going from run to idle.
We'll add a condition again by hitting plus and choose move is equal to false.
Now, if I accidentally delete one of these transitions, like this idle to run transition, like oh, I accidentally deleted that.
I can always right click on the idle, hit make transition, and then drag to the end point or the destination and leftclick.
That'll give me the transition here.
I just have to hit the plus button and then choose my transition condition again.
If I do it like this though, there's going to be a minor issue.
Let me show you what that issue is.
Let's hit play and watch our character.
So, he's just idling, doing his thing.
And if I hit move, watch what happens.
So, he starts running, but watch when I stop him running.
He stops instantly.
The start has a delay.
Look at that.
It doesn't start until it finishes or until it gets all the way to the end there.
The reason for that is this has exit time checkbox.
If I uncheck that, then when I hit move, it's going to instantly start transitioning instead of waiting.
Has exit time will make it go all the way to the end before it exits out essentially.
So, let's add in our other transitions.
We're going to add one from idle to jump.
We'll hit the plus on the condition.
choose our jump being equal to true.
For the return, we'll choose jump equal to false.
Now, we also want to be able to go from jump into run.
So, we'll hit plus and add a jump equals false here.
But we're going to add an additional condition here that we're also not moving.
So, we'll say move.
Oh, whoops.
I clicked the wrong one.
So, jump is equal to false and move is equal to true.
Now, that also means that on our condition or transition from jump back into idle, we probably want to have another condition that checks that we're not moving.
So, if move is false, we'll go this way.
Otherwise, we'll go that way.
The last one we need for jump is from run to jump.
We're going to want a condition again just that we are jumping.
The jump is set to true.
All right.
Now, let's do the final ones for duck.
So we'll go to the duck, hit plus, we'll choose duck is equal to true and move is equal to well actually we don't need the condition for move equal to false.
This is going into duck.
Almost did the wrong way.
Also for run we'll hit plus and choose duck is equal to true to go from run into duck.
Now to go from duck into idle, of course we want duck is equal to false and move is equal to false.
Now notice that we're doing all of this again while we're playing.
That's because this is a scene level or a project level asset, not a scene level asset.
So this the changes will save.
Although we do have to hit save project.
All right, the last change we need or transition is from duck to run if duck is false and move is equal to true.
All right, let's hit the duck button and see what happens.
We duck down.
Look at that.
He can now duck and start shooting.
And he can stand back up.
If I've got move on, he'll move and duck and then go back to moving or to go to jump and then go back to um moving or jump and then go to idle.
Now for the jump blend, let's see.
We'll put them in jump mode.
We'll crank this up to maybe like a 0.5 and maybe a one.
Let's put in a one here and kind of see it happening.
If I go into this jump though by double clicking on it, I can actually slide the blend right up here and I can see how it's going to do that that jump animation.
Now, let's stop playing, save the animator off, and then hook up our code.
To do that though, we need to go into plastic and notice that there's no pending changes.
Then, what I want you to do is hit file and save project.
And you should start to see that your character controller updates.
Again, this is a project level asset.
It's not a scene level asset.
So, it doesn't save when you hit Ctrl S or file save and save your scene.
It does save when you save your project or when that project autosaves.
And that also means that you can modify it while you're playing.
So, now that that's updated, let's say that we've modified the player character controller.
And eventually, I want to rename this and and get it kind of cleaned up more.
But I want to get this committed before we have any issues.
Make sure that we've got all our changes in there.
Now, we're going to hook up the animations for our new player in code.
So, I'm going to stop playing and go find my player script.
And actually, first I'm going to remove the animator that's on here.
So, I've got an animator on my player.
I don't want that there.
I'm going to remove it and then open up my player script.
I just want to make sure that I remember to remove that animator.
Then, I'm going to go up to our animator field, which looks like to me is on line 23.
Remember our animator is found in the awake method.
By calling the get component method, it gets an animator for us.
Since our animator is now a child object, we've got multiple Well, we have an issue.
First, that our animator is not going to be found.
And we have two options for how we can assign this animator.
We can either call the get component in child method which will get the animator from our child down our hierarchy or we could assign the animator with a serialized reference.
And in this case both will work.
But we need to remember that if we end up with multiple things on our player, then adding a serializ or multiple animators on our player, perhaps like a weapon has a separate animator or some other thing, then we may be more inclined to go with a serialized reference where we're assigning and being very specific with it.
Since we only have one, my preference is to just go with get component in children and leave it at that.
Now, if I want to be able to go back and forth between these two types of players, again, we'll have to find a different solution or between these two types of graphics, that is.
But since I don't want that, I just want to be able to get that one animator.
This change will do it.
That'll get me my animator from the child component.
Now, I need to go down to the part where we're updating our animator, which is actually in a method named update sprite.
Let's Well, this probably needs a new name.
Let's rename it to update sprite.
and animation.
And then we could probably refactor it out to have an update sprite and an update animation method separately.
But first, let's fix the parameters.
The first parameter we have here is an is grounded.
We're no longer using that old character controller.
We're using this new one that now checks to see if we're jumping.
So, we're just going to check to see if we're or set the jumping variable jumping to the opposite of is grounded.
And we can do the opposite just by adding the exclamation mark which does an inverse or a not of the is grounded.
So if it's true, it'll put in false.
If it's false, it'll put in true.
Now for our speed, we actually got rid of using a float and went to a bool.
So I'm going to delete line line line and duplicate line 136.
We name the parameter move.
Did I name it move or moving? Let's go take a double check.
I need to make sure that I've got the correct name in there.
Move, move, jump, and duck.
I've got to singularize these and get rid of that uh ing.
So, there we go.
Let's change jumping to jump.
There we go.
And move to move or horizontal speed to move.
Now, the variable that I want this to be set to is a variable just telling us whether or not we're moving.
So, that would be whether or not our horizontal is not equal to zero.
So say horizontal not equal to zero.
All right, let's go try that out.
So jump back into Unity and it should be true moving if our horizontal is less than zero or greater than zero.
Should be false by default.
Looks like it is.
If I jump, it goes into that jump animation.
We don't do the blend yet, but the jump animation seems to be happening.
And if I walk, oh, we get some animation.
We get some animation.
And I stop walking.
Well, we still keep getting animation.
Let's see how long it animates for.
Let's go look at the layers real quick.
Go look at our mobility layer.
Go up one level.
We can see that we're in run.
Oh, there we go.
And we went back to idle.
Let's look at the parameters here.
So, our move parameter, I start moving and we're still moving even though my horizontal shouldn't be moving.
I'm not actually pressing the button to move.
Let's take a look at what's going on there.
If I go look at my player and I go to my properties and then I go into debug mode here, I should be able to see my horizontal value.
Where is that at? Right here.
It's at zero.
Let's start moving and then watch the value.
See how it's not getting to zero.
It's getting close to zero.
It's a tiny tiny little number that e is the exponent.
So, it's getting closer and closer to zero, but it's taking forever to actually reach zero.
And the reason for this is what we're going to cover in the next section.
So, let's stop playing, jump into plastic, and commit our changes that we hooked up the player to um um um hooked the player animator to code.
And let's save our scene.
Make sure that that's in there as well.
Let's take another look at our animation issue, which is really an acceleration and a deceleration issue.
If we go find our robot, go take a look at his animator one more time.
Remember, you can see that he's sitting in this run and eventually he'll start kind of switching back and forth between idle and run and then finalize in idle.
After a little while, it does take quite a bit.
I think he's almost there, though.
Let's see.
Is it going to happen soon? I'll dra Oh, there we go.
It's starting to happen.
Okay.
And he went into idle.
Looks like he just stayed in idle that time.
So, here I've got a player debug window.
In fact, let's open up a new one.
Let's close this tab again.
And we're going to go select the player, right click on it, or yeah, let's just rightclick and hit properties.
This opens up a new window that's kind of like an inspector, but it's locked to the player.
I'm going to switch it to debug mode, and we're going to take a look at that horizontal value again.
Let's go find just the player script and take a look at that.
So, we've got the horizontal value right now is a zero.
If I go over here and I run to the right, it goes positive and then it drops down to these insanely small numbers.
These e numbers are just the number of zeros before it.
It's a the exponents.
It's a tiny tiny tiny number that's still not quite zero.
So, we've got two options here.
one, we could have our animator check to see if it's like less than 0.1 or something in our horizontal and then have it switch over and maybe switch away from a move.
We could have the move variable get set to true only if the horizontal is greater than 0.1 or we can fix this horizontal so that it actually just gets to zero properly instead of being something that's going slow.
The reason that it's never getting to the exact number or here it looks like it's never going to get to the right number and not just getting there slowly.
Oh, and there it got finally got there.
It's really slow.
The reason for it is that we're using the lurp method.
And the way that we're using the lurp method in here is um not ideal.
It is something that you'll see often.
You'll see it in documentation all the time and in a lot of examples.
And it's this line right here where we're going from a start value to a desired value.
And we're always passing in a a small value.
We're never passing in a full one.
So here we're going to go from like zero to one and we'll do move it a tiny bit and then we'll move from 0.01 0.01 0.01 or whatever to one and we'll move it a tiny bit more and then we'd go from like 0 2 to one a tiny bit more and so on.
In fact, let's log this out and see what it looks like so you can get a better understanding of what's happening here.
I'm going to put a debug.log and we'll log out the horizontal value.
First, let's add a dollar sign so we can put in variables here.
That allows us to do string interpolation.
We'll put in the squiggly braces, which allows us to put a parameter in.
I'm going to put in the horizontal value.
Then I'll put in the desired horizontal value.
And then I'll put in the amount that we've moved, which is the time.
delta time times the acceleration.
So, I'm going to copy that, put in more squiggly braces, and paste it in.
Add a semicolon to the end.
Let's save, go play, and see what we're getting in the log and see how that value is changing, how it's actually going up.
So, if we go to the console, I'll clear out my logs.
We'll press play.
All right.
So, here we are playing.
And you can see my horizontal and my desired are both zero.
The delta doesn't really matter cuz it's not changing yet.
So, let's move a little bit and see what happens to these values.
I'll just move a little bit to the right and then I'm going to pause almost instantly.
All right.
So, I press to the right and pause.
Let's scroll down here and look at the logs.
Oh, I've got a lot of logs down here.
So, you can see here I'm seeing my velocity.
The first value here is that uh current one.
That's my horizontal.
Let's scroll up to where it was zero.
So, here's where I started moving.
Right here I was at 0 0 and then the next frame I had a desired speed of five and moved up to a 0.417.
The next frame I had a desired frame of speed of five and moved up to a 1.01.
Then I went to a 1.27.
That's this again this first number before the five.
And I keep going.
You can see that number went up up up up up up up up up up up up up up up up up up up up up up up up up up up up up up up up up.
And it kept going up and up up up up.
And it kept going up and up up up up.
And it kept going up and kept going up, but then it eventually stopped.
And it stopped going up probably because I pressed pause, but it was never actually going to get up to five.
And the reason for that is the same reason that it's never going to get down to zero.
Let me unpause it and pause again.
And look at the number now.
You see how the number kept dropping smaller and smaller and smaller? It's down into more and more zeros.
The amount that it's changing by is also dropping.
It's changing by 0.03.
Where before up here, if I scroll up high enough, you see that it was changing by 0.5.
0.5.
0.5.
And here's some 0.1 at the first point and 0.8.
You can see that the numbers, it's hard to tell initially, but what happens is the numbers keep getting smaller and smaller.
the amount that it's changing by to get to that value just keeps dropping.
So, what we want to do is modify this a little bit so that instead of using lurp and not getting to the desired value that we have, we're just going to modify the value instead.
Lurp is useful if we have a start and an end value and a time like we do with our moving objects that are moving back and forth.
But for this, there's an easier or alternative solution.
It just requires a slightly bit slightly more code to write.
Now, let's go open up our code on line 93.
I'm gonna zoom this out just a little bit.
And instead of using the lurp value or the lurp method here, I'm going to comment that out.
We're going to add in a few lines.
First, we'll check to see if we need to accelerate.
We'll do that by checking if the desired velocity is or desired horizontal is greater than our horizontal.
If that's the case, then we're going to add some braces here and we'll say that the horizontal or underscore horizontal plus equals our acceleration times time do delta time.
Now, if our horizontal gets greater than our desired horizontal, we're just going to snap it to that.
So, we'll say if the horizontal is greater than desired horizontal, then horizontal equals desired horizontal.
Now, we'll go down and add an else if statement.
So say else if our desired horizontal is less than horizontal, well then we're going to decelerate or really it's just going to slow down from the opposite direction or move towards that opposite direction depending on what we're going.
We're going either towards zero or maybe towards neg five.
Who knows? So we could be going either way.
This is going left or right.
So we'll say horizontal minus equals acceleration time time do delta time.
I mean we know we'll see when when our code's running.
That's who knows.
Say if horizontal is less than the desired horizontal then horizontal equals desired horizontal.
That'll give us some nice snapping and nice smooth control over our acceleration.
Let's go try it out.
So we should be able to press play.
And now our acceleration should be I think really in meters per second or in units per second how fast we accelerate instead of some semiarbitrary number.
So, here we go.
I can accelerate and decelerate pretty good.
I think that that looks and feels just about how I want.
The final thing that I want to do, though, is make this character spin around so that he actually faces the correct direction.
So, let's go back into our update method here and the update sprite and animation.
Hit F12.
And when we flip the sprite renderer here, let's instead flip the animators transform.
That's that child object that's down in the hierarchy.
So I'll say underscorean animator.transform.rotation.
Oops.
Rotation equals quatronian.identity if it's going to the right.
That's our default.
And I'm going to copy line 154 on to 156.
And here we'll use quatronian oiler or eule e r.
And we'll put in a zero and a 180 to flip it around.
180 on the y-axis and a zero on the z.
Now we'll have an animator that flips back and forth.
Let's see if that works.
Jump back in.
Press play one more time.
We should be able to run back and forth, have our character animate properly, and uh look pretty cool, I think.
Let's see.
So, he runs to the left, runs to the right.
I can jump.
Everything is looking pretty good.
Now, one thing to notice that when I turn, the turning happens visually when the character actually starts moving.
If we want, we can also just tie in our animation part here to the um the input instead.
We can tie directly into the input and it might feel a little snappier even though it's not actually turn it's not actually moving yet.
We can also just turn up the acceleration though.
So if we want to make this a lot tighter of a feel, turn that up to like a 50.
And now we accelerate at about 50 units.
Yeah, I feel like that's probably a little too fast.
How about a 25? Yeah, I'm thinking I might go with like about a 25 now on my ground acceleration.
So, I'm going to stop playing, set that to 25.
I'm going to override my prefabs.
Just hit apply all.
Go save my scene.
Go into plastic.
And we'll check in our changes.
The player animates properly now or animates move and jump.
Let's hit that.
move and jump and faces the correct direction.
We'll check that in.
Now, we're going to give our player the ability to shoot back so that we can have some enemies that are tough to deal with without just trying to land on their heads.
And we're going to do that by adding a new blaster script.
First though, let's take a look at the blaster objects that we're going to use.
We have this blue bullet prefab and we have an explosion that we can use for when it lands.
The plan is to use this blaster that he already has in his hand, spawn some shots, and have them go flying off at our target, and then deal some damage or kill that target.
To start, we're going to go to the player and well, actually, we'll go to the scripts folder, rightclick, choose create, and create a new blaster script.
Then, we'll attach that script and open it up.
Our blaster script will do two things.
It's going to listen for player input and see when the player wants to shoot.
And then it'll spawn the prefab for our bullet and launch that out.
Now, to start, I'm going to get rid of the start method and replace it with an awake because I want to grab a few components and cache them.
I'll get rid of this comment line on line 7 with controlx or shiftde.
And then in awake, I'm going to cache the player input component with underscore player input with a capital I there.
keeping the camel case equals and we'll get component of type player input.
We'll save that off by generating a field.
Hit home alt enter and enter.
And now we've got a field.
Double click that private keyword and get rid of it.
That player input script is right here on the player just above the blaster.
And remember, we've got our action map that we can double click on to bring up our available actions that we've created.
We have a fire action here, and that's what I want to tie into.
So, let's go back to our blaster script, find our fire action, and when it's performed, let's launch a projectile or at least spawn one.
So, to do that on line 13, we'll say underscore player input dotactions.
And we need to not action events, actions, and then we use the square brace so that we can reference something in this collection or this array.
I don't know if it's actually an array or a list.
It's some sort of a collection here that we're going to reference by string name.
And the name is going to be the same as that action name, which was fire with a capital F.
So, this is going to get us the action.
And on that action, there's an event.
So, we can hit the dot, go find the little lightning bolt down here, see all of the events, and choose performed.
Now, that's going to fire off whenever the fire method is performed or that event will be invoked whenever the fire method is or whenever the fire action is performed, which I think is our left click or control.
We can go look at it again in the action map in a moment.
Let's hit plus equals though and tie this into a method.
I'm going to call this try fire.
T capital T and a capital F.
We'll generate a method for it.
We should get a private void try fire with a input action call back context parameter.
Now in our try fire method, we're going to start by just spawning one of those bullet prefabs.
So we'll say instantiate insta.
There we go.
Instantiate.
and we'll put an underscore and I'm going to call this blaster shot prefab.
We don't have a prefab for it yet.
So, we're going to generate a field for it first.
And then we'll make this of type game object.
We'll change private to serialize field so that it can be modified in the inspector, but only in the inspector.
Then I'm going to move it right up here above my other private field so that my serialized fields are at the top, just the way that I like to organize them.
All right.
Now, we've got our trifire method.
It doesn't have a semicolon at the end, and it doesn't know where to instantiate this blaster shot.
This instantiate method is going to spawn a blaster shot, but it'll just go out whatever the position is stored on that prefab.
So, let's add in another parameter.
Let's just do it at transform.position as the second parameter, and we'll use quatturnian.identity as the third.
This is going to end up using not transform.parent, transform.position.
There we go.
This will spawn it at the position where we've given it.
So, at our player's position, essentially, wherever this blaster is facing the default rotation, which is going to be just all zeros.
Let's save this off.
Go back into Unity.
Assign the blaster shot prefab.
Make sure that that spawns.
And then we'll start building up this blaster script.
So, here's our player with the blaster script, and we've got that blaster shot field.
Let's go find the prefab.
And let's start by just taking this bullet blue and dropping it right in there.
I should be able to press play now, run around, click fire, and have bullets kind of spawn awkwardly on top of me.
Let's see if that's the case.
And here we go.
Look at that.
I can spawn bullets wherever I am.
They spawn as fast as I click and they're giant facing the wrong direction and don't move.
Before we fix that though, let's go to plastic and commit our first version of the blaster.
So, blaster spawns game object projectiles that don't move yet.
And we'll check that in.
Now, we're going to fix this bullet problem.
Our bullets are too big and they face the wrong direction.
We're going to start by creating a new prefab.
Instead of using this visual model, the bullet blue, we're going to create a player blaster shot.
I'm going to do that by dragging my bullet blue out so that I've got a nice visual representation.
It's at 0 0.
Let's move it down so that I can see it a little bit.
And then I'm going to give it an empty parent.
I'll rightclick and choose create empty parent.
I'm going to name this robot or let's call it player blaster shot.
I want it to be very obvious.
This is the player's attack.
Now, I want to change a couple things on it.
Well, let's see.
What do I want to change first? The scale.
This is way too big.
Set this down to maybe a 0.25 and a 0.25 instead of a 0.5.
And if I move the parent shot, make sure that the child shots at 0000 relative.
But if I move the parent shot right about here, I can see that.
Yeah, that looks pretty good.
I can see that as a good position and a good size and scale there.
I do need to change a couple more things, though.
First, I think I want to set that order for my sprite layers.
Let's go to the sprite.
Expand it out.
Expand out some more.
And expand all the way down to this number one.
Find the sprite renderer.
And let's change the sorting layer to be on the player layer for now.
I think I'll bring the order and layer forward so that it's at like a 10.
And then it'll always be in front of my player.
My player values should all be zero right now.
So 10 should be nice and far in front.
I'm going to go find my player blaster shot root object here and then drag it in to become a prefab.
Now that it's a prefab, I'll assign it to the player's blaster.
So take the bler here, find that blaster shot prefab, and very importantly want to make sure that I get the one from the project view.
Let's see, where is it? Player.
Did I Did I rename it? No.
Did I name it wrong? Ah, there it is.
I'm just blind.
So, I'll go find it, grab my player blaster shot, and drag it onto the players blaster shot prefab section right there.
So, it should say player blaster shot, and when I click it, it should select the one down here.
If it selects the one up here, you've made a big mistake.
And if you delete this one, and your player blaster shot now shows as uh invalid, well, then you still need to go fix it.
So, make sure that the correct blaster shot is showing up.
I'm going to save, press play, and make sure that we get a blaster shot that looks about the right size and scale in the right direction near the right place.
I don't expect the position to be exact, but I do expect it to look about right, somewhat close, near the center of my body though, instead of at the weapon point.
Let's see what happens when I play.
All right, we click and yep, I get a bullet right near the center of my body.
Now, if I'm facing the other direction, the bullet doesn't change, but it is showing pretty close to where I want it to be.
Now, I want to change the spawn position of this bullet.
So, it spawns right where my weapon is.
To do that, we're going to stop playing, expand out, or maybe just click.
If I just click over here on my weapon, I should be able to find the gun.
And I want to spawn it not necessarily right at the rect or the transform position of this.
I want to be right out here at the end of my weapon.
So, I'm going to add a new transform child to this object.
I'll rightclick and hit create empty.
I'm going to call this fire point.
Capital F and a capital P.
And then I'll drag it over so that it's right on top of the weapon.
Next, I'm going to go to my player and go to that blaster script.
We're going to create a field for that fire point that we can assign on our blaster.
So we'll add a serialized field and this will be of type transform and I'll call this underscorefire point.
Then we'll use that firepoint when we instantiate.
Instead of using our transform position, we'll use the firepoint.position.
Let's save that.
I'm not going to change the rotation at all.
Now we'll go back into Unity and we need to go to our player and assign that firepoint to our new firepoint field.
We'll drag that on.
Save our scene.
Press play.
And we should expect to see that our shots now appear at the fire point.
There we go.
We spawn.
And look at that.
The shots are appearing at the right place.
If I go this direction, they're still appearing at the right spot.
Notice that they do go up and down as uh as my weapon moves, though.
So, if I happen to click when my weapon's up high, that position is up nice and high, and it's firing up there.
Now, before we start writing code for the blaster shot, let's check in our initial prefab.
So, say initial blaster shot prefab with firepoint working.
Now that we have our blaster shot prefab, let's create a script to control it and give it a rigid body and collider so it can move around and hit things.
We'll start by going into the blaster shot prefab edit mode and I'm going to hit add component and I'm going to find a rigid body 2D.
I'm going to expand it out and set the gravity scale to zero because I don't want this thing to drop or drift down over time.
And I'm going to set freeze rotation so that my blaster shot doesn't start spinning around or doing anything strange like that.
Next, I'll add a collider.
And I'm thinking that a circle collider 2D makes the most sense.
The default radius is obviously way too big.
But if I grab the radius and just click and drag, I can find a value that looks okay.
I am thinking probably about 12 or maybe even a 0.1.
Something right around there.
And then that looks close enough.
I could move that collider a little bit to the left, but I think that that's probably good enough.
You hit it right on that edge.
That'll count as a collision.
The next thing I want is a script.
So, I'm going to go to the scripts folder and we're going to create a blaster shot script.
So, rightclick, create car script, and call this blaster shot.
We'll add that to our blaster shot object.
soon as it finishes recompiling and then we'll open our script up.
So, we've got the blaster shot there.
Actually, let's exit out of prefab edit mode.
Let that save our prefab and then open up our blaster shot script.
So, the first thing I'm going to do with our blaster shot is just make it fly off to the right and then maybe disable itself or destroy itself as soon as it hits something.
So, the first thing we'll do is get the rigid body.
We'll do that in an awake method.
Let's all replace start with awake again.
Hit Ctrl X on that line 7 and clear that e extra comment out.
I'll say underscore RB equals get component and we want to get a rigid body but not a rigid body regular kind.
We want the 2D kind.
Then we'll hit home alt enter and generate a field for it.
I'll double click that private keyword and delete it.
Now I've got a rigid body that I can modify in the update method.
every update frame from now until we've destroyed our object.
We're going to just set the velocity to be vector 2.right.
So say RB dove velocity equals vector 2.ight.
The last thing I want to do is make this thing just disable itself or destroy itself when it hits an object.
So we'll add an on collision enter 2D.
And here I'll just say game object setactive false.
Get rid of that private keyword again.
And now I've got a very simple blaster shot that should just fire off to the right until it touches another object and then turn itself off.
Let's go see if it works.
So, I'll go back into Unity and we should be able to press play now and then watch our blaster shots fire off.
Let's go to the game view, press the play button, and see if we can actually shoot things.
The shots aren't going to kill anything or do any damage or anything like that, but they should just fire off like that.
They fire off to the right and they just keep going and going and going and going and going.
Eventually there you see that they got hit by the laser and turned off.
It's kind of cool.
So the laser is turning them off or hitting that other object just turned them off.
If I jump up here and shoot things so that eventually they just turn off as soon as they bump into something.
All right, that's pretty cool.
But my blaster shot moves way too slow.
So next step is to speed it up.
We're going to open up the blaster shot script.
We're going to add a serialized field at the top.
So serialize field.
Where is that at? Oh, it was already right on it.
And we'll call this is well, first we got to give it a type, which is going to be a float because we're going to want a decimal.
We'll call this underscore speed and I'll give it a default of well, we'll start with a one.
Now we'll copy that speed and multiply that times our vector 2.right.
So it'll move at whatever speed we've given it.
Now I know one is actually too slow cuz that's what it's doing already.
So, I'm going to crank it up to a default of something like three or let's even go with five.
That seems like a better speed.
I want my shots to go faster than I'm running.
And that'll give me lots of speed or lots of room to run up to 5 m a second or maybe 4.5 so that I'm not catching up to my own bullets.
Let's press play and see what that feels like.
And then remember that we can go modify it on our blaster shot prefab.
So, I can fire my shots and if that feels good, then cool.
If I feel like that's a little bit too slow though and go find my player blaster shot right here, modify this prefab and maybe turn this up to an eight.
And those shots look nice and quick.
Might be a little too fast.
Maybe like a seven.
And yeah, I think maybe let's let's try running.
So, I'm going to run towards my shots.
Yeah, I'm thinking maybe a seven or an eight.
Let's let's try running towards the shots with an eight.
Yeah, I'm going to go within a value of eight.
So, I'm going to leave an eight on my blaster shots.
I'm going to open up the script real quick.
Change the default to be the value that I think I'm going to use.
So, that way if my prefab gets reset or anything, I don't have to remember this in two places, and I don't have two numbers stored off trying to remember which one I want to actually use.
So, I'll make that match, but still leave it adjustable in the inspector.
And now the last thing I want to add to this is a way to set the direction so that it can go either left or right instead of always going to the right.
And I'm going to do that with a new method.
We're going to add a launch method.
We'll make a public void launch that'll take in a direction.
So we'll go vector 2 direction.
And this will get stored off into a direction variable.
U direction equals direction.
We'll add a field for that.
And then in our update, instead of going to the right, we'll go to the direction.
So we'll just copy direction and replace vector 2.ight.
I'm going to probably give it a default value of vector 2.ight.
So if we don't have something in there, it's just going to go off to the right.
And then we'll get rid of that private keyword as well.
So we need to call our launch method.
Now when we'll do that from the blaster since the blaster spawning this.
So we're going to go find our blaster.
And when we instantiate our shot, we'll get a reference to our blaster shot and then call launch and tell it to go in our current direction.
So say var shot equals that instantiate, which is going to return back right now a game object because the type that we have here is game object.
If I put blaster shot here, it's going to say, hey, this is an error because instantiate returns back a game object and it can't just implicitly convert it to that type.
Now, the way that we can fix this, there are two options.
We could do get component on it and try to get the blaster shot.
But if we just make the type that gets serialized here blaster shot instead, then we can actually get back that specific component.
Now that we have that component, we'll just say shot.launch.
And we want to launch in our current direction.
And we don't have a way to get our current direction yet.
What we want to do now is get that from our player.
So I'll say underscoreplayer dot direction.
and had to hit backspace there to get rid of that input that it tried to auto add.
We don't have a player stored off and there's no direction on the player.
So, let's cache our player in awake and then go add the direction variable to it.
So, copy player and right here above the player input part, we'll say underscore player equals get component and we're going to get a player, not a player input, but a player.
We'll hit alt enter generate a field and we should get that right by our player input.
I'm going to double click player, hit enter so I get a new line, and get rid of all that at the same time.
The final thing we need to do is have our player know which direction it's facing.
And we could just grab the um the rotation, the quadrian rotation from this player and then convert it.
But I want to show you an easy way that I think works a little bit better for controlling our inputs.
We're going to hit alt enter and we're going to generate a property on our d for direction.
We'll hit F12 to go to it.
And here you see that we've got a vector 2 with a public getter and an internal set.
We're going to change the set to be private.
So this is going to be a variable that says which way we're going left or right and can only be set by the player but can be read by everything else.
That's why it's public with a getter and private with the set.
So the set is kind of overriding the public part over here to the left.
Now, when we flip direction of our character, which is right down here in update sprite and animation, we could actually flip this variable as well.
Be nice and easy.
So, then it just lines up with our actual inputs so that we fire off in the direction that we're pressing, not necessarily the direction that we want to move.
So, I'm going to add some braces around our horizontal part.
And we'll say direction equals vector 2.ight if horizontal is greater than zero.
And then if horizontal is less than zero, we'll switch direction.
Equal to vector 2.ft.
We'll save that off.
And right now, this is a little bit confusing because the name of this method no longer matches what it does.
So, I'm going to take this little bit of code, the part that updates our direction.
Select it.
So, it's 155 through 164.
Hit alt enter.
And we're going to extract a method.
And I'm going to call this update direction.
Now I'm going to take this code out of update sprite and animation.
So I'll select line 155 and cut it.
Then we're going to find the reference to update sprite and animation.
So I'll click this line right here and it'll show us the references or I can hit shift F12 or rightclick on it and hit find all references.
Lots of different ways to pop them up.
Once I find the one place where it's called, which looks like it's on line 111 in the player script.
So it's oh, literally it already went to it because I double clicked it.
That's what happened.
So now that I found that line, I'm just going to add in update direction as well.
So I'll paste that right below.
So update sprite and animation, then update direction.
And update sprite and animation is actually just updating the animation.
So now I'm going to rename it to be update animation.
Delete out these extra two lines here.
155 and 156 that were there.
And now I've got slightly cleaner code that does exactly what it's supposed to do and says what it does.
It's named right.
Let's get rid of that private keyword there.
Save.
Do a build.
Control shiftB.
Get rid of all the errors.
And it looks like something added a weird using statement here.
Ah, line six blaster got a using static experimental graph view line.
I don't know what added that, but I'll hit shift delete and delete it.
We can delete all of these other unused using statements as well.
Save.
Go back into Unity.
And now we should be able to launch in the direction that we've chosen.
It's not going to flip our blaster shot around, but it should at least move in the correct direction.
Let's go test it out.
So, press play.
So, we move to the right and shoot.
Goes to the right.
And if I move to the left and shoot, my shots go to the left.
I think if I stop playing and play again, if I don't move at all, I've never set my direction on my player.
So, it's probably going to shoot.
Yeah.
Not in any direction at all.
So, we need to give oursel an initial direction on that player value.
Let's just go open up that player script, find the direction, go select it, controllclick, and then right at the end of the property declaration, we can do an equals vector 2.ight.
That's our default direction for this game.
So, with that done, I'm going to go back into Unity and we're going to commit our changes for our blaster shot that now fires in the proper direction.
Although, it doesn't quite look that way yet.
It doesn't rotate the right way, but it moves in the correct direction.
So, blaster shot script added to the prefab and it now fires in the correct direction.
No S at the end or backspace and check in.
Now, we're going to have a small challenge.
What I'd like you to do is write the one line of code that'll make our blaster shot face the direction that it needs to face.
You can figure out where you should put that code, think it through, and then do the code, test it out, see if it works, and then at the end, resume.
And let me show you my solution.
It should be very simple.
It should be pretty straightforward.
And the goal here is really to see two things.
Can you find the best place to put this code? and can you figure out what that code is? So, go ahead and give it a try and then if you need help or at the end again just resume and we'll go through.
All right, I'm going to assume that you've either gone through it or don't want to.
And now I'm going to show you the solution.
So, let's go find our blaster shot.
Oh, first let's make sure that I've saved my sandbox scene.
Apparently, I hadn't saved my scene off.
Let's go find our blaster shot script, though.
And inside of our blaster shot script, we have our launch method.
And in this launch method, we have the direction that we want to go.
All we need to do is set our transforms rotation based on this direction.
So we're going to say transform.rotation is equal to and here we want to do a check to see if direction is to the left.
So we'll say let's just do like this underscore direction double equals vector 2.ft LFT.
So if that's true, then we'll do the first value after the question mark.
And that first value is going to be quatian.
Ooiler e u l e r.
And we're going to give it the value that we want in vector values.
So the numbers that we would put into the inspector.
And if we go over and look at the inspector, let's see if we can go check that out real quick.
And go find one of those blaster shots.
Let's go find a blaster shot.
Drop it out into the scene view.
Where's our player blaster shot? If we want it to face the opposite direction, we need to flip 180 on the Y.
So, we're going to give it a zero, a 180, and a zero.
So, we'll put in zero here for the X, 180 for the Y, and zero for the Z.
Now, if it's not to the right, we just want to use the default quatronian, which is just quatronian.identity, which is essentially just the same as this with 00 0.
So, if we save that off, we should now have a blaster shot that either looks like it's going left and fires to the left or looks like it's going right and fires to the right.
Either way, it should look correct and not look weird like it's flying backwards.
Let's check that out.
So, we go in here.
We got a shot firing off.
We got another shot firing off the opposite direction.
Things are starting to look up in my opinion.
All right, let's stop playing now that challenge is done and our scene is saved.
Let's make sure we've saved the scene again.
Go to the player and override our player changes as well so we get that fire point added in.
We'll hit apply all and then we'll check in these three files.
We got our blaster shot, the sandbox, and the player preaps.
Say blaster shot faces the correct direction.
And then on a new line and say updated the player prefab for blaster weapon.
And we'll check that in.
Oh, make sure we save again.
Apparently, I had one more.
Oh, my update for my prefab wasn't in there yet.
Now, we're going to make our blaster shots actually deal some damage.
Let's get to the fun part.
We're going to open up our blaster shot script.
And in the part where we deal with collisions instead of just setting our object to not be false, let's see if we've hit a dog.
Let's first find a dog component.
We'll say var dog equals collision.
game object.get component and we're going to try to get a dog component.
So say get component, let's see if I can spell it right of type dog.
Oh, I need to capitalize my G there.
Now, this will return back a dog if we've hit a dog.
So I'll say if dog is not equal to null, then we'll tell our dog to take some damage.
So say dog.take damage.
And right now I'm just going to assume that my shots always deal one damage.
I can make that a variable amount and pass it in, but I don't have plans for that yet.
So, I'll just tell the dog to take damage.
We'll hit alt enter and generate a method on the dog to take damage.
And then inside of this dog take damage method, let's just start by disabling the dog.
So, we'll say game object set active to false.
We can give it some health, let it take damage over time and all that in a moment.
But first, let's just make sure that when we hit it, the dog just kind of disappears.
And then afterwards, either way, no matter what we hit, we should still be setting our object to false.
So even if the dog is null, we hit a brick or a rock or a player or something else, we still want to turn our blaster shot off.
Now go back into Unity.
And for this to actually work, we're going to need to make sure that we have a collider on our dog as well.
And right now, our dog is on this child object.
We're going to be moving that up soon.
Right now, it's here just for the animator for that shoot call back.
But let's add a capsule collider to the dog.
Let's move it up a little bit.
Move that offset up.
You can see the scale is all kind of wonky and weird.
I'm gonna drag it up so that it's a little bit bigger.
Let's make it a scale of two.
And set that offset to one.
And then we'll do a size of one there.
And I think I I'll just leave it right there.
So, we've got a capsule that we can shoot.
And then again, we're going to move that up and build out a better collider for our dog in a moment.
Let's go to the dog, though.
Go to overrides and apply that change.
And then I want to delete out that extra laser blast prefab that's sitting here, the laser blast shot.
Save our scene.
Press play and then shoot and see if my shot goes through.
If I can get it past that laser and knock out the dog.
Let's see.
Shot the dog.
And the dog has died.
All right, let's stop playing and let's go into plastic and say that our blaster shot kills dogs.
And we'll check that in.
So, we can shoot dogs now, but what if we want to shoot bricks or ladybugs and have them do something? Right now, I can have my shots hit them, but it doesn't really do much other than push them through the physics system.
Well, let's go back to the blaster shot and see what the initial way to do this would be and then see if we can find an alternative or better way to do it.
So, say we didn't hit a dog.
We could of course just say var ladybug equals and then do a look at that.
It auto completed for me.
Collision.gameobject.getcomponent ladybug.
And then say if ladybug is not equal to no, then ladybug take damage.
See, oh, we have a take laser damage.
Let's call take damage though.
We don't have a take damage method there yet.
So generate a method for take damage.
Then on that take damage method here, maybe we want our ladybug to use this laser.
Um, no.
Well, let me think.
No, we don't.
Let's Let's just make it die.
We'll say game object set active to false.
And then let's go to the brick and let's do the same thing on the brick.
Or let's add the same code for our brick, too.
So, we've got a ladybug here.
I'll say var brick equals and hit tab and just let it autocomplete.
And if brick is not equal to no null, then brick damage.
And here we might want to make it take some laser damage or something, but let's do that inside of the brick.
Let's generate a method for take damage.
And remember that our brick has this laser destruction time for how long it takes to blow it up.
Let's add in a number of blaster shots that it takes to blow it up, too.
Let's add a serialized field um ints to destroy.
And I'm going to set it to three so that it takes three shots to destroy a brick.
Now, I'm going to go down into our take damage method, and instead of just destroying our object, I'm going to modify our taken laser damage time or our taken damage time to be our total amount of time divided by the number of shots that it takes to destroy it.
So, if this was two, it would be, you know, half of the time of the first shot, half the time in the second shot, or on three, it's going to be one/ird of the time for each shot.
So here I'll say damage time or taken damage time plus equals and then we've got that variable for the amount of time that it takes laser destruction time and we'll just divide it by shots to destroy.
So say underscore laser destruction time divided by underscore shots to destroy.
Now we can shoot this thing three times and have it blow up.
Let's go test all of these out.
I'm going to do a build.
Control shiftb.
Make sure that my blaster shot got saved, my ladybug, and my brick.
And now I'm going to run around, play, and see if I can blow up all three different types of things and have that slightly different behavior on the brick.
Remember, the ladybug and the dog are just going to disappear on one shot for now.
And the brick is set to take three and tie into the laser damage.
Oh, lady, that guy died.
Let's go try the ladybug.
She died in one shot.
Looking good.
And these bricks.
I shoot one, two.
Oh, that one's on the second shot.
Got two shots on that one.
One on that one.
Shoot, shoot, shoot, shoot, shoot, shoot, shoot, shoot, shoot, shoot.
My shots are not working.
So, why are these shots not working? I assume that the reason is pretty simple, and it's because of the calculation here for the time that's getting added, the taken damage time.
Oh, no.
I know what the problem is.
When we take damage time over here, we're not actually checking to see if we've taken too much damage and then exploding.
So, I'm going to copy this bit of code here on line 26 and 27.
And then we'll paste it right after line 64.
So, if we've taken too much damage, we need to actually explode.
We'll minimize the brick script one more time.
Press play.
And now, I expect that my bricks are actually going to blow up when they take their their hits instead of not taking anything.
And we should probably add some visuals.
We'll add some particles and impacts and other things in a moment.
But first, let's go see that this thing actually blows up.
Let's jump.
Oops.
Let's see if I can get up there.
There we go.
That brick did blow up.
Let's try one more time though from the other side without turning on the laser just so that we can double check and see it.
It's always good to just be sure that everything is working as we expect.
So, come over here and jump up.
Shoot that ladybug.
Jump up again.
Shoot a brick.
Shoot a brick.
Shoot a brick.
Shoot a brick.
Shoot a brick.
If I could hit the same brick three times, it would be great.
All right, there we go.
I can see my bricks are blowing up after a few hits.
That looks right.
So, I'm going to go back into plastic, make sure I've saved my scene, and uh blaster shots, hit bricks, and ladybugs now.
And we'll check that in.
So, you may have noticed while we're building up this blaster shot that the on collision enter method is growing and growing.
And for every single thing that we need to damage, we're going to have to keep adding more and more code.
So, if I want to add in eight more enemies, this is going to get quite a bit longer.
If I want to add in a couple other things that I can shoot, just going to keep growing and growing and growing.
Now, there is a very good solution for this.
there's an easy way to simplify this to remove a lot of this code and make things a lot easier to extend in the future.
And again, we're going to have a little challenge.
This challenge is going to be a little bit bigger than the other ones.
What I'd like you to do is come up with the solution so that we can cut this on collision enter method down to maybe three, four, or five lines.
something really short that deals with damaging any type of thing that we want to hit and uses some special trick or some special code that we may have covered in the past or we definitely have covered in the past.
So using the same type of thing that we've used before.
So if you're not sure what that is, go ahead and just continue on and I'll give you some clues.
But if you have a good idea, you got something in mind, you think that you know what to do, go ahead and try to solve the problem right now and then continue on.
If again, if you need a couple clues, I'll give you some of those and then we'll dive into the solution.
All right, I'll assume that you either are ready for clues or want the solution.
Let's start with a couple of clues.
Remember when we wanted to deal with lasers and we added a I take laser damage event or interface? This made it so that we could damage multiple different types of things.
We've got three references to it.
We have one on our ladybug or there's two types of things.
One on our ladybug and one on our brick right here.
I take laser damage.
This defined a method that we could call and then we use this from our laser.
Our laser looks for things that you implement I take laser damage.
Let's see if we can find that right here.
And then tells them to take laser damage.
So with that in mind, continue on.
see if you can find the solution.
All right, it's solution time.
What we're going to do is create an I take damage interface.
So, I'm going to create a new script.
Call this I take damage.
We'll open it up.
And it's going to have a bunch of stuff in it that I don't need.
So, I'll delete out everything except for the word I take damage.
So, say public interface and I'll paste in I take damage.
We'll add a void take damage method that has no parameters and returns nothing.
save and then copy I take damage back onto my clipboard.
I'm going to go to the blaster shot and in the blaster shot instead of finding a dog, I'll find an I take damage and then I'll delete all of the code for the ladybug and the brick.
I'm going to replace the word dog with damageable and then get rid of these braces because I don't need them.
Now, we're down to three lines and all I need to do is add the I take damage interface to my three different classes.
my dog.
So, I'll add it right up here.
And we'll make this word public instead of internal because the interface needs it to be public unless I mark it as internal in there.
But making it match and making it public matches with everything else I've done.
So, we're going to do that.
And then we'll go back to the brick.
We'll add the I take damage.
So, we add a comma after the other interface and I take damage.
And again, we're going to have that problem of it saying internal instead of public.
I'll just replace it with public.
And then the final one is in the ladybug.
Well, again after the I take laser damage, paste in a comma or put a comma and then I take damage and then just go make sure that this says public and not internal.
I'll save.
Do a build with control shiftb.
Make sure all those little stars disappear.
We'll press play.
And now we'll have a much more generic, a lot easier to extend way for us to take damage or to make things take damage.
Let's shoot.
The dog takes damage and dies.
Let's go kill this ladybug here.
She takes damage and dies.
And if I blast these bricks, they still take damage and die.
But I don't need to modify my blaster shot script anymore.
When I want to add in new objects, I'll just make them implement that I take damage interface.
Let's go to the plastic and add our notes that we've added the I take damage interface and check it in.
It's time to add explosions.
We're going to add an impact particle when our projectile lands.
So, we're going to take that blaster shot and whenever it hits something, we're going to spawn one of these explosion blue prefabs.
Let's drag this out and see what it looks like.
You can see here it's kind of huge, but if I press play, it does this neat explosion effect.
Let's watch it real quick and then we'll figure out a size that looks better.
So, that's cool, but way too big.
If I scale it down to about 0.25, though, now it looks about the size that my blaster shots were at.
So, I'm going to pick that as my size that we'll use.
I'm going to go down to my explosion prefab and change it to 0.25 and 0.25 on the X and the Y.
The Z doesn't matter because it's completely flat.
As long as it's not zero, it's fine.
So, I'm just going to leave it at one.
Now, we need to go to our blaster shot and make this thing spawn one of these explosion objects.
To do that, we'll open up the blaster shot script.
And in the on collision enter, we're just going to instantiate a blaster explosion or an let's call it an impact explosion.
So say var explosion because we're going to do something with it afterwards.
Equals and we want the instantiate method.
So we'll call instantiate and we'll give it a name of a new field that we're going to create.
And what did I say we're going to call this? Impact explosion.
And then we're going to spawn this at the point of the collision.
And so we don't want to use our projectiles position.
That's like the center of it.
We want to use the collision contacts.
Let's see if I can spell contacts right, not contracts at zero.
So the first contact and we want the position or the point of that.
And then the final thing we need is a rotation.
We'll just use quatronian.identity.
Add the semicolon at the end.
And now we need to create an impact explosion field.
So, I'll hit alt enter and generate a field.
Got to go down to variable and choose field.
Hit F12 to go to it and I'll replace private with serializ field.
There we go.
I'm going to cut it and move it up by my other serialized field and put game object instead of object so that I can add a serialized game object or my explosion.
I'm going to save.
And then I did mention that we want to do something with this explosion because once it spawns, I do want it to kind of kill itself over time.
But uh let let's spawn it for now and then we'll take a look at that next.
First, we'll go into Unity.
We'll go find our player, which has our blaster on it.
Make sure we got everything selected.
There we go.
And then I'm going to go select um my prefab for my blaster shot.
There we go.
That's what I was really looking for.
I could have just gone down to the prefabs folder.
So, we'll find the player blaster shot and we're going to assign the impact explosion.
So, I'm just going to drag the impact explosion over there like that.
Press play and let's start shooting things.
So, we play and shots hit.
And you can see my explosion got there, but it's just repeating over and over.
Let's go shoot a couple more things.
I shoot that.
Shoot a couple more shots out there.
And every time a shot lands, we're spawning these these explosions.
But the explosions just keep playing over and over and over.
So, we've got to make these explosions disappear or go away.
And the quickest way to do that is going to be right after we do the instantiating.
We can call the destroy method.
So, we call destroy.
And we need to pass in not the explosion, but the explosions game object.
And then another field for the delay or the amount of time that we want to wait.
Now, I know that this explosion ends at about 1 second.
So, I want to be a little tiny bit less than that cuz I know that if I put in a one here, but I get a little flash of that extra bit of particle.
So, I'm going to put in a 0.9 and a semicolon.
Now, if that number doesn't work, I can always just come back and change it.
But, let's try that out.
Got it at a 0.9.
What's going to happen now is we'll spawn this projectile or this explosion when the projectile lands.
And after 9/10 of a second, we'll destroy the object.
Let's go back into Unity, press play, and start blasting stuff.
See if we get a cool explosion that shows up visually, but um doesn't uh stay around and doesn't keep looping.
There we go.
Looks like it worked.
That one is not destroying cuz nothing is set to destroy.
That's just placed in the world.
Let's go shoot a couple more things.
Hit that guy.
You can see that my projectiles are landing, the shots are spawning, and they look right.
They're not uh they're not repeating or doing anything strange.
So, I'm going to stop playing, make sure that I've saved my scene, go into plastic, and say we added our initial explosions on impact.
And in just a moment, we're going to actually start to talk about some of the performance characteristics of what we've just done and how we can improve upon that as well.
So, get ready for that.
But for now, let's check in our changes.
Now, I want to bring our second player back in.
I've got my controller here.
We're already in play mode, so I'll hit the button and try to join in once I give the window focus.
There we go.
I've got my character here, and I can jump them around.
Looks like they're both working fine.
Let's shoot, though.
So, I blast and look at that.
My shots are able to hit each other.
I'm going to shoot the other robot with this controller.
And yeah, my shots hit him as well.
So, I want to make a couple little changes here.
I want to make it so that our blaster shots can go through each other so that we can help each other and take out enemies.
I also want to go away from the split screen mode.
Split screen's pretty interesting and it's easy to set up.
But the mode that I'm thinking is more like a Cuphead where we're running along blasting and shooting stuff and I want to get into that side byside view where the camera is automatically adjusting.
So, we're going to make a couple of changes to make both of those things possible so we can have a nice fun faster pace sides scrolling game where we're blowing up and blasting lots of different things.
Let's start by making our projectiles go through our players and our players go through each other.
To do that, we're going to go to edit and go to our project settings.
And we'll start by going to physics 2D and just unchecking player and player collisions so that our players can run right through each other.
Now, if you're on the physics tab and you're scrolled down, there's also a player and player.
That's not going to help here.
it won't work and you're going to get some well unexpected behavior of the collision still happening.
So here we've got player and player unchecked.
I'm going to move this away.
Press play and I should now see that my players no longer run into each other.
Let's check that that's the case.
So we press play and I run right here and I can run right through my other character.
All right, that's looking pretty good so far.
Now we need to make it so that our projectiles do the same thing.
And to do that, we can just go find our projectile prefab, go find our player blaster shot, and change the layer right here to be on the player layer.
I'll hit yes to change the children.
Let's press play again.
And when we start shooting, our shots should go right through each other.
Let's see.
Got to get our character in.
There we go.
We run over here, we shoot, and my shots go right on through them, just like I expected.
Now, we could have added a separate layer for our player shot, but there's really no need for it right now.
We just don't want our blaster shot to interact with the exact same things that our player shouldn't interact with.
If we have to change that matrix, we have to modify it later, we need to do something special for the blaster shots versus the players, then we can always split them out.
But there's no need to now.
No reason to make it overly complicated or add any extra confusion there.
So, let's stop playing.
Let's save our project and make sure that our prefab is updated and then go into plastic and let's first in or update and check in our blaster shot.
So, we've let's see made players and blaster shots not collide with each other.
Got a nice simple commit.
We'll check this in and then dive into cameras.
Now, we're going to disable our split screen setup.
I think split screen's cool.
It makes a lot of sense for some types of games, but what I want to build doesn't work with split screen.
So, we're going to disable it and allow ourselves the ability to reenable it pretty easily if we decide we've changed our minds later.
So, let's stop playing.
We're going to go find the player prefab and open it up.
Underneath the player prefab, we have a main camera and a virtual camera.
And these are the two objects that we use for doing our split screen setup.
I'm going to right click or select both of them holding shift and leftclick.
Right click then and hit create empty parent.
I'll name this object by hitting F2.
Split screen camera.
And then go back out of or no, not going to go back out.
First, I'll uncheck it to disable it so that my split screen camera is off.
And then I'll go back out of prefab edit mode and save.
Now, my camera view is going to be completely black.
My game view shows nothing.
And the reason for that is I no longer have a camera in my scene.
So, we're going to create a new camera.
We're going to create a new Cinem Machine camera.
And we want to go with a target group camera.
This target group camera is going to follow our player or players and lock onto them and also show enemies or other points of interest that we might want to highlight.
Let's hit the plus button on the target list here with target group camera selected and then drag our first player in.
Still nothing shows.
The reason for that is if we go to our Cinem Machine brain, there's no camera attached to it.
When we had our player and underneath our player, if we expand it out and expand out the Cinem split screen camera, look at the main camera object here.
There's a Cinem Machine brain, but there's also a camera here.
a camera that's set to orthographic mode with a projection size of five.
So, let's go add one of those to our Cinem Machine brain down here.
We'll hit add component, add a camera.
We'll set the projection mode to orthographic and the size to five.
Now, we're going to go take a look at that virtual camera.
In the virtual camera, we've got two parts for our tracking.
And we've got the body and the aim.
The body is going to move the camera around to keep things in line and the aim is going to tilt the camera.
We don't want any tilting happening.
So, we're going to change aim to do nothing.
We're in a 2D game.
We don't want to be tilting around or anything.
And we're going to change the body to be framing transposer, which is the transposer that you want to use for a 2D orthographic game.
It's going to keep the objects in view by moving the camera in and out physically.
It's going to just move it away back and forth.
Now, if we look down in the corner, you'll see that we've got a minimum ortho size, and this is the furthest away or the closest that it can get.
Remember, one is really, really close.
That's what you're seeing here.
And if we put it up to about a five, it's going to be right at what our camera was at before.
So, now we've got a tracked camera that should follow this character around.
Let's press play.
And we're going to see that so far we don't really have anything new.
We should just have our camera working for player one and probably completely broken for player two.
So, there we go.
I can run around on player one.
Seems to track fine.
I can run, jump.
Everything's going okay.
And if I join in on player two, well, player two is no longer visible.
They can just run off screen.
So, let's add player two to the target group.
I'll select my target group, hit the plus button, and go find our second player.
Where are you, player two? There you are.
I'll drag player two in there.
And now I've got two players being tracked.
Let's run around.
And you can see that both of my players are tracked.
And right now, we've got absolutely no limits on our distance.
I think we've got the max size to 5,000 or something.
So, we can get pretty far away.
Obviously, I think this is a little too far.
I'll add some restraints later or constraints later.
But for now, I like that it's able to track and follow my players, but I don't like that I have to drag these in because that's just not a realistic option.
I can't go dragging players into a target group every time.
So, what we're going to do is have our player automatically add themselves to the target group.
And then we'll figure out a more advanced target group filtering system later when we have some other things to add into there.
Let's start with the player though.
We'll go into our player script.
And when we enable our player, let's just find the target group if there is one and add oursel to it.
So, we're going to go right below our awake method and add an on enable.
In our on enable, we'll just search and find the object of type that is the Cinem machine target group.
Did that find it? Did I type it right? Let's see.
There we go.
Now, if you don't get it autocompleting, make sure that you add the using Cinem Machine statement up here.
That automatically added when I typed it out and hit enter.
That's why it went from black to blue.
If it doesn't happen and you don't see that, if it looks like this, then just go up here and add that statement using Cinem Machine manually if you can't get it to add automatically.
Now, if we find that object, so we're going to put a question mark dot.
If we find it, we're going to add a member, which is going to be our transform.
And then we need to give it a weight, which we'll put in a one, and a radius, where we'll just put in a one.
We'll put a semicolon at the end.
And then we're going to add an on disable.
And remember real quick that this question mark is going to make sure that we only call the ad member if we find a Cinem Machine target group.
If we don't find one in our scene, this code behind it won't get called.
So we won't get an exception or an error saying, hey, we couldn't find a target group.
All right, let's go add an on disabled.
Before we do that, though, I'm going to delete my private keyword.
Go to the end of line 56.
So I just go down and hit the end key, hit alt enter and hit use expression body methods to shorten this up and make it into a oneliner.
Then I'll duplicate it with control or command D and change the enable to disable.
And then we'll instead of adding a member, remove a member.
We don't need the two parameters after the transform.
So we'll just put in the transform and remove those two after the the first comma.
We'll save and do a build.
And now our player should get automatically added and removed from that list as they enable and disable.
Let's see if that works.
So we press play and our first character's here.
Our second character comes in.
We run around and it looks like everything is tracking.
Let's go take a look at that target group.
One thing to note is that our first player is actually in the target group twice.
Um that's just because we had them added manually and then they're adding themselves again.
So, it does get double added.
That's something we can address later, but as you can tell, it's not actually causing any real issue.
We still have both of our players tracked perfectly fine.
All right, let's stop playing and let's save our scene and then we'll commit this into plastic before we start working on having it set up for our other scenes.
say that we've added split or added um multi-player target group view instead of split screen and we'll check that in.
Now that we've taken split screen out, if we open up level one or level two, we're going to see that we have no camera around.
So, we need to add our camera setup to our other scenes.
And first thing that we're going to do is turn it into a prefab.
We have this Cinem Machine brain that has the camera on it and the brain component, the virtual camera and our target group that right now has a player assigned to it.
Let's select all three of these objects, rightclick, and add an empty parent by choosing the create empty parent.
I'm going to call this um multiplayer camera setup.
And then I'm going to drag that into my prefabs folder.
Now I've got a multiplayer camera set up that I can add to my other scenes.
So I'll go into level one.
I'll make sure that I save my sandbox scene.
Go to the prefabs folder and take out my multiplayer camera.
Now I can see it in here.
I'll save that and I'm going to go into level two as well and just grab that camera in so that I've got the same camera setup for both of them.
Right now I could of course have a different camera setup and that's something that happens very often in games.
So, we'll have a slightly different camera setup for each different level, but base them off of a single prefab.
Let's go back into the sandbox scene, though, and do a little bit more work.
So, we've got our multiplayer camera set up.
Let's press play.
Make sure that it's all working with the prefab that we're able to track both players.
I've got my controller right here, so I should be able to jump in any second.
All right, so run over here.
Run over here.
And things are tracking.
Oh, Steam popped up.
Let's run over here again and let things track.
It looks like my characters are tracking just fine.
I can get nice and far away and uh I can blast that guy.
It's looking pretty good.
So, now that that's working, I want to stop playing and I want to go into level one and test out level one.
Let's press play here and then we'll add in our second character.
And I'm going to run over player one to the right.
Go grab those coins.
Keep them running.
Keep them running.
Come over here by this frog.
And notice that we're not hearing any frog sounds.
And the reason for that is pretty simp.
Oh, it's pretty simple though.
The reason was that player one wasn't playing the sounds.
It was only the most recent player because I have multiple audio listeners.
And if you look at our log, you'll even see there are some logs like this where we've got multiple entries, one per frame saying that we have multiple audio listeners in the scene.
And what's going on is that each of our players, if we look at them, has this listener object on it.
If we select it, we've got a listener right here.
So, they're both trying to listen at the same time.
And only one can actually listen.
So, only the most recently added one is actually going to pick up any sound.
So, we need to stop playing and change our audio setup just a little bit.
We're going to remove the audio listener from our player and put it onto our camera setup.
Let's go into player prefab edit mode.
remove the audio listener.
I'll just right click and hit remove component.
Go back out.
Hit save.
And I'm going to go find my multiplayer camera setup and expand it out.
And on the virtual camera brain.
So, this is the object that's following or that's that's being moved around.
This is where the camera is.
We'll add an audio listener.
Audio listener.
There we go.
We now have an audio listener component.
We'll add that to the prefab, though.
So, we're going to go to overrides on the prefab and hit apply all.
see that it's got the little plus saying that we've now modified this on the prefab.
We're hit apply.
And now if I go into any of my scenes, that should Let's hit save.
Then we should see the audio listener is on that child right there because we applied it to the prefab.
All right, let's go back into level one.
We're going to press play and we're going to see first if that error is gone.
So let's see.
The multiple audio listener error is not there.
I add in a second player.
It's still not there.
Let's run over here, grab some coins.
Remember, the coins don't have positional sound on.
Go over by my frog.
And I still don't hear anything from him.
Now, let's get the other player over there.
And we'll listen some more.
And notice that we still don't hear anything.
The reason for that is if we go to our camera, let's go find our multiplayer camera.
We go find the Cinem Machine brain here.
We're going to go into 3D mode and hit F.
And look at the position of this camera.
Right now, it's at -11 because it's moving out and it's moving away.
So now our positional check that we were using here for the frog where we had that range of what was it 10 m away on the audio source.
Where did we put that uh on our 3D sound settings? Yeah.
On our max distance of 10, that's no longer in range.
So if I crank this up to a 20 Let's see that.
Now we can start to hear it because it's actually kind of pulling out.
And if we get closer together so that we're closer to the character or this guy, it should be even louder.
And I can run away, of course, and stop hearing him eventually.
But for now, I'm going to stop playing, save our scene, and then we'll commit our changes.
Let's make sure that we've got that frog's max distance cranked back up to 20 so that we'll be able to hear him when we get somewhat in range.
We'll save our scene, go to plastic that we added, multiplayer camera setup, and we'll check our changes in.
It's time for us to start talking performance.
Right now, we have two players in our game that can shoot an unlimited number of bullets that just keep flying around forever.
So, we can see that bullets are flying.
I can look over to my left side in my hierarchy and see new shots going off constantly.
And when shots land and hit things, I can see that I get a shot that appears and disables itself over time.
Now, right now, this isn't going to cause any problems.
I can run around, shoot many hundreds of times, and my game's probably going to run fine.
But eventually, it's going to slow down.
Depending on the system, the problems are going to come faster and faster.
If you're on a mobile device, they're going to come much, much quicker than if you're on an extremely high-end development system.
But let's make it a little bit easier to reproduce the upcoming problems that we're just about to solve and to view them in the profiler.
We're going to stop playing.
And what I want to do is open up our blaster script.
We're going to go find the blaster on our player and we're going to make a quick modification.
Instead of firing when we pull the trigger down, we're going to fire every frame that we're holding the button down.
We'll do that by going into our update method.
And I'm just going to copy line 17 up to the dot part, everything up to the end of the fire in the braces and paste it in here.
I'll put that inside an if with some parenthesis.
And it'll say if that get or no it's read sorry I lied read value and it's of type float not get it's a read value we're going to read a floating point value that's going to be 0 to one if it's greater than zero then we're going to try firing or just do a fire so we'll just try fire and we don't have an object or a context a callback context to pass in so we're just going to pass in null.
Actually we can't even pass in null.
we're going to have to pass in a new call back context.
So instead of doing that, we'll just take this line here, 22 and 23, and we'll add some braces and paste it in.
A lot better than calling it and creating a new context.
We don't want to start causing other issues.
So there we go.
We've got our launch code inside of the update.
And I'm going to comment outline 17 so that we don't ever call try a fire.
We just call it in update right now.
And we're again going to call this every single frame where we're holding the button down.
So we can spam out shots and then take a look at the performance characteristics of that and see how we can optimize it.
So let's jump back into Unity.
Now we're in play mode and let's hold the button down and look at those shots start firing.
I'm going to get my other player in, hold this trigger down, and look at all those shots go blasting off.
Lots and lots of firing.
So what's the issue? Well, if I hold it down for long enough, eventually I'm going to start to see my frame rate dip.
But like I said, that's going to probably take quite a while on this system.
It's got a lot of memory and a very, very, very beefy CPU and video card.
So, it might be pretty difficult for me to see the slowdown just shooting these, but I can see that the frame rate is starting to drop.
It's going down into the 20s and 30s.
It was in the ' 50s and 60s a moment ago.
Let's take a look at the profiler though to see this data I think even quicker and a little bit more visual representation of what's going on.
If we go to window and we go to sequencing, no analysis right below sequencing and go to profiler, this will pop up the full-on profiler window.
This may or may not be docked.
I'm going to grab it and just dock it down below right next to our console.
I'm going to drag it up just a little bit once I've got it selected and make it just a little bit bigger.
Now, if you scroll down here, you see that there are actually quite a few different profilers.
It starts with the CPU one that shows just what our CPU usage is and shows us each thing that we're running each frame.
So, it'll tell us what thing took the most amount of time.
If I go through and sort by time, I can find each frame and see that well here we're actually getting a little bit of work in the physics 2D fixed update.
That's actually taking 9 milliseconds.
And if I scroll through, you can see that the time on that.
It looks like it might be going up, but it's a little bit hard to Oh, there's one where it's at 18 milliseconds, which is really, really high for a single colon there.
But let's scroll down and see the part that I think is more interesting and even more apparent.
If we go to memory, and then we choose this option to see the current frame and then unpause, we can actually see the memory allocations live.
Well, let's go back to that profiler tab.
Drag it.
If I could click and drag, this would be a lot easier.
We can actually see the allocations happening.
If we look down here at the other, we can see how much memory we're using with our own objects.
And if I just start holding the buttons down, watch as those memory allocations just go up, up, up, up, up, and up.
We're going to keep eating up more and more RAM, and eventually our game is going to blow up.
We'll run out of system memory or something else or the whole thing again is going to slow down.
Ah, look at that.
But we can see our our performance is actually dropping quite a bit now even on this high-end system.
So we need to do something about that.
We've got to fix the problem.
Now one solution is just to destroy all of those objects that were appearing and have them get kind of cleaned up instead of disabling them.
So let's go through that next.
Let's open up the blaster shot script.
See if I can find my blaster shot.
There we go.
And instead of disabling our game object here on line 40, let's destroy it.
We'll say destroy.
and we'll pass in our own game object.
Now, we'll add a semicolon at the end, and this will immediately destroy our object.
So, we shouldn't end up with all of that physics work that going on.
We're just going to have all of our objects being created, landing, hitting, and then getting destroyed.
It also should reduce the amount of memory that we're using because we're not going to keep those objects around.
We're going to create them, and then destroy them.
That does, however, cause one other issue, which is going to be memory fragmentation.
Let's check this out, though.
We'll press play and in just a second, we should be able to get our player in here, start shooting, and look at the memory usage.
You see that it's going oh about the same.
It's going up a little bit.
It's going to drop a little bit.
Let's shoot some more.
And look at the memory usage staying right around what is it about 410 412.
It's no longer doing that skyrocketing and kind of going up up up and away, which is what it was doing before.
Also, our performance isn't dropping nearly as fast.
Let's face the other direction, though, just so we can get more more shots going and staying around for a little bit longer.
But what and that's another thing to note.
Once we shoot off to the left, our shots aren't getting destroyed.
So, we need them to actually self-destruct as well.
So, we'll stop playing and we'll add in one more bit of code in here to our blaster shots to make them self-destroy after some certain amount of time.
So, we'll go up into our awake method and right after we launch ourselves or right after we get created, let's just say destroy and we'll destroy our game object and then we'll give it a delay of some maximum lifetime.
I'm going to make that a variable and call it underscore max lifetime.
And then we'll generate a field for it.
Alt enter and go down and generate a field.
F12.
We'll go back, replace the private with serializ field.
And then I'm going to cut this line with shift delete and move it up and paste.
So we've got a max lifetime that needs a default value.
I'm going to give it a value of 4 seconds.
So that after 4 seconds, our object will automatically destroy even if it hasn't hit anything.
Let's go check that out.
And now we should be able to see that our memory usage won't go up even if we're shooting off to the left where our shots just go off forever and ever and ever.
Let's see.
So we press play.
We'll face to the left, keep shooting, and our hierarchy should also stay about the same size instead of growing indefinitely.
So, let's check it out.
We aim to the left and shoot.
And I'll come in on another player.
Aim to the left and shoot as well.
And we can see that the hierarchy, it's growing a little bit, but eventually it's going to stop.
And see that the size of it isn't changing anymore.
And you can tell just by looking at this that the size isn't changing.
Now it's shrinking and growing again up until I get however many shots it is that I can fire over 4 seconds out.
And once those disappear, as we can see, they'll start kind of cleaning up out of the hierarchy and disappearing.
And then eventually they're all gone.
If I go to the scene view and go to 2D mode, let's see.
We can actually zoom out and watch the shots disappearing.
Let's do it from just the other player.
So watch the shots from this player going out.
And you see that over time once they live for 4 seconds they end up disappearing and that's why our hierarchy ends right about here and our memory usage is kind of peaked or capped right there.
So this is working.
This helps a little bit but again it does cause one other problem which is our garbage collector is going to be working overtime because we're constantly creating and destroying objects.
Now on Windows on a super high-end system doesn't make any difference.
You're not even going to be able to tell on here.
Soon as I go to a mobile device though, you're going to notice a huge, huge spike.
So, we'll talk about that in a moment.
For now though, we're going to go into plastic and commit our initial changes that the blaster shots selfdestruct and clean up.
And we'll check that in.
Now, we're going to dive into the solution to our despawning or spawning and despawning objects problem.
the problem with memory where we end up with either too much memory allocated or we end up with memory fragmentation and our garbage collector has to reallocate and clear up and move objects around again.
On a high-end desktop system, you're going to have a hard time seeing that until you hit a really hard or high limit.
And on a mobile device, you're going to see it almost instantly.
You're going to see the freezes and hitches when the garbage collector is trying to fix up and reallocate or rearrange objects in memory so that it can create new objects.
Now, this is a very common problem in game development and the very common solution to this is to create a pool or a reusable group of objects.
In this case, it'll be a reusable group of blaster shots.
So, we'll create blaster shots, have them pulled together, and then we'll request one of these blaster shots from the pool, launch it off, and then whenever it hits the end target, we'll just disable it and send it back to the pool to be reused for the next time that we need a shot.
We'll end up with quite a few objects in our pool, but that's okay.
We can have it all be totally dynamic.
And to create a pool, we don't need to do very much because since it's such a common problem, Unity's built a pooling system right into the editor.
You'll probably find a lot of videos on how to create pools, how to do all of this on your own, but if you just use the latest versions of Unity, you can use the object pool that's built right in.
And that's what we're going to use.
If you look at the Unity documentation, you can see the object pool is a way to optimize projects to it says lower the burden of CPU and when you have to rapidly create and destroy new objects.
And it says it's a good practice and design pattern.
Again, such a common problem that Unity released a solution for it.
And here you can see some examples that they have.
This is a script for a particle system that will make it automatically return itself to a pool.
This is I'm not sure which one this is.
This is getting a pulled item and showing quite a few of the different methods.
Now, we're going to go through writing this code ourself and setting up a pool for our blaster so that it can shoot out objects and then reuse those objects.
And then we'll figure out how to do them across players as well.
To make our blasters use pooling, we're going to start by opening up the blaster script.
So, select the player and open up the blaster script.
And up at the top in our awake, we're going to initialize and create a new object pool of type blaster shot.
So we're going to say underscore blaster or pool, not blaster pool equals new object pool of type.
So we do the open braces right there or the less than symbol.
And we're going to put in blaster shot.
Do an open close parenthesis.
And that will give us an error saying, "Hey, you need to pass in some parameters.
Specifically, you need to pass in a method that'll get called when our object is created or a method that will create and return back a new object." So, I'm going to create a new method here that we'll just type in the method name of.
And I'll call this um let's say add new blaster shot to pool.
A nice long name.
I'll hit alt enter and generate a method for it.
That should give me a method that returns back a blaster shot and just throws an exception.
Now, to spawn a new blaster shot, we're just going to instantiate one.
So, I'll just put that right here on line 25.
Instantiate a blaster shot prefab.
And I could just return that right here.
So, now I've got the definition or the correct call to create an object pool.
And I need to actually create the field for it.
So, I'll select the pool, hit alt enter, and generate a field right up here.
I'm going to double click the private keyword and hit enter just to get rid of it, and add a little bit of spacing.
So, now I have a pool that I can get blaster shots from.
And when it needs to create a new blaster shot, whenever it runs out of blaster shots, it's going to call this add new blaster shot to pool method, which will just return it a new blaster shot that it can add to the pool.
So, what do I need next? Well, I need to use this pool.
So we'll copy the pool and find the spots where we instantiated before.
So on line 31 when we called instantiate, I'm going to instead call pool.get.
I'll add a semicolon and I'm just going to comment out the rest of that line for now.
We're going to take another look at it in just a moment.
We're going to do the same thing here on line 40 where we're doing our super fast rapid fire.
In fact, I'll just select over here with shift and click, copy, and then paste right down here.
So in both cases, we'll now get the blaster shot from the pool instead of instantiating it.
And you might notice that this also means that we're no longer putting this blaster shot at the correct position because now when we instantiate it, we don't spawn it at a firepoint position and we're not spawning it multiple times.
So we can't pass in that firepoint position when we want to spawn it again.
So instead, let's give it the initial position to launch from in the launch method.
To do that, I'm going to copy firepoint.position_firepoint.position right onto my clipboard with C.
And in the launch call, I'm going to add a comma after direction and paste with alt enter or shift controlv, not alt enter.
And now I'm going to hit alt enter though and get my popup that's going to allow me to add a parameter to the launch method.
You can see here it wants to change it from being a method that takes a vector 2 named direction to one that takes a direction and a position.
If I hit enter, it's automatically generated it.
And now my launch method should look right.
I can't see it yet though.
Let's hit control and click on launch.
It'll take me right into the method.
Oh, it didn't actually do my change.
Let's go back and do that again.
Alt enter and we'll generate that method.
Oh, that's strange.
It was supposed to have refactored my method and changed it.
Let's go back and redo that real quick.
I want to go back into my blaster shot and we'll go back over to the parameter here.
Alt enter.
And we want to Oh, yeah.
It's not allowing me to generate my method this time.
That's fine.
I or it's not allowing me to refactor and automatically update my method.
That's okay, though.
I'll just go to the launch method.
We'll click on it.
Control-click.
And we'll type it in right here.
So I'll say comma vector 2 and we'll call this uh position.
Then we'll set our transform.position equal to position.
And it's important that when you're doing these autogenerates and you're going through and you know trying to hit the hotkeys to make things happen.
Sometimes it just doesn't happen and you've got to go in and do it manually.
You can't get stuck and hung up on the fact that something's not working in an autocomplete or something like that.
It'll really slow you down and giant waste of time.
Most of the time the tools just work, but every now and then something doesn't happen right and you've just got to work right past it.
Just go in and do it manually.
So here we need to get this other parameter into our second call into launch for the rapid fire.
So I'm going to copy what we've got selected right there on 32 and paste it in.
Now, if we just run with this, we will get shots launching, but they're not going to be reused because we're not actually sending anything back into the pool.
So, we need to make sure that instead of destroying our objects, we actually return them to the pool as well.
Let's go into our blaster shot script.
I'm going to hold control and leftclick on the blaster shot.
We destroy our blaster shot with this destroy call right here in awake and the destroy call on line 43 and on collision enter.
Instead of doing that, let's tell our object to self-destruct.
And when it self-destructs, it's just going to disable itself and return itself to the pool.
So right here in our awake method, I'm going to call an invoke and we'll call in method named self-destruct.
So I'll put name of selfdestruct.
That's going to make it so I don't have to use a string for the name.
And when I can now I can now generate the method name right here and change the return type to be void.
Now I need to give it a delay.
I'm going to give it a delay of our max lifetime and add a semicolon.
So it'll self-destruct at whatever our max lifetime is.
At the max lifetime, I want it to disable itself.
So just say game object setactive to false and then return itself to its pool.
Now, it doesn't have a reference to the pool, so it doesn't know how to get back to the pool.
I'm just going to assume that I can figure that out, though, and say underscorepool.release, and we want to release this.
Now, release is the method that you call on an object pool to send an object back to it or say, hey, this object is now ready to be reused.
Go ahead and put me back in your pool and do whatever you're going to do.
Now, we're going to need to get a reference to this pool though.
And I can do that from our launcher.
So, if I go to the blaster right here, when we are creating our blaster shot, instead of just instantiating it and returning it, let's instantiate it, tell it what pool it came from, and then return it.
So, I'll replace this word return with varshot equals.
Then I'll say shot setpool, and we'll pass in our underscore pool, which we do have here.
Remember this is the blaster.
It has a pool already defined.
And then we'll generate a method for that with alt enter by clicking on set pool and hitting alt enter.
And then finally return the shot.
Now I'm going to go into set pool by hitting control and clicking on it.
And then in the set pool method, we'll just say underscore pool equals pool.
I'm going to replace internal with public just because that's what I like to do.
And then generate the field for our pool.
This should give us a field up at the top that's a private object pool of type blaster shot named pool that gets defined or assigned right down here.
I'm going to go up to the top or remove that private keyword here.
And then the final thing I need to do is call self-destruct when our object gets destroyed.
So I'm going to copy this self-destruct right here.
Go down to the part where on line now it's 51 where we destroy our object.
I'm going to replace that and the set active call with self-destruct.
And we're going to um I guess that's it.
We don't really have to do anything else.
Just call self-destruct.
The final thing that you're going to notice now though is that when we spawn objects, they're going to be initialized or enabled by default.
They'll launch off.
They'll fire off.
They'll get returned to the pool and disabled and not turned back on.
Let's go see that real quick and then fix that last issue.
So, we'll jump in.
We'll press play.
And we should expect to see a bunch of blaster shots fire off and then some weird intermittent behavior where we have blaster shots not actually visible anymore and then eventually get to the point where we may have no more shots ever showing.
Let's hit play.
So, here we go.
There go the shots and you can start to see that intermittent set of blasting.
And what's actually happening is that we're just getting these blaster shots back from the pool that are already used.
So these objects, they're never getting reenabled.
So let's go back into our pool.
Oh, we can actually see we're even getting another error here.
Let's go back into our blaster script and make one more change.
Now when we define our pool and instantiate it, we only passed in the add new blaster shot to pool method.
But this method or this in constructor actually takes multiple parameters.
Now let's go take a look at the object pool parameters.
So here's the documentation and you can see that it takes quite a few parameters.
There's a create function which is the first one which is used to create a new object.
So that's the one that's instantiating something for us.
Then there's the one the next method action on get.
This is a method that gets called whenever an object is taken from the pool.
So whenever we call get this will get called automatically and this is a great place to enable our object.
There's also one for onre to call when our object gets released and this could be a great place to disable the object.
In fact it even says that right here.
There's one for destroy.
There's some a couple others that we're not going to dive into like a max size and a default capacity is actually kind of interesting.
If you need to spawn a large number of objects and you know that you're going to need at least 100, you could maybe set this to 100 and not have the objects spawn over time.
This is useful for things where you have a good idea of the size of the pool off the start of the game.
Now, we're going to dive in and just take advantage of the action on get and the action on release.
We go back to the code and minimize that window and we're gonna add in two new parameters.
So I'm going to put a comma there and a new line.
And for the next next uh input parameter, the thing that we're going to call, I'm going to use a lambda statement instead of creating a method.
So I'll put a t here and then a lambda.
So t is going to be the the object that gets released or the object that gets um gotten actually because the first one is the action on get.
So when we get an object, we'll get back a blaster shot and that'll be assigned to t here and I'll say t.gameobject game object dot set active to true.
Now I'm going to add a comma and go to the next parameter which is our action on release.
And we'll do the same T and a lambda statement.
t.game object set active to false.
Add in my closing brace right there or closing parenthesis right there.
Let's add another line.
Save.
And then I'm going to go into that blaster shot real quick and remove those two calls or that call in the self-destruct that sets us to not active because we'll already be inactive.
We don't need that anymore.
Now we're back in Unity.
Let's shoot and see what happens.
So you can see my shots firing off and it doesn't look like there's any missing or stuttering.
All of my projectiles are actually reappearing.
But we are seeing an error down here in the console.
If you have your console window open, you might be noticing this.
And the problem is that our object is self-destructing even after it's already been returned to the pool.
So imagine we hit something.
Our object hits right there.
Let's just clear the log real quick.
We hit it.
Our object has been returned to the pool, but the timer already fired off or on awake to make it return itself to the pool again.
And we need to fix that.
We need to actually not use the timer in awake and instead use something else.
we need to move it so that our object doesn't get destroyed only once and only once after it's been launched out.
So, let's go back into our blaster shot script and make our final change to the blaster shot.
Instead of calling our invoke in on awake, we're going to just delete this completely.
We're going to instead just give ourselves a self-destruct time in our launch.
We'll say underscore selfdestruct time equals time plus our max lifetime.
We'll generate a field for our self-destruct time.
I'm going to hit F12 and just go remove that private keyword from it.
And then we'll copy that self-destruct time onto our clipboard.
And inside of the update, I'm going to say if time is greater than or equal to our self-destruct time, then we will self-destruct.
Otherwise, we're not going to self-destruct.
And if we hit this object, we hit and release ourselves or call self-destruct.
Oops, that looks like I accidentally deleted that.
If we call self-destruct down here, we're going to disable our object and update's not going to get called again.
So, we won't be self-destructing more than once.
Let's save.
Do a build real quick.
Make sure that the build succeeded, which it looks like it did right down there.
And then we'll get back into Unity and start shooting and watch as our blaster shots fire off.
And I should expect that we've got now no errors.
And if I pull in my second player, let's get this controller on.
We should be able to start blasting.
And the same thing.
We've got shots firing off in both directions.
And no problems at all.
If I go to my profiler window, I can pull this up and watch the memory usage.
Let's see if I can drag this up properly for once.
Watch my memory usage.
And it should just be relatively stable, not starting to skyrocket and fly off.
It is going to go up a little bit though because we haven't completely fixed the problem.
If I don't if I look over here, you see that now it's not going to go up at all.
The problem is that our explosions are still not pulled.
So those things are still spawning an object and still creating some memory allocations.
We have one other issue, too, and that's that both of our players have their own pools.
So if one player starts shooting a whole bunch, let's let's just reproduce it real quick.
If one player starts shooting a whole bunch and then the other player starts shooting a whole bunch, the second player is going to need to create all of its own objects because the first player has its totally separate pool and they're not sharing those blaster shots.
So that's something that we want to think about and something we want to optimize.
And the of course the other shots are the other problem.
So here we go.
This is that player this the second player running around and see all of my shots here and the size of the the pool right here.
As soon as I start shooting on my other player, we're gonna get all new shots coming in because this player has its own pool.
So, let's stop playing, jump into plastic, make sure that we've committed everything, and then we'll talk about how we can optimize this even more.
So, we've added basic pooling to the blaster.
And let's check that in.
I mentioned in the last section that each one of our players has their own pool.
And I want to show what that looks like just a little bit more before we solve the problem there.
Let's go into the blaster script.
And I'm on line 27 where we add a new blaster shot to the pool.
And right after we do that, right on line uh 31, let's just log the count of all objects on the pool.
We're going to do debug log_pool.ount all.
This will show how many entries we have in that pool.
I'm also going to remove this private keyword so that it matches with the rest of my naming and conventions.
Now, I'm going to go into Unity and we're just going to start shooting a little bit with one of our blasters.
So, we'll use one of the players.
I'll shoot and see what the log entries look like and then we'll press play and or join in on the other player and see what the log entries look like as well.
All right, here we are.
And if I got my log open, I start shooting, you'll see that we got zero items.
Shoot a bit, we're starting to build up the items.
And the number is now up to like 70, 85 items, whatever.
If I clear out the log, it's never going to be a smaller number.
We're just going to get more as the pool grows.
So, I've got 99 items in this pool.
Now, I don't know if I'll if I shoot more yet, I can get up to 120.
So, it's as many as I need to have.
But as soon as I add in my second player and I run over, you see that they start shooting.
Now they've got 20 items in the pool.
30 65 totally separate pool of objects.
So the total number of objects I have is now not 188.
It's 188 plus however many this other character has.
So I want to remove that and get it down to a single pool for all of the like objects.
This will make a lot more sense for if we have poolled objects for our enemies.
We don't want to have a separate pool for each single enemy that shoots projectiles.
We want them to all reuse this these objects.
So, we may as well do the same with our player.
To just get started, we're going to create a new script.
And this new script is going to go right along with our game manager and player input manager.
And this will be a pool manager that'll be responsible for pooling anything that we pull.
And it'll be a good place for us to assign objects and grab them back.
So, we're going to go into the project folder and rightclick in the scripts folder.
Create a new C script.
And I'm going to call this pool manager.
No spaces with a capital P and a capital M.
We'll open that script up.
And we're going to start by just making it return back a blaster shot.
We'll make it blaster shot specific.
And then we'll extend it out from there.
So, I'm going to get rid of the start and update methods and instead we'll add an awake.
And in the awake method, we want to initialize that blaster shot pool.
Let's just go steal that code away from the blaster.
I'll go into my blaster and we'll find the part in awake where we initialize the pool and I'm going to select it all line 18 through 20.
Crl X and cut it and get it right out of there.
We'll paste it into our pool manager and get rid of the private keyword.
Now, we don't have the add blaster shot to pool.
So, we'll go into the blaster method and we'll take that as well.
I'll select it.
So lines 24 to 31.
Crl + X.
Go over to the pool manager and we'll paste it in.
We don't have a pool yet.
So we should go steal that declaration too.
We'll go over to the blaster one more time.
Take line 11, select it.
Ctrl X and then go over to the pool manager and we'll paste it in.
Oops, I accidentally added a plus.
We'll get rid of that and paste it in.
Now we do have an error here saying that it doesn't know what the object pool is.
If I hit alt enter, we should get a using option for using Unity engine.pool.
Click that.
And now our pools are back in.
That got automatically added to the blaster when we typed it in, or at least when I typed it in last time.
Now we need the blaster shot prefab.
We'll steal that from the blaster as well.
Each one of these things that we steal out of the blaster is making the blaster script simpler and moving the responsibility of spawning these objects into the pool manager.
So, we'll paste it into the pool manager.
We've got a blaster shot prefab.
We've got a pool.
We've got an awake method and a method to create our blaster shots.
Now, let's go back into the blaster and clean things up.
So, line 8 is blank.
We can clear that.
We've got an extra space here.
We can clear that.
And again, shift shift delete or control X will remove these lines here.
XR X get rid of those lines.
And now in our trifire and our update methods, we no longer have a pool to get from.
So, we need to replace this pool.get get with something that gets it from our pool manager.
So, I'm just going to put pool manager.instance because I know I could just turn this into a singleton if I just put the instance right there and then call get.
I'm going to copy pool manager.instance, paste it over the underscore pool.
I'm also going to get rid of these comments at the end of the lines just to make it a little bit less confusing so I have less to look at.
So, now I've got pool manager.instance.get get that will return back a blaster shot.
So, I don't think that that's a good method name though for getting a blaster shot.
I should probably call this get blaster shot.
I'll replace get down here with get blaster shot.
And then I finally need to create an instance here and then generate the get blaster shot method.
So, let's start by generating a property for the instance.
Now, I'll hit F12 to go check that property out.
to give me a public static object of in instance or named instance.
We're going to replace that with pool manager.
So instead of object, it'll be a pool manager.
Instead of an internal get, it'll be or set it'll be a private set.
Inside of awake, we'll set instance equal to this.
So now we've got an object that we can get the instance of that we can then call the get blaster shot on.
We finally need to generate a get blaster shot method.
So go back to the blaster, hit alt enter on the get blaster shot and generate a method.
And then all this needs to do is return pool.get.
Now right now our pool is only a blaster shot pool, but we could probably rename that to blaster shot pool in in a few minutes when we have another pool type.
For now though, let's make this public.
Save.
Do a build.
And we should have a working pool manager.
And now a single pool for both of our blaster shots.
Let's go double check.
Oh, we've got yep, our log entry right there.
Just want to make sure it was still there.
We'll go back into Unity.
We're going to add the pool manager to our game manager prefab so that it's available in all of our scenes.
And then we'll assign that blaster shot to it and we should be good to go.
Let's go check that out.
Here's that game manager.
We'll add our pool manager script to it.
I'm going to collapse some of these down.
And then we'll go assign the blaster shot prefab to it.
See if we can find that in my assets folder.
The search didn't show it, but I know where it is.
Just in my prefabs folder.
Take that player blaster shot and drop it right in.
Now I want to apply my changes to the prefab by going to the overrides and hitting apply all.
Oh, here I've pressed play.
And let's go check it out.
So I've got my log open.
If I shoot a couple shots, I can see I'm up to 11 there.
I've got my second player here.
Let's bring him in.
Start shooting.
And this guy's got 17.
Let's shoot up to Okay, 124.
Let's clear the log and keep clicking and see that.
Look at that.
I'm not getting any more.
Next one's going to be over 100 at least.
I might even have to shoot two of the 125.
There we go.
Start shooting from both players to start building up more and more.
So now I've got a single pool for all of my blaster shots and they're being reused.
I don't have to create new ones and I can use the same system for all of my other pulled objects.
Let's stop playing.
Make sure that I've saved my scene.
I think my prefab is updated.
Let's go into the plastic window.
And actually the first before we commit, let's go back to the blaster and remove that log entry because we don't really want to be spamming out that we are um or I guess it's in our pool manager.
We don't want to be spamming out the log entry of how many things are in the pool.
So, I'm going to delete that out.
We'll save.
Go back into Unity, go to plastic, and we'll commit our change that we've now created a pool manager to handle pulled objects.
Created pool manager to handle pulled objects and check in.
Because our impact particles, those explosions, aren't pulled yet, we're still not completely saving ourselves from the issues that we'll have with performance.
So, let's set up a more generic pooling setup that'll work for our impact particles and any other impact or explosion type things that we might want to show.
We're going to start by going into our blaster shot script right to the spot where we spawn our explosion.
And instead of spawning our explosion and telling it to destroy, let's just tell our pool manager to spawn one at this specific point.
We'll say pool manager.instance instance dot and here we have a get blaster shot.
Let's say get blaster explosion.
And then we'll pass in the point or position where we want to spawn this thing at, which is our second parameter right here, the collision contact point.
So I'm going to copy that and paste it as a parameter.
I accidentally got the comma, so I'll hit backspace, go over and add my semicolon.
Now I know that I want this to last a little less than a second.
The rotation doesn't seem to matter.
And the impact explosion is a prefab that I have defined up above.
So I'm going to delete lines 51 and 52.
Just hit shift delete.
Shift delete.
And then I'm going to go up to the part where I have my impact explosion.
And I'm going to double click that line or just click and hit home and hit controlX to get that onto my clipboard.
Now I'll generate a method for get blaster explosion.
Alt enter to generate the method and F12 to go to it.
So inside of my get blaster explosion, I just want to return back an object from a blaster explosion pool and set it well but also set its point or position to this point.
So we'll say var explosion equals and then we'll say underscore let's call this uh explosion pool.get.
We don't have an explosion pool yet, but we'll get one in a moment.
Then we'll say explosion.transform position equals point and then finally return explosion.
I'm going to change the return type here to be a game object.
So we'll just return back any old type of object and the type or the public.
We're going to replace internal here with public.
There we go.
Now we're going to need an explosion pool to get our objects from and to put things into.
So, let's go up to our pool manager up at the top and take a look at where we have our blaster shot pool.
Right here on line 11, we have an object pool of type blaster shot named pool.
I'm going to rename this to blaster shot pool.
Capitalize the S and the P so that we keep that nice camelc case.
So, I've got a blaster shot pool and I also want to have a pool for our blaster explosion.
I have the blaster explosion line already on my clipboard.
So, I'm just going to paste it in.
Or it's the impact explosion.
So, maybe I should just call this I'm going to call it blaster impact explosion.
Let's rename it.
So, I've got my blaster impact explosion.
I have my blaster shot pool.
I need a blaster impact explosion pool.
So, I'm going to duplicate line 12.
And I'm going to copy, what is this? Line 10, blaster impact explosion all the way up to the word pool and paste it.
We'll change the type here from blaster shot to game object so that it doesn't need to be a blaster shot and it can be any old type of object.
And then we'll instantiate the pool in our awake.
To instantiate the pool, we'll just add in a new set of lines.
Let's type it out this time instead of copy and pasting.
I'll say blaster impact explosion pool equals new and then let it autocomplete.
Now we'll give it our three methods.
The first thing that we need to do is give it a way to add or create an impact explosion, which is just going to be instantiating an object, setting its pool, and then returning it.
So, right now, let's just return an object instead of instantiating one or let's instantiate one instead of doing one where we have a pool to set because we don't have anything to set a pool on yet.
So, we're going to use a lambda statement.
I'll do an open close parenthesis and then equals greater than instantiate.
Got to spell it right.
Instantiate.
Let's see if I can spell it.
There we go.
And then open parenthesis.
And we'll do our blaster impact explosion.
And I'm going to rename this to add the word prefab at the end.
So that I know very obviously that this is the prefab.
So that's line one or the first parameter.
Then I'll add a comma.
And then our second is the set active and set inactive stuff.
So we've got to just basically copy lines 21 and 22.
So say T and do our lambda T T.Aame object or actually we're already on a game object.
So we'll just do T dot set active to true.
And then for the third parameter we do T and another lambda.
T dot set active to false.
Add in the closing parenthesis and the semicolon.
And now we have a pool that will give us back an object.
And um oh that's pretty much it.
It would just give us back an object.
Now, we need to replace the word explosion pool here with what I named it, which was blaster impact explosion pool.
And save.
If we just use this, it's going to get us our objects.
But you may have noticed that we're still missing something.
We're not actually returning our objects to the pool.
And that's part of the issue with the game objects.
If we want to return them to the pool, we're going to have to do something else.
We're going to have to give them some script or some way to know how long they need to be alive for or when they should return.
Now, there are easy ways to do this and hard ways to do this.
And my recommendation is almost always go with the easy way until it doesn't work and until you actually need to go with something harder.
So, what we're going to do is create a new script that's more generic that we can add to any object that will just return it to its own pool after some amount of time that we can define on the prefab.
Let's start by typing down at the bottom of our pool manager.
We're going to make a public class called return to pool.
We'll inherit from MonoBehavior.
So we have the colon mono behavior.
And then we're going to add in here an on enable.
So in on enable when we've enabled ourselves, we're going to invoke a method.
And I'm going to call this release.
Well, actually we need the word name of here.
Name of the keyword right around the release name.
and get rid of that capital S there.
And then we're going to delay that by some amount of time.
Let's call that um delay underscore delay.
We'll generate a field for the delay, which is going to be a float.
And then we'll make this a serialized field instead of private.
And I'm going to give it a default value of maybe like a half a second.
We can modify this per object.
So it'll be totally customizable.
Next, we'll generate a method for the release.
So I hit alt enter and generate release method.
make it return back void or nothing.
So it has no return.
Get rid of the private keyword.
Let's get rid of this private keyword up here as well.
And then in the release, we're just going to tell it to return itself to its pool.
So say pool or underscorepool.release this.
Now we don't have a reference to a pool.
So that's the last thing we're going to need.
We're going to make a public method public void set pool that takes in a pool of type return to pool.
So it be an object pool of type return to pool pool.
Now I'm going to use a lambda statement and just say underscore pool equals pool.
I can also turn the release method into an expression body and then hit alt enter and generate the field for it.
So now we have an object pool.
Oh, it didn't give me the object pool type.
That's a little bit obnoxious, but I'll just copy it right here.
Object pool return to pool.
We'll paste that right in and save.
We'll do a quick build.
And now that we have one more issue that we need to remove remove this script from this file.
It needs to be in its own file.
It's a mono behavior.
And for it to work and be a valid component, it has to be the first class in the file.
So we're going to move it to its own file, return to pool.cs.
Then we'll go back into the pool manager.
And the final thing we need to do is just replace these instances of game object with return to pool for our blaster impact explosion.
I'm going to actually also here by the way if you're not sure how to do that the thing I just did there.
Just click hold alt click and drag and then you can type on multiple lines at once and go back on multiple lines as well.
Last Oh, where else are we missing it? It looks like the explosion prefab needs the correct type as well.
And then finally, we need to make sure that we're setting the pool because in our initialization right here, we just instantiate the object.
We don't set the pool.
We have a couple options.
We could make another method like we have for our add blaster shot to pool.
Or I could just add in a little lambda statement or a little inside of our lambda statement, some parentheses and a couple more lines.
If we just have one thing after the lambda, we don't need a semicolon.
But if we have more than one thing and we have them in these parenthesis, we need a semicolon for each line.
So I have a line to instantiate it and we need to assign that to something.
So I'll call this barsh shot equals instantiate.
Then we say shot setpool.
We'll pass in our blaster impact explosion pool.
And then finally return shot.
This is exactly the same as creating a method down here just with a little bit less code.
Kind of keeping it all compact so that it's in one spot.
Let's save.
Do another build.
That build popped up.
One more error that I missed, which is right here that our get blaster explosion isn't returning the right type.
It's got game object instead of a return to pool.
Let's try one more build.
See if that works.
Do we get it? Did all the errors go away? I think so.
Let's go back into Unity and tab in.
I'm still seeing an error down there, but I think it just hasn't caught my new file change because the return to pool file moved to its own file and it hasn't updated in the editor yet.
Once I tab over, it should reload everything and then reappear and the error should just disappear.
Oh, there it goes.
It popped back up my code editor.
Yep.
And now my build succeeds before I can even see it in here.
So, let's press play and see if everything is properly pooling now.
Oh, you know what? It's definitely not cuz I haven't added the prefab to my game manager or my pool manager and I haven't added the script to the prefab.
So, let's go do that first and then we'll press play and make sure that it all works.
So, here's my pool manager.
Let's go find that blaster shot impact or the explosion right here and drag it on.
But I can't drag it on because it doesn't have the component that it needs, the return to pool.
So, I'll add the return to pool component to the prefab.
go find my pool manager again.
Drag my blaster impact explosion on and apply changes to my override.
Then we'll go into play mode and start blasting.
Let's watch these explosions all start to go into the pool.
There we go.
I can see my explosions coming out of the pool and going back in.
They're getting readded, redabled, or enabled and redabled.
And I end up with a nice steady amount of blaster shots and everything is I think working pretty well.
Let's get one more player in here just for the fun of it.
Make sure that we're still seeing um all of our shots properly.
Yep, looks good.
They can shoot right through each other.
And my blaster shots are, I think, looking pretty nice.
So, I'm going to stop playing, save everything off, make sure that I've got my scene saved, and again, my prefab overrides in there.
And then we'll go into plastic and say that we've added a return to pool a generic let's say added generic return to pool script for the explosions on pool manager and we'll check that in.
It's time to take a deeper look at our players animator.
If we watch right now you can see that our player idles but also constantly shoots.
And that happens even if I'm running around or jumping.
And I also can't duck.
There's no way to do our duck animation.
So, let's go find our robot.
Let's find his animator controller and open up the actual controller for it and then take a peek.
So, we've got a couple things going on here on our animator.
First, we have this mobility layer.
And we're going to talk about layers in just a moment.
On the mobility layer, we've got a couple things happening.
We have our idle animation that's playing right now.
And if I run around, remember we've hooked up our movement animation.
And that's happening with the move option or the move checkbox.
When move is checked, when we're actually moving, it's getting set to false by our code.
But when we're actually moving, it plays the run animation, but our fire still keeps happening.
And the reason for that is our layer setup here.
So an animator controller can have one layer, and a lot of them do have a single layer, but you can also add more layers by hitting the plus button.
And you can use multiple layers to blend and combine animations.
Here we've got our idle playing on the mobility layer.
And on this action layer, we have a shoot animation playing.
Now, we also have a hidded animation layer, which I don't like the name of at all.
And it's also not showing anything.
You can see that it's playing through.
It says it's going none, hurt, and dead, but you can't actually see anything animating there.
The reason for that is on this gear, there's a weight option.
And if we slide this from 0% all the way up to 100%, you can see that it starts to play that death animation loop.
Of course, it's fighting with the mobility one.
So, I can't actually tell what's going on or I can't see the death happening very well.
Now, I can't crank down the weight of my base layer.
I have to do something differently.
And I don't really like this setup personally for death animations.
I feel like the death stuff should probably be on this mobility layer.
So, I'm going to turn the weight down and we'll move that stuff over later.
For now, I want to take a look at our shooting.
Our shooting animation is constantly happening, not just when I actually shoot.
And what I'd like it to do is instead fire off whenever I click the button.
So, as soon as I click or as soon as I start a shot, it'll just fire off that animation.
So, we're going to add a new parameter.
We're going to go to the parameters tab.
I'm going to stop playing because I found that if I add parameters when I'm playing, half the time Unity just crashes.
And then I'll hit the plus button and we're going to choose trigger.
I'm going to name this trigger fire so that it matches with my input.
And then we'll add a transition right here from none into shoot.
Well, we've got the transition there.
We'll add a condition to that transition that we have the fire trigger happening.
We'll uncheck has exit time so that it happens immediately.
And now whenever I set fire, it should do this shooting animation and not um when I'm not when I don't set this trigger.
So, by default, it's not going to sit there and keep playing my fire animation, and it should instead just play it every time I click this box.
So, I click it, and it fires off.
You might notice, though, that if I click it, and I click it again.
Oh, yeah, it's firing pretty good.
That looks good enough.
So, I think that what we'll do is go now into our code and hook up our fire animation or our fire trigger.
So, to fire this off, we're going to need to know on our blaster when we're trying to shoot.
And when we try to shoot, we'll just tell our animator to set this fire trigger.
So we'll open up the blaster script.
And in the method where we fire, well, right now we have two spots where we fire.
We have this try fire and then we have our rapid fire section.
Let's take the lines of code 23 and 24.
Select them both here.
Hit alt enter and move this into a method named fire.
Inside of that fire method, we'll also set the animators trigger.
So say undersc_an animator a tour that's a n i m a t o r dot oops let's control z to undo and fix that autocomplete and we'll do set trigger and we're going to set the fire trigger.
We don't have an animator yet.
So I'm going to copy animator.
Go up to the top of my awake and we'll put animator equals get component.
And we want get component in children animator because remember our animator is a child of this object.
So, we're going to hit alt enter on the animator field.
Hit home, then alt enter, and generate an animator field.
And then I'll get rid of this private keyword here and add a little bit of spacing between my serialized field and my non- serialized fields.
We're going to reenable the performed event so that we now try fire whenever the fire method is performed.
So, only when I leftclick.
And we're going to add some checks in here to see if we can fire in a moment.
But for now, we'll just call straight into the fire method.
So, we got an empty method here that's calling into our other fire method.
And then we're going to replace lines 39 through 42 with the fire call as well, so that we can rapid fire by holding the button down.
And finally, I think I'm going to comment that out, but with control C.
So, I've got rapid fire set up there if I want to enable it, but I'm going to have it disabled by default.
So, I'll save, do a build, make sure that we can compile, and then we'll jump into Unity and see if our animator starts playing correctly.
So, we press play and let's click, click, and shoot.
Click and shoot.
And you can see that every time I click, it pulls up and it shoots.
So, there's one change I want to make so that it's a little bit more responsive.
So, that if it's still playing the downward animation, it'll fire off and go up again.
Let's take a look at that real quick.
Let's go to the animator and let's take a look at our shoot layer.
Here we are.
And you can see that when I shoot, there are lots of times when it's still playing in the shoot and it doesn't restart the shoot animation.
So, what we can do is add a transition from any state.
I'm going to stop playing because I don't want it to crash.
Make a transition into shoot.
And then on that transition, add the fire condition.
So now, even if it's in shoot, it will go into this shoot state.
I'm going to remove the transition from none over to shoot because that's just a duplicate transition.
We already have one from any state into there.
So, we don't need that other transition just to make it extra confusing.
Now, if I click, you see that every time I click the weapon goes up.
It's looking a little bit more responsive and I think kind of the way that I want it to.
So, I'm going to stop playing.
We'll go into plastic.
Make sure that we've saved our scene and project.
So, I'm going to go save project.
That'll make sure that my animator controller is updated.
and I say that we um made our blaster only animate when it's actually shooting.
Animates when shooting and check in the change.
Now, we're going to take a deeper look at our robots animator.
We're going to hook up the duck, make sure that it works properly, and figure out how to make that work with our character's collider movement and everything else.
So, let's take a look at our animator here.
Here I've got my robot selected and I've got the base object underneath it with the robot controller on it.
And here I've got my robot controller opened up.
So double click on the controller and double click on the actual character controller right there.
Pops open this controller on the bottom.
I'm going to go select the base.
I'm going to press play real quick and just watch it in debug mode for a moment.
See that I can go between my states again.
So I've got my idle state here and I go into the run state when I start running.
If I jump, I go into that jump state.
My blocks start to fall down.
And if I want to duck, right now, I don't have any way to do that other than going to parameters and choosing the duck option.
Remember, I can hit fire, and that should work when I'm ducking or when I'm standing.
It's not shooting off a projectile because I'm just clicking the button on the animator.
And if I stand up and click it, you'll see that it does that same animation.
Now, let's go take a look at the layers again.
Remember, we've got a mobility layer.
That's what we're seeing right here.
This is the default layer.
It's just what it's named.
It's called mobility because it's handling the movement.
It could also be called locomotion movement or just about anything else.
A lot of times it's just called layer.
We've got this layer though that handles our moving, jumping, and ducking.
And then we've got the other layer here for our shooting.
And then finally, we have this hit layer that we're not going to hook up yet, but eventually we're going to cut it and move it over to our mobility layer.
So, what I'd like to do now is make our duck work.
And then I'd like to make it so that we can do a couple other transitions that don't exist yet.
So right now our duck works by transitioning from idle into duck when the duck condition is true.
That's our parameter right here.
When this gets set to true, goes into duck.
And then when it's set to false, it goes out of duck.
If I'm running, it also gets set to true.
Let's see.
If I run and I stop, you see that it went in from duck or from run into duck.
And if I try to get out, it should well, it's not going to go straight into running because I'm not holding down the controller and clicking at the same time because it knocks me out of focus in the window.
So, let's now hook up our duck.
To do that, we're going to need to set this duck parameter in our code.
To do that, we'll open up our player.
I'll go to my player and find the player script.
We'll open that up.
And inside of our update, we're going to start reading our vertical input as well as our horizontal input.
On line 80, we read the horizontal input by reading the action move and getting its vector to which is our X and Y or our horizontal and vertical.
And I want to get the vertical part from it as well.
So I'm going to duplicate line 80 and change this X to a Y.
Now, personally, oh, first I'll change this to vertical.
And then I'm going to say that personally I don't really like doing it exactly this way because now we're reading that action twice just to get the x and y value.
And I'd rather just take this line right here or this bit of code on line 80 the part where we get the vector 2 cut it with an x and call this u let's just call this input with a lowercase i.
I'll say var input up above equals and then paste.
And then on line 82, I'll put input.y.
So now I've got a horizontal input and a vertical input.
I'm going to copy my vertical input.
And I'm going to go down to the part.
Oh, I think um right around here where I set the horizontal and I had it commented.
So right after my acceleration, I'll add two lines.
And I'm going to say underscorean animator set bool.
And we're going to set that duck bool.
So say duck and we're going to or is it duck or ducking? Let's go double check that I've I've typed the same name.
It is named duck.
Just want to double triple check to make sure that I get it right.
So we're going to call it duck and then we're going to pass in true if the horizontal value is not a negative one or the vertical value is not negative.
So if we're not pressing down, we'll put pass in true and we'll pass in false if we are put pressing downward or trying to get a negative value.
So I'll say underscore vertical or no there's no underscore just vertical input.
There we go.
Less than oh vertical input.
Got to get these.
There we go.
Got my auto correct right.
Less than zero.
So if our vertical input is less than zero then we will set the duck parameter on our animator which should cause our player to duck.
Let's save.
Go into Unity and press play and see if our player now ducks when we push down.
All right, here we are.
And I push down and you can see he goes into duck mode.
Let go and he goes back into up or standing.
And if I run and duck, he goes into duck mode and kind of slides around and then goes back into run as soon as I let go.
All right, that's kind of good.
But I don't want my character sliding around like that when he's ducking.
I want him to kind of stop moving as soon as I start actually ducking down.
So let's go into our player script again and let's add another line of code here so that we don't move if our vertical input is less than zero or so that our desired horizontal becomes zero if we're pressing down so that we kind of stop moving left and right.
So to do that I'm just going to add a new line and we'll say if vertical input is less than zero then desired horizontal is equal to zero.
So, this should stop us from moving sideways or stop us from having an input sideways if we're pressing downwards.
Let's go try that out.
We should be able to get in here and run around back and forth.
Yep.
And then I hit down.
And now I'm instantly stopped.
Run over here, hit down, and I'm instantly stopped.
Now, there is one issue with this.
We're going to address this in a moment, but try jumping and then pushing down.
Look at that.
Our jump stops in the middle.
We don't keep getting that arc.
We're not actually finishing our jump.
We just start dropping down instantly.
And that might be a setup that you want.
Maybe you want it that you push down and you instantly stomp down like a Kirby or something.
But that's not the effect that I want.
So, we're going to need to address that.
But before we do, we should check in our changes cuz we've got quite a bit here.
And then we'll continue on and fix it in the next section.
So, say we've added duck input to the player there.
Get rid of that extra space and checking our changes.
Now, the way our duck code works right now, it stops us from moving if we're running side to side and we press down by just checking to see what our input is.
And while that works great if we're just running and we want to stop like that and just push down, it doesn't work so great if we're in the air like I showed you a moment ago.
If we're jumping and we press down, our animation's still in that jump animation.
You can see on the animator, but our character stops going instantly because we're pressing duck and we're trying to duck, even though we haven't actually started ducking, it's stopping us from moving.
So, we're going to make a modification to this code.
We're going to change it so that instead of ducking when our prayer player presses duck, we'll read from the animator when our player is actually started ducking.
And in that case, we'll go into the stop moving mode.
So to do that, we're going to add in another parameter.
We're going to add a parameter that we're going to read instead of writing.
And when I add a read parameter, I usually like to prefix them with the word with the word is just so that I know that this is the one that I'm reading and not the one that I'm setting.
We're going to add a new parameter and it's going to be a bool type.
And I'm going to call this is ducking.
Now, we're going to set this is ducking script or this is ducking parameter, sorry, from a script that we'll set on this duck animator or this animator node.
So, on this animation node, we're going to add a new behavior.
And we're going to do this by clicking the add behavior, hitting new script, and we're going to call this duck behavior.
I'll hit enter, and we'll now get a new animator behavior.
Let's go find this duck behavior.
There we go.
I hit control, comma to search for it.
Now, when we create a duck behavior, what we actually get is a scriptable object that's attached to this animator node that has a bunch of callbacks on it.
So, just like on a MonoBehavior, when we start, we get a start method and then when we update, we get an update method that gets called automatically.
We can also automatically call some things on these animation nodes and then tie into our code.
You can see here there are quite a few commented out methods.
There's an onstate enter that gets fired off whenever we enter this state.
An onstate update that obviously gets called every frame.
And there's a comment here gets called every frame.
And then there's one when we exit the state.
And then we've also got some for when we move and when we do inverse kinematics.
We're going to deal with the onstate enter and onstate exit.
So to do that, we're going to uncomment these lines.
What is this? Line 8 through 11.
I'm going to hold alt and just drag over them.
Click and drag and get rid of the comments there.
And in the on state enter, we're going to get an animator passed in.
When we enter this duck behavior or this duck state, what we're going to do is tell it to set the boolean parameter is ducking to true.
So say animator set bool is ducking to true.
Now I'm going to copy that line and I'm going to do the same thing here on lines 20 through 23 in the on state exit.
So alt click drag remove the comments paste and then we're going to set is ducking to false.
Let's go back into Unity and see what that does and then we'll see how we can use that in our code to make this feel a little bit smoother and actually work exactly how I want it to work.
So we've got our duck behavior right there.
We've got this duck animation node and the duck behavior is on it.
If I press play and watch our robot animate, I may need to go select the base object here.
See the animation playing.
Oh no, it looks like we've got it.
So I run around and as soon as I duck, look at that is ducking.
Notice that is ducking isn't exactly the same as duck.
When I press down, it doesn't instantly pop on.
It's pretty close, but it's not instant.
When I release, you can definitely see the little bit of a delay as it transitions between states.
So now, let's see what happens if I jump and try to duck.
Well, I jump and duck and I still fall.
But that's because we're reading this duck variable.
Let's go change the code and see what happens if we change it to the is ducking variable instead.
So to do that, we'll open up our player and we'll find the line where we read duck.
Oh, where we set the duck bool.
And then right below it where we're doing the if vertical input is less than zero instead of that we're going to say if animator.getbool is ducking and we'll get rid of the less than zero and add a parenthesis.
So this is going to return true if is ducking is checked or true and false if it's not true.
Now, if I go back into Unity, we should see that when we're in that jump state, we're no longer going to get the ducking behavior until we actually land and drop down to the ground.
And um we'll also see that tiny bit of a delay.
Let's see.
So, I run maybe I can definitely see the delay when I'm standing up.
So, I don't actually start running until I stand up.
And if I jump and duck like that, the ducking doesn't happen until after I land.
That is the behavior that I was looking for and a very cool use of animator behaviors.
So, if you haven't used these state machine behaviors on the animator, this is a great way to use them.
There are also lots of other things that we're going to use them for.
But before we continue on, the last thing I want to do is make sure that we have a transition from ducking to jumping because look what happens if we jump from our ducking state.
Let's go into a duck state real quick and jump.
And I get this weird behavior where not only can I not move left and right, but I stay in this weird ducking animation.
And also notice that my my head hits way too early.
That's because my collider isn't correct.
We're going to address that soon.
First though, let's stop playing and add transitions from duck to jump.
I'm going to right click on duck, hit make transition, and go into jump.
And we want to make this transition.
I'll hit the button on under the condition that jump is true.
So to say jump is true, we'll go from duck into jump.
Now I'm going to make a transition from jump into duck.
And in this one, we want to make sure that jump is false and that duck is true.
So we'll go into the ducking state from a jump if we're pressing down.
We're trying to duck and oh, I got that backwards.
Duck is true.
And we're not jumping anymore.
So let's save.
Let's press play again.
And now we should see that nice smooth transition from a jump and back.
Actually, it's not going to be that smooth because I didn't uncheck has exit time.
So, I'm going to select both of those nodes.
Uncheck has exit time.
Uh, and I crashed my editor.
That happens.
I'll restart it real quick.
And now I'll remove those has exit times while I'm not playing.
Exactly why I don't do it while I'm playing.
It crashes relatively consistently if I modify this animator controller in play mode.
Now, press play.
And we should expect to see the correct duck to jump transition.
There we go.
Duck to jump.
And it goes right back in.
And I can move when I'm jumping.
Obviously, if I hit my head on stuff, it makes it a little bit harder, but you can see my transitions are now working pretty good.
I can't move when I'm when I'm ducking, but I can jump from that duck state and kind of continue on.
All right, let's stop playing.
Make sure that I've saved my project now because I've been modifying my animator controller.
go into plastic and say that we added the duck behavior.
And I I added the U here.
I did not put the U in the name there.
So spell it whichever way you prefer.
I don't think it really matters.
Added duck behavior and made player able to transition from duck to jump and back.
And we'll check in our change.
Now we're going to move down our laser beam.
And we're going to do this so that we can duck underneath it and set up some interesting challenges.
To start, let's grab our laser object.
We'll take the laser and I'm going to move it right down to about here, about one unit up.
So, two and a 2.5.
I'm going to take my laser switch and drag it over here to the left a little bit so I can play with it.
And then I'm going to take one of these blocks that don't move.
One of the ones with no rigid body on it or anything else, duplicate it, and move it right down here underneath my laser just so that it looks nice and I can't walk right through it.
All right, so now I've got my laser here.
But if I press play, we're going to see some strange behavior.
Let's check it out.
In fact, we can probably already see a little bit of strange behavior.
My laser beam is uh off in a weird spot.
Let's go turn this laser on.
And look at that.
I now have a laser beam firing over to my player from down here.
So, what's going on here? Think about this for a moment and try to figure out in your head what's happening.
Why do I have a laser beam going from up in the sky and smacking my player? I can turn it off.
I can turn it back on.
But if I keep running over, you see that I still keep getting a laser on my head.
Now, I can get away from it by going over here or something.
But the laser is back on my head.
So, I want you to just for a moment think about what's going on.
Think about why this might happen.
And then we're going to talk through the cause and I'll show you how to solve it.
So, I'll assume you've thought through.
If not, you can pause and think more.
If not, or you're ready to continue on.
Let's take a look at what's going on here.
So, we have our laser object, right? This laser is placed right here.
I'm going to go to the scene view.
Our laser is placed right here in the world at 2.5 and -2.5.
Our laser has a laser burst object on it that's placed right in the correct position.
If our laser was shooting from here over to our player's head, that would be about where it would hit.
And we also have a line renderer.
And the line renderer has two points on it.
It has a position zero that's at one one.
And then a position one, which is well variable.
Let's watch as I move my character around what happens to that position one.
Position one changes.
Position zero does not.
If I modify position zero here, let's say I put this down to a zero.
You can see that it actually does change it.
So position zero is the start of my line renderer.
And since the start of my line renderer doesn't match up with the position of my object, well, it's going to look very strange and be offset.
If I copy the position of my object into position zero, then you can see my laser shows up properly.
All right, so it's ready for me to duck almost, except first, I'd like to fix it so that we don't have to manually adjust the position every single time.
So, we're going to stop playing and go make a change to our laser script.
We're going to open up the laser script and in our laser, we're going to add an on validate method.
On validate will get called every time it validates our object.
essentially every time we click on it, save or do a build.
And in the onvalidate method, where I'm going to remove the private keyword, we're going to do a couple things.
First, we're going to cache our line renderer.
So, I'm going to take line 16, cut it, and paste it into 22.
That also means that I need to make this into a serialized field cuz otherwise it will not save.
So, if I don't serialize this field, it'll get it in on validate.
It'll work fine on validate, but then when I go to play mode, well, it won't have a value cuz on validate doesn't run when you start play mode.
I'm going to get rid of line 10.
Add a line after there for 11.
So we've got a blank space.
And then let's continue on to our onvalidate.
So in our onv validate, the first thing we want to do is just set our starting point to our transform point.
So we'll say underscore line renderer set position and we'll give it index of zero, that first position, and we're just going to set it to our transform.position.
Now, our end point or the left hand point should probably do the same thing that we do for our update.
It should just figure out where the object is to the left of it that would hit and then draw the laser out to there.
So then we can see what it's going to hit and have a good idea of that in edit mode, not have to go into play mode to test it out.
So we'll take the end point code line 40 and 42 and 43 the part where we get the end point the default one out in our direction and then where we raycast in the direction to find a collider.
Copy all of those up to line 30 and paste.
And then we'll say if first thing collider end point equals and here we actually probably could have just copied this line right here.
First thing point.
So, we'll get that point or for our end.
And then the final thing we'll do is set the line renderer set position.
Oh, whoops.
I put this into the wrong method.
I put this into toggle.
So, we're going to cut this, put it into onvalidate.
There we go.
And we'll line renderer set position one to our end point.
Now, I'm going to get rid of that extra line that I added in my toggle method.
Take another look at our onvalidate.
And then, let's go look at it in Unity.
We should now see our end point properly assigned and our lines showing up in the right spot right against our player.
Now, the one thing that's wrong is that our little laser beam is in the wrong position.
So, let's go open up the laser script one more time.
What did I call that thing? The laser burst.
So, we need to make sure that the laser burst position is getting set as well.
And I believe that is right here, line 53.
So, we'll copy line 53 as well.
and we'll paste that over to uh well, let's see.
I guess we could probably just do it right here at the end.
So, we have the laser beam, the point either at the far end or at the thing that it hits.
So, then we'll know exactly how far it's going to go.
Let's check it out.
There we go.
Now, I've got my laser beam there.
If I grab my player and I move him around, I should be able to see it update once I go reselect my my object or maybe save or press play and eventually it's going to build and then validate that.
All right, let's go turn it on and we run over here.
Looks good.
I still can't duck under it.
And I stopped playing and yeah, my laser is looking good.
All right.
So, I'm gonna stop playing.
Well, I guess I already stopped playing.
Go into plastic and make sure that I commit my laser change.
So, laser are now movable.
And we'll check that in.
in.
in.
Now that our laser is in position and we can duck underneath it, let's take a look at why it's still hitting our player and see what we can do to fix it.
I'm going to grab my game view, drag it down below, and then take a look at my scene view.
I'll select my player character and take a close look at him.
So, here you can see I've got my character with this collider and it's hitting me kind of right on the face.
If I duck down now, you can see my character with that same exact collider and it's hitting right at the top of my head.
So, I'd like to change this.
I'd like to shrink down my collider so that it doesn't hit my player when I'm ducking.
Now, if I look at my capsule collider, you can see that I've got it set to a size of two here.
If I drop this down to about a one, I can see that now I fit underneath it, but that offset is way off.
So, let's set the offset to a 0.5 or I guess it's a negative.5.
And now I can see that it would go under or go right through me.
But I don't know if that looks right with the duck.
So, I'm going to duck and say that is probably a little bit too small.
If we look at the collider again, you can see it's this green capsule right here.
I think it should be a little bit bigger.
So, one is too small.
I'm going to change this to a 1.2.
And then I'm going to stop playing.
Get my default values back.
And let's just add a second collider.
What I think what I'd like to do is get my second collider in cuz I want to make sure that the bottom of it aligns perfectly with this one.
So we're going to take our capsule collider now and we're going to hit copy component.
Then I'll rightclick again and hit paste component as new.
That'll give me another capsule collider down below that I'll drag up here to be side by side with my full-size collider.
Now, I'm going to change the size of this one.
I'm going to shrink it down to a 1.
Oh, let's go to like a 1 2.
That might be good.
And then grab the Y and drag it down until it lines up.
Figure out what that value is.
What is it about a point4? There we go.
And then let's see how that collider lines up and looks.
I'm going to first turn off the other collider.
Just uncheck it for a moment.
Press play.
And then I'm gonna look, duck, see what my character looks like.
See how that lines up.
And make sure that the laser also goes over the head.
That looks about right.
So, it does kind of go right through the antenna, but that's kind of the the feeling that I was looking for, that the antenna wouldn't necessarily count as a hit.
Um, yeah, I think that that's pretty close.
I could, of course, increase it a little bit more, but I want to give my player a little bit of wiggle room.
So, I think that that is a pretty good value.
Now that I've got my two colliders here, I need to actually make sure that they switch back and forth or so that we can actually have the tall collider on when we're tall and the short collider on when we're short.
To do that, we're going to just open up our player script.
And we already have code where we check to see if we're ducking.
And if we are ducking, we're going to just enable one collider.
And if we're not ducking, we'll enable the other collider.
So, first things first, let's cache the is ducking variable into a bool.
I'm going to cut it.
Add a new line and say var is ducking equals and then paste our animator.getbool.
I'll copy that is ducking and say if is ducking desired horizontal is zero.
And then we're going to say underscore duck collider.enabled is equal to is ducking.
I put two equals one equal.
And then we want an underscore standing collider.
Actually, let's name this ducking collider and standing collider.
And we'll call it say enabled not equals is ducking or no, sorry, equals not is ducking and put my words all backwards.
So the exclamation mark will make it be the inverse or the opposite of what is ducking is.
Now we're going to need these two colliders to exist.
The standing and the ducking collider.
I'll hit alt enter.
generate a field for both of them.
Click on the first one, generate a field.
Click on the second one, generate a field.
Hit F12.
And they're both going to be the wrong type, but it's easy enough.
I can just altclick and drag and change these two collider 2D.
We'll change private to serialize field.
So, I hit home.
I'm still in block edit mode.
So, I've got both of the lines selected.
I'm going to hold control and shift and hit the right arrow and then put square braces.
Serialize field and closing brace space.
There we go.
I've got my two colliders.
I want to move these up though over by my other serialized field.
So I'll cut and paste them right up here.
Save and do a build.
Now I did get an error here.
Oh, I got an error cuz I didn't put the D on enabled.
I put enabled instead of enabled.
Fix that error and go back into Unity.
This is again why I like to do builds all the time.
Instead of save, do control shiftB.
If I have a typo or something, I'm going to get a notification, a warning right away.
Now my player should have a ducking collider and a standing collider.
The standing collider is the tall one.
The ducking collider is the short one.
Now that those are assigned, I'm going to go to overrides, apply all of my prefab overrides, press play, and see if my character can duck underneath this laser beam properly.
Run over here, turn the laser on.
I'm getting hit in the face.
And duck.
Look at that.
I can duck under it.
Now I can set up whatever I want on the other side for my laser beam to hit.
And also, I can now duck underneath enemy shots, which I think is probably the much more important thing and the thing that you're going to be doing even more often.
But a laser beam is just as important to duck under.
Well, maybe not just as important, but still important.
All right, let's stop playing.
Go into plastic.
Let's save our sandbox scene that has our new player updated.
And our player can duck under things with the proper collider now.
And checking our changes.
It's time to give our player some inventory.
Right now, he has a blaster that's permanently equipped.
And I'd like to be able to give my player multiple different items.
Maybe swap out weapons or give them items that they can pick up in a level and use throughout that level.
And I want to start with two different item types.
one that we can have across multiple levels that kind of persists with us and one that's just for a specific level like a key to a specific lock on the level that we have to grab and find to go open something or trigger some other action.
Let's start by creating a key so we have two different items and then we'll figure out how we can build this into an inventory system for our player so they can pick up multiple things and then switch between them.
We're going to begin by going into the items folder of art and grabbing one of the keys.
I'm going to take the yellow key and drag it out here so that it's just off to the side of the player so that I can pick it up.
I think I'll zero out the X position.
Just go to a flat zero and do a -3.5 on my Y so that it's just evenly aligned with my cubes.
Now, I'm going to add a collider to it.
I'll go with a circle collider 2D.
And this is going to be so that I can pick the key up.
When I touch the collider, I want to pick up my key.
I'm gonna shrink the collider size down because you can see it's a little bit bigger than the key.
Maybe to about half of the 0.5 and about a 0.25.
Think that's close enough.
Maybe a.3 would be a little bit better, actually.
There we go.
That covers the edge of the key.
Should be able to pick it up pretty easily.
So now I've got a key with a collider on it.
And I need a script to be able to pick this thing up.
So I'm going to go into my scripts folder.
Actually, first I'm going to grab my duck behavior and drag that into my scripts folder since it's a script and it kind of belongs in there.
Then we'll go into the folder and I'll rightclick and choose create and we'll pick C script and we're going to call this key with a capital K.
So keY and then we'll open that script up in Visual Studio.
Get our code editor up here.
Now in our key script, I want to keep it pretty simple.
I want our key to just be able to lock and unlock things.
But I also want my key to be able to be picked up by the player.
So I'm going to start with a simple ont trigger enter 2D.
We'll delete out the start and update and just do an ont trigger enter 2D.
Let it autocomplete.
And first thing I'll do is check to see if it was a player that touched us.
So just check against the tag for now.
We'll say if collision compare tag and we'll check against that player tag that we have assigned to our player.
If we have a player that we've touched, then all we're going to do is say that our transform.parent or set parent to set our parent because we want our parent to be this other object or the player that we touched.
So there we go.
We can let it autocomplete and have it give us the collision.t transansform.
I'm going to save.
We'll go back into Unity.
We'll make sure that this object actually has our collider set as a trigger and that we have the script on there.
And then we're going to go pick the key up and see what it does.
So we go over here.
Oh, is trigger is not checked.
So, we'll make sure that gets checked.
And then let's go add the key script.
Now, we'll press play, and I should be able to walk over there, pick up a key, and have it just kind of be bound to my my object.
Not really bound, but parented to my object.
So, I run over.
There we go.
Now, I've got a key that kind of follows along and gets drugged behind me.
That's neat and all.
Not exactly what I want.
I kind of want the key to be in my player's hand instead, though.
So, let's start by making a little change.
so that we can drag or drop the key right up to where this player's hand is.
And in fact, let's take a look at it while we're playing.
I'm going to go through and click click and find the object that I've got here.
So, it looks like there's a front object.
We've got the gun right here, which is probably where I want this thing.
So, while we're playing, I'm actually just going to take my key.
Let's see if I can find it.
And drag it to be a child of the gun for now.
I'll reset the position.
0 0.
And yeah, that looks like it probably about right.
Let's change the sprite renderer and adjust the sorting layer to be on props so that shows in front of our player.
And yeah, that's about what I'm thinking right there.
That key sitting right in front of the player.
So, what we're going to do is add a new point now so that we can drop this key onto where the gun is without it being directly on the gun.
So, we'll stop playing, go to the gun, rightclick, and we're going to choose create empty.
It's going to give us another game object that's a child of the gun.
I'm going to call this item point.
Oh, let's move the mouse off of there and then drag it out so that it's not a child of the gun anymore.
Now, I'll go to my player and apply my overrides.
So, I just hit apply all to add that item point to my prefab.
Next, I need to find a way to assign this item point.
And to do that, well, we'll just add a field in our player like we have for our blaster and our fire point.
So, we'll go to the player and we're going to add a new field here.
I'm going to make this one public for now.
make a public transform and we're going to call this item point.
We're going to leave it just as a public field because in just a moment we're going to move it out of here and completely change it.
So for now we're going to leave it as a public field that we can assign or use and read from in our key method.
So instead of assigning it to or setting the parent to our collisions transform, we're going to get the player object and then assign it to the item point instead.
So instead of checking the tag now, we're going to look for a player.
So we'll say var player equals collision dot get component type player.
Then we'll say if the player is not equal to null then we'll transform set parent and we'll set it to the players item point.
We'll add the semicolon there.
Delete outlines 14 and 15.
We no longer need that code.
And then we'll jump back into Unity and we should see the key getting dropped onto the hand and in the correct point, which is also going to give us the nice side effect of when we turn around and face the opposite direction, it's now rotated and snapped over to the correct side.
Let's see if that's the case, though.
So, we come over here, we grab the key.
Oh, I can't grab my key.
Oh, and that's because my point isn't assigned.
That's because the item point on my player is not assigned.
So, if I take the item point here, drag it over.
Now I'll run over and grab it again.
And you can see that my key is assigning itself to the correct child or the correct parent.
It's now underneath the item point.
But my position is not getting zeroed out.
So I've still got an offset here.
If I zero this position out, you'll see that it goes to the correct place.
So I need to make two more little changes.
Let's stop playing and make those changes.
Now first change is we got to go to the player and reassign that item point while we're not in play mode.
apply our changes to our prefab so that that gets saved and works in all of our levels.
Next, we're going to go into the key and in the part where we set the parent, right after we set the parent, let's also set our local position to zero.
So, we'll do it to vector 3.0 and we'll save.
Now, that should reset our key so that our key is kind of snapped directly to our hand.
And we before we finish, let's make the third change that I I forgot to mention, which is that we need to make sure that our key is on the correct sprite layer.
So, we're going to go to the sorting layer, and we're going to change this to be props instead of default, so that it shows up in front of our player.
Now, I'll save my scene, press play, and let's run over, grab our key, see if it snaps to our hand, and we can move it back and forth, and maybe start using it to open some locks.
There we go.
I've got a key in my hand, and it's looking pretty good.
I can still shoot.
Weapon still works.
There's nothing stopping that right now.
But I've got a key and I can uh maybe start bouncing this around and and using it on something.
So, let's stop playing.
Go into plastic.
Make sure that we've saved everything.
Save the project as well.
And then say that we added the key script and check in.
We have a key now.
So, let's add a lock and make our key work and then see if we can figure out where some inventory refactoring might tie in.
We're going to start by going to the tiles folder and grab the yellow lock.
I'm going to take lock yellow and just drag it out here somewhere off to the left.
I think I'll go with what is that like a -9 and again a -3.5, which is what my ground is set to.
So, I've got my lock over here to the left, and I want to make it so that my key can unlock this lock, and so that when I unlock the lock, something happens.
I'd like to be able to just kind of toggle this to turn something on and off, kind of like I do with the switch.
So, let's add a new script.
We're going to add a toggle lock script that can toggle the state of this lock on and off and fire off some events.
We'll go to the scripts folder, rightclick, create a new car script, and I'm going to call this toggle lock.
I don't want to use just the word lock because it's a reserved word and if I do a lowercase lock then I'm going to have an a conflict with that specific word.
It's one of the few special case words kind of like var or string or int.
Lock is another one of those.
So now that I've got my toggle lock script, I'm going to add it to my lock yellow object.
And I'm going to rename both of these objects.
I'm going to name this yellow lock and I'm going to name this yellow key.
key.
key.
These are going to be my prefabs.
Next, I'm going to go to the yellow lock and we'll add a collider to it.
So, let's add a box collider 2D so that I can't walk through it anymore and then figure out how we're going to write some code so that our toggle lock can do some toggling and switching of the state of this thing.
So, let's start by going into the toggle lock script and add just a toggle method, one that toggles the state of this to from locked to unlocked.
We'll delete out the start and update.
And I'm just gonna make a public void toggle.
And then all this is going to do is switch the state of a bool and change the look of our sprite renderer to start.
So we'll say toggled equals underscore or not toggled.
There we go.
Hit alt enter and generate a field for it.
And we should get a private boolean.
So this is going to be the bool for whether or not it's toggled.
In fact, let's rename this to unlocked underscore unlocked.
It's controllr to do that or F2 to open up the rename dialogue.
So, I've got an unlocked boolean that'll toggle on and off when we call the toggle method.
Next, I want to change the look of the sprite renderer.
So, let's cache the sprite renderer and an awake method.
So, add an awake here and we'll say underscore sprite renderer equals and then let it automatically type out the rest of the code for us to get the component of the sprite renderer.
We'll generate a field by hitting home and alt enter.
And then I'm going to get rid of all of these extra private keywords that I don't need.
And in our toggle method, I'm going to set the sprite renderer's color to either white or gray depending on whether it's locked or unlocked.
So we'll say sprite renderer dot color equals.
And here we'll do an unlocked.
So if it's unlocked, we'll get the value after the question mark here.
If it's not unlocked, then we'd get the value after the colon that's going to be there.
So, we're going to start with color.white so that we get the nice bright fully colored version.
And the if it's locked, so if unlocked is not equal to true, then we get that second value here.
And that's going to be colorg gray.
There we go.
With an a gr a y.
So, this should allow me to toggle the lock on and off visually.
And then I can probably fire off some events from there.
Let's now add a context menu to this so that I can make sure that it works.
And we'll use name of toggle.
There we go.
Save and do a build.
And we should be able to now toggle this on and off in the inspector.
And then figure out how we can call this toggle method from our code from the key or somewhere else.
All right.
So, we're back in Unity.
I'm going to press play and then I'm going to right click on my toggle script and see if I can toggle it on and off.
off.
off.
So, press play.
It's actually my toggle lock script.
There we go.
And it's up.
So, I right click and I toggle it.
And now it's going to probably the on state.
I right click again and toggle it and it goes to the off state.
Right click again and toggle it goes to the on state again.
So the next thing I want to do is make it so that we default into the off state so that it kind of starts off by default.
It's not on.
To do that, we can just add some code in our awake unlocked equals false.
And then let's set the sprite renderer color again.
So I'm going to copy line 20.
And for now, we'll just paste it up here as line 14.
Realistically, it's always going to be gray, though, so I may as well simplify it and get rid of the turnary check there.
And just make sure that we set the sprite renderer color to gray.
Now that we'll go back into Unity, we should see that it's disabled by default.
And you can ignore that little error there on my plastic connection.
And then we'll run over here.
It's just trying to connect with my internet connection reset.
And we run over and look at that.
My lock is off.
If I right click on the lock, I can toggle it.
And I can toggle it back off.
So far so good.
Next step though is we need to make our key handle the toggling.
So before we do that, let's just check our toggle lock into plastic or first let's create prefabs out of these and then turn them and then commit them into plastic.
So we'll take the toggle lock, the yellow lock here, drag it into the prefabs folder.
I'm going to put this into the list view or not the non-list view, the icon view so I can see some empty space.
We'll take the toggle lock, drop it over and the yellow key.
Sorry, it's the yellow lock and the yellow key.
Make those into prefabs.
Go into plastic.
Now I've got my three files.
So that we added yellow lock and check in.
Now we're going to add a way for our player to use the key.
We're going to specifically add a less than optimal way in my opinion and then figure out how we can refactor that and talk about why it's less than optimal.
We're going to start by adding the code onto our key script.
So let's stop playing.
We're going to open up the key script.
And when we pick up the key, instead of just setting the position, let's also bind up to the player input so that we can re remember or get notified whenever the player presses the fire button.
So I said remember, but I really mean get notified or or get told about.
So we're going to say var player input equals player.get component player input.
Then we'll say player input dotactions just like before.
And we're going to get the fire action by name.
See if I can get rid of that popup there.
And then we'll register for the performed event.
I'll say plus equals.
And I'm going to name this method use.
Let's call it use key.
Make it a little bit more explicit.
I'm going to generate a method for that.
And we'll get a use key method that passes in that callback context for our input action.
I don't care about that context, though.
All I want to do is find all of the locks that are within a specific range that I can customize or adjust and then tell them to toggle.
Now, to get all of the locks in a range, I can use the physics 2D overlap circle method, which is what I'll do first.
I'll type in var hits equals so that I have something that I can assign all of the hits to.
And it's going to be physics 2D physics 2D.
There we go.
Circle.
But I want to make sure that I get the circle that gets all of them.
So it's overlap circle all.
There's also overlap circle nonalloque which is slightly better.
We'll talk about that later though.
Let's for now just use overlap circle all because we're only going to be activating this or firing this off when we use the key anyway.
So it's not going to be a big allocation issue.
Now we need to give it two parameters.
The starting point or the initial position which is just going to be our transform.position position and then a radius which is going to be like our use range.
So I'm going to name this underscore use range and then hit alt enter and generate a field for it.
I'll hit f12 and then let's go give this a default of like 1 meter and make it a serialized field.
So there we go.
We've got a use range of one.
I'm going to add the semicolon to the end of the line.
And now we've got back a list or really it's a a collection or an array of these hit objects.
Now my my mouse over is not giving me the uh the proper tool tip there.
So I'll just continue on.
So we've got our overlap circle hits and what I want to do is l loop through each of these hits.
So I'll say for each var hit in hits.
We want to check against this object and see if it has a key lock or a toggle lock on it.
So we'll say var toggle lock equals hit.get component and we'll try to get a toggle lock component.
If the toggle lock exists.
So if it's there then we'll let's add some braces.
Say toggle lock toggle.
And then let's just break or return out of this loop so that if we have multiple toggle locks in range, we only hit one of them.
There should never be a scenario where we hit multiple.
But we don't want to loop over all of the other colliders in there if we've already found a lock.
I'm going to remove this private keyword now.
Save and do a build.
And let's go try out our key.
We should be able to run over and use our key on that lock and watch it turn on and off.
All right, we'll play and then run over and grab our key.
Come over to the lock.
Click.
And look at that.
It turns on.
Click.
It turns off.
Click.
It turns on.
Click.
It turns off.
If I don't have the key, well, then that's not going to happen.
So, let's just go double check that and make sure that can run over there with no key on and click cuz every now and then you'll write code and not realize that you shortcuted something.
So, let's see.
Yep.
Doesn't work without a key.
Exactly as expected.
And if I pick up a key and run back over, it works fine.
All right.
So now we've got our key kind of working, but there's definitely an issue here.
One of the biggest issues is that our key if it disappears is going to start causing us to get some errors.
It's going to start causing us to throw exceptions.
Let's let's take a look at that.
Go find our body upper arm right arm lower hand and that item point.
So let's say I just um deleted my key and now I press fire.
Now I'm going to start getting null reference exceptions because the performed event is trying to fire off into something that no longer exists.
It's trying to make a call back into something there.
We also have this is also getting called I believe by our our input system as well.
So the input system bindings are still there even though our key has disappeared.
Also, if we have that key there and then we have our blaster and we pick up some other items, our if our key is listening for the inputs and registering for that, then our our objects are I in my opinion doing a way too much.
They're thinking too much.
They're having a little bit too much control.
These items instead should probably be controlled by the player or by some player inventory and have that script tell them when to be used and when not to be used.
Then we can hook up our bindings once, have it so that our player input just binds to whatever system it is that uses the items, and then have that system tell the items, whichever item is currently equipped to be used.
So that's where we're going to take this next.
But for now, we're going to stop playing.
We're going to go into plastic, and we're going to say that we added a well, let's save our scene, too.
Added a bad key use system.
So added ba let's see added basic key use setup not optimal so that we remember it's not the optimal setup that we want um but it's our first version of it which is again the way that I always like to write stuff make sure that we've got our code we've got it working we kind of got it figured out and then we figure out the actual system that it's going to fit into try to let these systems kind of develop and build around what it is that we're creating instead of trying to guess and predetermine what what they need to look like.
So, let's check that in.
Now, we've got a key and a lock.
But let's say I wanted to add another item.
Let's just start with something simple like another key.
Maybe I wanted a blue key and I wanted to duplicate my yellow key.
Rename it to blue key.
Hit W in scene view mode and maybe move it over here a little bit to the right.
Change that graphic over to the blue key instead.
And then I save.
and I press play and I go pick up some keys.
Well, what do you think's going to happen? And think about it for a minute while we go into play mode.
And then let's go try it out.
And we should see that we end up with just two keys kind of stacked on top of each other.
You can see I've got my yellow key there.
If I turn off the sprite renderer for the blue key is right behind it.
And if I run over here and try to use it, you'll see that it doesn't actually seem to turn my lock on and off.
And the reason for that is actually because I've got two keys here.
So, I'm toggling it on, and then my other key is toggling it off.
And I can't switch between these two keys.
I can't really control what I'm doing here, and I don't like having to have both of my items stacked.
So, what we're going to do now is add our player inventory script that's going to deal with keeping track of our items, letting us switch between active items, and controlling when we use items.
So, let's start by going to our player and actually into the scripts folder, and then rightclick, create a new player inventory script, and then we'll add it onto the player.
So, I've got my script created.
I'll go to the player, and I'm going to add this new player inventory script onto there.
Now, I could add all of this code into my player script, but I want to take a look at my player script real quick.
It's actually growing to be relatively large.
Let's see.
We've got down here at the bottom 225 lines of code.
If I add in all of the inventory code to this, well, we're probably going to hit around 300 or 350 lines of code.
My player is going to start to get bigger and bigger and bigger, and it doesn't necessarily need to.
I generally prefer to keep my classes around 200ish lines or less so that it's relatively manageable and maintainable for me that I don't end up with a giant class with hundreds of thousands or tens I've seen the most I've seen is like 50,000 I think in a class and I've seen quite a few that were like 10,000 lines.
It's terrible and it's nightmare.
You want to end up with smaller classes in general that are responsible for doing one specific thing.
And that's what our player inventory script is going to do.
one thing.
It's going to deal with playing placing our items in the correct spot and showing the correct items so that we can switch between them and using those items.
So, it's one responsibility, although it does, I guess, technically do more than one thing.
It's one responsibility of keeping track of our inventory.
So, let's take line 23 here, this item point that we had put on player, and let's first move that over to the player inventory.
So, I'm going to cut line 23, get rid of those empty spaces.
I'll open up our player inventory script.
Control, comma, brings up the drop down and start searching.
Player inv.
There we go.
Player inventory.
And I'm going to paste our item point up here.
Next, I'm going to go to the key.
And in the key where we tell it to get a player, instead of getting a player, I'm going to get a player input.
And then we're going to tell the player input to just pick this item up and do whatever it needs to do to pick this item up.
So, let's replace player here with player, not player input, player inventory.
I think I might have said input there.
And let's replace the word player here with player inventory.
Control-r or F2 to rename.
And now that I've got my player inventory, and I know it's not null, I'll say player inventory.
This.
Now, I'm going to take all of the code after that and just cut it.
I'll generate a method.
Alt enter.
I've got that on my clipboard, by the way.
Crl + X or shift delete to put that onto my clipboard.
Now I'll generate the pickup method.
Hit F12 to go into it.
And inside of that pickup method, I will paste.
But now the code that I have is actually kind of inverted.
I don't want to set the transform of my player inventory.
I want to set the keys transform parent.
So I'm going to take key put it before the transform.
Say key.transform setparent.
And then I just want to set it to my item point.
I don't need the player inventory anymore.
I can get rid of that.
And then I let's see, let's double check that we've got everything.
Yep.
Need to set the keys transform local position to zero as well.
So put a key right there.
And then we can delete outline 15.
And then let's take a look at our new line 15.
We have this player input actions fire.performed.
Remember when we pick up a key now, we're just binding to that performed action so that we get a call back and we could call it tell it to use.
Instead of doing that when we pick up, let's do that inside of our player inventory awake so that we can use it all the time no matter what item we have picked up.
And then we'll figure out what our active item is and kind of pass that message along.
So we're going to cut line 15x again.
And I'm going to add an awake method right up here.
In the awake, I'll paste, but we need to get a reference to the player input.
So I'm going to make this be underscore player input.
I'll go up a line and say underscore player input equals get component player input.
Remember this player inventory is at the same level on our player game object as the player input.
So let's go take a look at it real quick.
Got player inventory here and player input right there.
So it's got a direct reference just by calling get component.
Now that we've got our player input getting grabbed, we need to actually generate the field for it.
So we'll select it, hit alt enter, and hit generate field.
Should give us a private field up there.
I'll delete that private keyword.
And then we're going to come down here and implement the use key method.
Now, I don't want this to be use key because this is going to use whatever item I currently have equipped.
So, I'm instead going to rename this to use equipped item and then hit alt enter and generate a method for it.
Now, I want to use whatever item I have picked up most recently by calling it use method.
And right now, the only method or the only items that I'm picking up are keys.
So, I'm just gonna save this off into a variable for mo my most recently picked up key.
We'll change this in a moment, but let's start with something simple.
So, say underscore um equipped key.
Let's think there's two P's in there.
Equipped key equals key.
It'll be whatever key we picked up last.
We'll generate a field for it.
So, now we have a private key field up here named equipped key.
And then in the used equipped item method, we'll say equipped key key key dot use.
Now use is not showing up because I don't think it's marked as public.
So we're going to hold down control and click on it.
See if we can go to it.
Oh, let's just hit F12.
Okay, it's not even taking us in there.
We'll just hold control and click on the key.
Oh, it's cuz I named it use key.
That's right.
So we're going to go down here.
We're going to change the use key method.
Let's replace the word key with blank.
So it's just use.
We're going to get rid of the callback context because I don't need to pass in any input data here.
And then we're going to make this public instead of private.
I'm going to remove this private keyword here on the ont trigger enter too since I'm already in the file.
Now let's go back into our player inventory.
And our player inventory now should be able to use the equipped key whenever we press fire.
Now we don't want this to fire off and give us an exception if we haven't picked up a key yet.
So let's add one more line here before line 22.
I'll copy equipped key and we'll just say if equipped key and then oops, there we go.
All right, let's remove these two private keywords here.
Do a build.
Make sure that it compiles properly.
It looks like my build succeeded.
So, jump back over to Unity and let's go try picking up a key with our new player inventory.
We can't switch between them, but it should allow us to just use the whatever the most recently picked up key is.
Let's see if the use method works.
That's the main thing I want to make sure is functional and working.
So, I go grab a key and you can see that it's not in the correct position.
And I come over here and I obviously can't use it.
So, let's go take a look at the player inventory.
Ah, the item point's not assigned.
Let's go take the item point and assign it on the player inventory and then apply our overrides.
So, overrides, apply all.
So, our prefab is updated.
We'll save the scene so that we've got the updated prefab in there.
Press play one more time.
And now I expect that my key should go to the right place.
Yeah, that looks good.
And I can come over here and use it.
And if I go over here and grab the blue key, I've got one key still active.
So I should still be able to use this.
And now I've got multiple keys and I've got a way to start using things.
And I can start to make this a little bit more generic.
And I've got one hookup point for it.
Also, if I go in here and I just delete out my keys, go delete those two keys and start clicking, I'm not going to get errors because we're checking to see if that key exists and it's doesn't exist anymore.
So, we don't throw an error.
We do have it looks like one object returning to a pool that's probably just placed in the scene.
Not an issue to worry about.
So, I think we'll stop playing and go into plastic and let's check in our changes.
So, here we'll say that we've added initial player inventory and check in.
Now, we're going to give our player the ability to switch between items.
We'll start with keys and then again expand out to more item types in the near future.
Let's go to our player and let's open up the player's input action map.
So, we'll double click on the actions and we're going to need to add a new action.
This will be our equip next action so that we can cycle through our different items.
I'm going to hit plus and just name this equip next.
And then I'm going to give it a binding.
So, I'll click down here in the bindings, and I'm just going to bind this to, I think, three on my keyboard.
So, I can just reach up, tap three, and then go on to the next thing.
You can bind it to whatever it is that you feel is the best next item button that you want, or you can even bind it to a mouse thing.
But I think that three is just kind of like where I rest my hand all the time.
I can reach up there and tap it nice and easily.
I'm going to save my asset, and then we're going to go into the player inventory script and bind up to this equip next.
So, let's go find our player inventory.
And right here where we're binding to our fire performed, let's duplicate the line and replace fire with equip next.
And then let's change the method instead of use equipped item to equip next.
Then we'll hit alt enter and generate a method for it.
it.
it.
And then get rid of that private keyword there.
So our equip next method is going to deal with changing what item we have equipped or what key we have equipped.
and then eventually what item we have equipped.
So to do that, to use that, we're going to need all of our equipped items in some sort of a collection so that we know what they are and we can go through them all and just activate the correct item.
So inside of our pickup method, instead of just adding a key and equipping it, let's add a key to a list.
So right now we we set the parent to it or we set the parent for the key.
We reset the position and we set the equip key.
Let's just add it to a items list.
So we'll say underscore items add and we'll add our key.
I'm going to generate a field for it and it's going to give me a totally wrong type of field I'm sure.
But I'll hit F12, go up to it.
Yeah, we got a private object.
Let's make it a list of keys for now.
We'll initialize it to a new list of keys and then hit home shift or control delete and get rid of that private keyword.
So now we've got all of our items that we pick up going into this list.
When we want to equip the next item, all we need to do is keep track of which item should be equipped next or which item is the next in our list, set that item to active and deactivate all of the other items and then also set our equipped key to that um specific one as well.
So to do that, we're going to keep track of the currently equipped item by index and then increment that.
So in our equip next we'll say underscorecurren item index++ then we'll say if our current item index is greater than or equal to our items.count we'll set the current item index to zero.
You can see that it's trying to autocomplete for me.
Current item index equals zero.
I'm going to hit home alt enter and generate a field for it which should just be an integer field.
they'll delete that private keyword and it's going to default to zero because there's no value set.
So we've got our current item index will increment when we try to equip the next item.
And then if it gets to be more than the number of items that we have or equal to the number of items that we have.
So say we have two items and our index gets up to two then we'll reset back to zero because zero will be the first item and index one will be the second item just like you see in our arrays in the inspector.
Same kind of thing here.
So, we've got our current item index incrementing and our items or our our resetting back to zero or looping back to zero.
Next, we want to just loop through each of our items.
So, I'll say four and then hit tab a couple times to have it generate a loop for me.
And I'm going to loop through the items.length or I guess it's going to be count because we're using a list and not an array.
So, we've got our loop through all of our items.
And what we want to do is set the item to be either active or inactive based on whether or not its ID or its index matches the current item index.
So we'll say underscore items or items at i.
We need the braces and the indexer.
So this is going to get us the first one zero at the first loop run through the loop and then it'll get us item one and then item two and so on until we run out of items.
So the first thing will be item zero and we're going to tell it to set its game object to set active and we want to set it to either true or false.
It'll be true if I is equal to our current item index and false for everything else.
So to do that we just say I double equals current item index.
So it'll go true for the one that we've selected and false for all of the others.
Now, this will toggle the object's active state, but it's not going to set our equipped key.
And we need to have that active or correct as well.
So, let's make a change to our equipped key, but instead of setting our equipped key inside of this equipped next method, let's turn this into a property instead.
So, I'm going to go to equipped key.
We're going to rename it.
Hit control-R.
I'm going to remove the underscore and the lowercase E and make it capital.
And then we're going to make it into a property.
And to do that, we're going to add a getter or just an expression body property, which is a lambda statement.
So do an equals and a greater than.
And what we're going to make it return is underscore items at our current index.
So now we'll get back the item at our current index.
Now, if we don't have any items at all, we need to make sure that we don't return back an an exception.
So if items has no entries and we try to get item zero, it's going to blow up and give us an exception.
So we also need to make sure that we've checked to see that items has at least the number of entries that we need.
So we'll say underscore items.count greater than or equal to our current item index.
Then we'll return back items at that index.
Otherwise, we'll just return back null and have no equipped key.
Now we've got an equipped key method or equipped key property that we can read from.
We no longer need to set it.
I'm going to remove that on line 45 and we'll save and then do a build.
Now, let's go try this out and see what it does.
You're going to notice that it almost works, but there's still one little issue here.
If we go pick up our our two keys, let's go grab them real quick.
And don't forget to remember what key you bound your next equip item to.
So, I'm going to run over here, grab that key.
Looks good.
I can hit three.
Doesn't seem to do anything.
Okay, looks cool.
Let's go grab this blue key.
You can see I got the blue key, but I don't see the blue key on me any right now.
If I hit three now, I can toggle between them.
But look at what that state was when I initially picked up the blue key.
It didn't turn on the blue key, and it didn't turn off the yellow key.
Well, I mean, the blue key was already on, so it just kind of left it there, but it didn't turn off that yellow key and hide the key away.
So, we never got the new equipped item.
When we picked up an item, it didn't automatically become equipped.
And that's what I'd like to change real quick.
Going to make it so that our item becomes automatically equipped.
Now, I think this seems like a perfect opportunity for a small challenge.
So, if you're up for it, go ahead and see if you can figure out how to equip the item as soon as you pick it up.
Do a little bit of refactoring, maybe extract out a single method, and then continue on, and I'll show you my solution for it.
All right, I assume that you've gone through it.
If not, then not a problem.
We're going to run through it right now.
The solution is actually pretty simple.
when we pick up an item, we just want to equip the most recent key or the most recent thing that we've grabbed.
So, first let's get rid of the start and update.
I don't know how those got in there.
I thought I had deleted them.
And then let's add a little bit of code here.
So, when we pick up, we're going to add an item.
And then let's just set our current index to be our last index.
We'll say it's equal to items.ount minus one.
So, this will give us our last index in the array.
Next, let's take our code that updates or toggles our active item and just extract it into a method.
So, we'll take lines 29 through 32, control shift or let's hit alt enter.
There we go.
And hit choose extract method.
And I'm going to call this um toggle equipped 2ps item.
There we go.
So, I've got a toggle equipped item that's just going to set the state of our item correctly based on whichever one's the current one.
And I'll copy that call to toggle equipped item and paste it down here in the bottom of pickup.
Get rid of that extra line there.
Let's jump back into Unity.
Got a little plastic error.
Not a problem.
We'll press play.
And now I expect that when I pick up the yellow key, it gets equipped.
And then when I run over and pick up the blue key, the blue key gets equipped.
Let's see.
So yellow key is equipped.
I can see the yellow key right there.
I go grab the blue key.
The yellow key is off and the blue key is on.
And if I hit three, I can switch between them.
So far so good.
Let's stop playing.
Go into plastic.
Make sure that we've saved our scene.
And I just want to make sure that I've saved my project.
I don't think there's anything different in there.
It looks good.
And say we added player inventory item switching and checkin.
Our current inventory system works pretty good for keys.
We can pick up multiple keys and toggle between them, but it doesn't do a very good job of dealing with our blaster.
We can switch between keys, but our blaster stays on.
And if I stop playing and start playing and just try to shoot, oh, we're going to run into an error saying that it can't find any keys to try to use and it's not trying to use our blaster instead.
In fact, our blaster fires off constantly, but we still get this error message.
If I go grab a key, the error is gone because it's able to use my key.
It's able to find something, but it's still firing off.
And this is definitely not the behavior that I want.
So, I want to make my blaster into an item.
I want to make it into a first class kind of item.
That's an object that can be used by our player just like the keys are.
But I want to do this slightly differently.
I don't want to take my blaster and pull it off of my player and then make it so that my player has to go pick it up.
I want it to be just kind of their default item that they start with or maybe an item that they can unlock and keep across multiple levels.
For now though, since I only have one weapon, I'm going to make it the default that they've got and they just kind of start with it.
So to do that, we're going to need to make a couple of changes to our player and to our blaster specifically.
Let's find the player object here in our sandbox and expand it out until we get to the blaster, which should be under the body upper and then the right arm and all the way down to the right below this item point, we've got the gun object.
If we go look at it in the scene view, let's go to the scene view.
We can see that this is our object for the blaster.
And I can turn it on and off by toggling the game object.
I'm going to rename this from gun to blaster.
And then we're going to take the blaster script from our player and we're going to click and drag it and drop it onto the blaster here.
That should move the script down to our blaster object and it's got a plus there and it should be removed from our player.
You can see it's got the minus right there.
And then we can go into our blaster and make sure that our settings are correct.
So, first thing we need to do is make sure we have a firepoint assigned.
And here you can see I'm in debug mode.
In normal mode, we see only the firepoint.
But if I go to debug mode, I can see all of the other fields that are going to need to be assigned as well.
We've got that animator, the player, and here it has a player input.
We're going to adjust this a little bit, though.
Let's go open up our blaster script, and let's make a few changes.
First off, I don't want my blaster causing animations to happen.
I want that to happen from my inventory system.
So, I'm going to delete the animator here.
And I also don't want my blaster reading input.
I want my inventory system doing that.
So I'm going to delete the player input as well.
I'm going to take line 14 and what is it? 16 and 17 and delete them all as well.
So we've just got our awake down to getting a player right now, which also is probably going to be an issue.
But for now, let's get the player.
But we need to get a player in parent.
So we'll do get component in parent because we're no longer at the same level as our player.
Remember our blaster is a child object way down here.
And our parent way up here has the player script on it.
There's our player script.
Let's go back into our blaster code though.
Open that blaster script and let's make the other changes that we're going to need.
So our fire method should no longer call the set trigger to fire.
We're going to do that inside of our player inventory.
So I'll delete that as well.
And I guess I'll delete out my rapid fire method.
The update.
I'm going to shrink this all down.
So now I've got a very small blaster script and I want this blaster script to be usable by my inventory.
So let's open up our inventory.
Let's save the blaster script and open up our inventory.
Inside of our inventory, the first thing I want to do is add our new blaster to our set of items and equip it.
I want to essentially call pickup and equip a blaster.
But you can see here that the pickup method takes a key.
And if I go look at our items list, well, we've defined this to take a key as well.
So, let's make something a little bit more generic.
Instead of having a key or a blaster there, let's have this be some sort of shared thing.
And I've got two options.
I can go with an abstract class, a base class that they both share and inherit from, or an interface where they both just have the same or similar methods.
And I feel like in this case, as with most cases, an interface is the best default implementation.
If we find that we're reusing a whole bunch of stuff and reusing a bunch of functionality, we could switch it to an abstract class.
But for now, let's start with an interface.
And to do that, we're going to create a new interface that our key and our blaster will both inherit or implement.
And let's call that I item.
So, we're going to go into our key.
And right at the end of our key, I'm just going to start typing a comma and I item.
I t.
So, it's an interface for an item.
That's why I'm using I item.
I'll hit alt enter and hit generate public interface or generate I item in new file.
It's the one that I want.
This should give me a new interface which is in a new file and it's going to say public interface.
Oh, where'd it go? Public interface I item or it says internal.
I'm going to make that be public.
Now, our interface is going to need to have at least one method on it that allows us to use the item.
It's going to need a couple other things, but the primary thing we need is a use method.
So, we're going to add a void use with a semicolon there and no parameters.
Let's go back into the player inventory.
And now, in all of the places where we're using a key, let's replace key with I item.
So, I'll take key and put in I item.
I'll copy that onto my clipboard and just start pasting it over all of my key entries.
So, my equipped key will now be essentially my equipped item.
We'll have to rename that in a moment.
The list will take I items.
And if I scroll down below, you can see that I start to have a couple errors.
The first error is that I item doesn't have a game object property.
So, it says I item doesn't contain a definition for game object.
So, we need to add one.
We can do that by hitting alt enter and creating a readonly property.
So, I hit enter and F12 to go to it.
And we should get an interface property here, but it's going to be the wrong type.
It'll be object instead of game object.
So, I need to go in here and put in game object.
Then save.
Oh, we got to hit alt enter and add the using Unity engine statement up to the top.
Then save.
We go back into our player inventory.
And now that error should be gone.
We can now call game object setactive on an I item.
It just has to be a mono behavior that has a game object that has a set active on it.
But as long as our interface is attached to a MonoBehavior, which in our case of a key, it is.
It's just on an object that inherits from MonoBehavior, it's going to automatically have that game object and be able to call set active.
Now, the other issue that we have is down here in use equipped item.
The equipped key check is giving an error because we're now comparing an interface to null instead of a class object to null.
And the shortcut of just checking it without the double equals null doesn't work when we're doing it with an interface.
So, we need to replace it with a not equals null to make sure that our equipped key or really our equipped item exists.
In fact, let's rename this to equipped item and then save.
Do a build and jump over to Unity.
And let's just make sure that our key still works.
We should still be able to pick up a key and use it, but probably not use our blaster.
So, here we are.
I can click and I get an error if I try to use my blaster as I expect.
I'm going to go grab both keys.
I can switch between them with my hotkey 3.
And the keys still work.
They still activate or toggle the lock, but my weapon doesn't shoot.
All right.
So, let's go back into the code and add our blaster as an item that we can use.
To do that, we're going to need to pick up our item probably in awake.
So, we're going to add a little loop in our awake method to find all of our children that implement the I item interface.
That way I can put multiple items on the player character from the start, have them kind of initialize with those or have those be on the prefab and then have them automatically be assigned.
I can toggle them on and off.
And I want to use these for items that I'm going to use across different levels.
For items that I want to use in a single level, I'll just pick them up normally.
So for the items that are children, like our blaster, we're going to find them with a get components and children.
And we'll use a loop.
So I'll do a for each var.
And let's call this item in get components in children.
I want the plural version to get the type I item.
So we want to get everything that implements that I item interface.
Then we want to pick up everything that's one of these items.
Now pickup doesn't take an I item.
So we're going to need to change the signature of it.
I'll control-click on it and we'll change key to be item.
And then I'm going to rename the key parameter here to be item.
Actually, I need to make this I item.
I've almost missed my I for the interface.
So there we go.
I've now got a pickup that takes items and adds them.
But you can see I've got another error because the item interface, the I item doesn't have a transform property.
So just like we did for the game object, we'll hit alt enter and generate a readonly property.
Hit F12 and go to it and change the type from object to transform.
It always just defaults to that base object which is kind of the uh the base level type for all of the objects in C.
And here I can see that I can shoot.
My blaster is working.
I can go pick up a key and it goes to key mode.
I can hit three to switch back to blaster.
Switch to my key and toggle these things on and off.
If I'm on my blaster, I shoot shots.
If I'm on my key, I toggle items.
So far so good.
I think it's time for me to commit.
So, I'll make sure I've saved my scene.
Go to plastic and say that we've added the blaster as an item.
It's got my duck behavior readded there.
I moved it around.
Just ignore that.
We're just going to check in these other files.
Now, let's take a look at player two.
We've got player one running around, ducking, picking up items, and doing things.
But what happens if we bring in a second player? I've got my controller here, and I'm going to try to join in as soon as I can get my mouse over the right spot.
There we go.
And I've got my character here that can run around and seems to duck quite a bit.
So, let's run over here.
See if I can pick up items.
Oh, I can get past the dog.
Okay, I'm going to go this way.
The dog is beating me up.
So, we'll run over here.
We'll go I see.
I'm ducking constantly.
And I'm going to run over here and pick up a key.
And well, okay, first things first.
My character poofed and disappeared.
And why did that happen? Well, let's take a look.
Let's see if there's a difference between our two players.
We've got our new player, our first player here, and our player's all set up with the inventory.
It's got the player input.
You can pick up items and this stuff seems to work.
And if I look at my other player, oh, you can instantly see that things changed, right? First off, the blaster script is on the player still.
And uh well, I wasn't able to pick up keys.
You saw what happened.
So, there's definitely a difference here.
And the first thing that we're going to notice before I give you any challenges is that our player hasn't had its prefab updated.
So, we need to hit apply all for our prefab.
We'll save the scene.
And now if I press play, I expect that our second player, while it will duck constantly, should be able to pick up an item.
Let's jump in.
There we go.
I got an item.
And I was able to pick up both of those items.
I can't switch items because I don't have a binding for my controller.
So, I'm kind of stuck on this key.
I should, however, be able to use the key.
But you might have noticed what happened there.
My key went kind of wonky and weird as soon as another player touched it because players just pick up and steal items from each other.
So, what we're going to do now is fix this issue and the ducking issue.
Now, we're going to take a look at item stealing.
Right now, our players can both pick up items and they can definitely steal from each other.
You can see that this player runs over, grabs the key, and runs off.
He could also run over and drop that key off if I'm slick enough with it.
Maybe I just got to take this guy over.
There we go.
Run over and steal the key.
They can pick up these keys and they can use them.
And they also get some kind of slightly strange behavior around them.
Look at this.
My character's toggling a lock with no key visible at all because the key actually was stolen by the other guy that's also kind of bugged out now.
So, how do we fix this issue? How do we stop an item from being picked up if it's already been picked up before? Assuming that we don't want to allow items to be picked up and passed around.
We could always add that later, but let's just assume that we want our items to stay with the player that owns them or has picked them up.
How can we go about that process? And what changes do we need to make to do that? It should be again, as usual, a pretty simple and straightforward change.
So, the challenge here is to go find the in my case, it's three lines of code that are all together that will make it so that your items only get picked up once.
So, I'm going to give you a chance to go ahead and see if you can figure that out, track it down, and if you need help, I'll give you a clue in just a moment, and then I'll finally give you the answer afterwards.
So, go ahead and give it a try.
And if you're getting stuck, let's just take a really quick look at the player inventory script.
Let's go through that.
We've got our player inventory script.
And right here, when we pick up an item, remember this happens.
Let's go find the line of code where it's called from inside of our player inventory.
It's called for picking up an item there.
And then if I hit shift F12, it's also called by our key.
So whenever we enter the collider of our key, we pick up the item as well.
So let's see how could we prevent this pickup from getting called again by another item.
Well, when we pick up our item, what we could do, if you haven't figured out the solution, if you've already figured out the solution, awesome.
If not, then what we can do is just disable the collider on the item that we have when we pick this item up so that it can't be picked up again.
It'll also prevent us from having an extra collider in there that's being calculated for no reason.
So, we can do that with a simple call to the items game object.
We'll say item.gameobject.get component.
And we want to get the collider 2D.
We'll save this off into a variable.
So, say var collider equals that.
and I'll say if collider is not equal to null.
So if we've got a collider then we'll set the collider enabled to false.
Now we need to check to make sure that we actually have a collider because our blaster doesn't need one.
We don't have to add a collider to our blaster to pick it up.
It's automatically there and picked up by the awake code.
So this code right here will disable it for the other objects that we've already picked up and or that we were going to pick up that have colliders and it will work fine for our blaster as well.
Let's press play and see if we can now run back and forth and get things working.
By the way, it looked kind of like we had our blaster stolen before.
It's not actually what happened.
What actually happened was that our item inventory index got messed up and we weren't able to switch back because an item got stolen away.
So, I've got my key here and if I let's see run over here, run past the player, you can see that he does not steal it.
I can take this player over here and he doesn't steal it.
I can use the key on the lock right there.
And my other player can run over here and grab a key as well.
I can switch between items on that player.
Run over here and even activate it by click.
I would be able to activate it by clicking, but I hit play.
But the one thing that I can't do still is switch inputs or switch items on my second player.
So, here we go.
Yep, that key works.
I join in, though, and I want a blast.
That works.
I get a key.
Cool.
But I can't change my attack or my weapon or my current item on that second player.
So, let's stop playing and let's do one more challenge in the same section.
Challenge is pretty simple.
Go ahead and figure out how to make it so that your item can be swapped on a controller as well as the keyboard.
If you don't have a controller, it's fine.
You can skip that part.
But if you do have a controller, which hopefully you've got something like this laying around, then go ahead and add in the input part for that as well.
And when you're done, again, continue on and I'll show you the solution.
All right, I'll assume that you're done or you're ready for the solution.
So, we're going to go to the player input and open up the action map.
Find equip next and expand it out.
We hit the plus and add a binding.
And then we'll just bind it up to oh, what is this? The the triangle.
That's it.
Tri angle on a PlayStation controller.
I'll save.
press play.
Now we should be able to go into Unity and press triangle to switch items and uh my right trigger to shoot.
Let's see if that's the case.
So I jump in.
I hit triangle and I can go back and forth between items and I can shoot with my shoot button.
I can go pick up another item.
Triangle goes through all three of them and my blaster still works.
So I think this is looking good.
I'm going to stop playing.
Go into plastic.
Make sure that my action map and my player inventory are both there.
And it'll say that we fixed item stealing and swapping with player two.
And check it in.
Now, we're going to add in another enemy.
This is the cat.
And the cat is going to reuse some of the concepts that we've already kind of started with and build upon them.
and it's also going to introduce some new concepts that we can apply back to our previous code.
So, let's start by moving the dog out of the way.
So, I've got my dog here.
I'm just going to put him up onto a platform over here.
Let's put that at what is this about five and uh I'm going to go with 4.5 there.
Have him sitting up there so I have plenty of room for my cat.
I'm going to go find that cat art object in the prefabs folder.
So, we have the cat right here.
here.
And if I double click on them, I can take a look at it.
You can see here it's a neat little robotic cat with a grenade on its tail that it's going to launch at the enemies.
So, the first thing I want to do is go find all of my sprite renderers.
So, we'll dig in.
Let's go just select everything and then, well, actually, let's go find the object that's not a sprite renderer.
I'm go select select.
I'm just going to click through and keep selecting until I accidentally select anything that's not a sprite renderer, like that foot.
As soon as notice that as soon as I click on an object that's not the sprite renderer, it says that this matching components list can't be edited.
So, I'm going to keep holding control.
That's how I select all these objects.
Just hold control and click.
I I realize that the foot objects are probably what I want to not click on.
So, I'm just not going to click those.
Select everything else.
Oh, effect doesn't look like one of them.
And then, now that I've got all my sprite renderers, I'm going to go to the sorting layer and we're going to Oh, I don't have my enemies layer here.
Let's um add a sorting layer and let's hit plus and let's call this enemies.
Thought I'd added one.
Apparently not.
So I'm going to go reselect them all and then do that again.
So let's just go I'm going to select all the way to the end.
So shift and end.
And then I'll just controllclick on the foot each each one of the feet and that one effect.
Now oh I'm missing something.
Is it the body? No.
One of these objects here.
We'll find Oh, it's the head right there.
So once I've unselected those parent objects, got my sprite renderer available again.
Go to the sorting layer and choose enemies.
Now if I look at my cat, I can see on the base it's got an animator, but it's missing the animator controller.
So I'm going to need to create an animator controller for my cat.
So let's go to the cat folder under animations.
Rightclick, choose create, and create an animator controller.
We'll call this cat.
And you can see that our cat has quite a few animations.
We're going to start with just an idle and a shoot, though.
I don't really need this guy walking yet.
If I decide I want him to walk, though, I can add that in.
Let's start by opening up our cat animator controller.
And here's my animator controller that popped up over to the side.
I'm just going to dock it up here.
I think I'll go side by side with my actual cat.
Then I'll take my idle animation and I'm going to drag it right into my animator controller.
I want to be able to go from an idle to a shoot.
So, I'll take my shoot animation and drag that into the animator controller as well.
And then we'll make transitions.
We're going to go from idle to shoot.
So, I'll right click, go from idle to shoot, and make a transition from shoot back into idle.
So, now we should be able to watch our cat character do his idle animations.
If I go select my character, let's see, let's go out of prefab edit mode.
Let's go drag a cat into our scene.
So, go from our cat.
Where's our prefabs? Take our cat and drag him right into the scene.
He's a little bit large right now.
Let's go make sure that the animator controller is actually assigned.
Oh, I didn't assign that animator controller.
So, let's go assign the animator controller.
Go back up to the prefab, hit overrides, and choose apply all.
Now, if I go to my animation window and I select the character right here, I can see some of my animations.
The two that are on my animator controller.
I got my idle and my shoot.
If I press play, I can see that it plays that idle.
And if I go to the shoot animation, I can press play and watch it do the shoot.
Let's hit play and watch it in game.
It should just go back and forth between the idle and the shoot animation.
See? So, it goes plays idle, then it plays a shoot, then it plays an idle, then it plays a shoot.
All right, looking good so far.
Obviously, this cat's a little bit big, though.
I've scaled everything else down to 0.5, so I think I'm going to scale this one down.
You're welcome to leave your cat huge if you want to have a giant cat.
Now to scale it down, we're going to take the base object, not the cat up here.
We're going to take the actual visual part right below it and scale it to 0.5 and.5.
Again, that Z doesn't really matter, but I like to just kind of keep it consistent there.
So, we're going to save that and then flip this cat around.
I'm going to go to the cat base object and do a 180 on the Z so that my cat is facing the correct direction.
So, now I've got my cat here.
He should be animating properly and let's see, swinging his tail off to the right, looking like he's going to shoot the grenade, but he is not actually ready to shoot that grenade.
In fact, if we take a look at the grenade here, let's go expand out the character.
See, it's under the body and then tail.
Tail.
There's a bomb here.
It looks like that's the object.
You can see that it's just a sprite object underneath this tail.
So, we're going to need to replace that.
We're going to need to replace it with an actual bomb that can launch, fire off, and hit our enemy or well, hit the cat's enemy, which is us, the player.
So, let's stop playing.
Go to the cat.
I want to make sure that I Oh, I do have one override change.
That's just for flipping the transform.
I don't need to apply that.
So, I'm going to go into plastic and say that we've set up our cat with the controller before we start putting together our projectile.
the setup cat and animator controller and we'll commit that.
Oh, and make sure that we've saved our scene as well.
This is our cat bomb.
It's just a spinning sprite that is going to explode when it touches our player or whatever other things we want it to explode on.
You can see I've got the animation playing here, but it's really just spinning along on the uh rotation.
So, it's taking this rotation value and it's spinning it.
And then there's a trail renderer that's adjusting its param its time.
So, that's for the trail that you'll see in a moment.
So, we've got it spinning around.
Again, this is just the cat bomb that we're going to set up.
Let's go to our project view.
Let's go find our cat.
And then, let's go take a look at our existing bomb.
If I look at here at my object and expand out my tail and look at the bomb, you see that this one's just a sprite renderer kind of holding the place of where our bomb is supposed to go.
So, I want to replace this now with our actual cat bomb object, the one that can spin around from our prefabs folder.
So, I'm going to take the cat bomb.
I'm going to drag it right on top of the bomb.
And then I'm going to drag it off of the bomb under up onto the tail.
I wanted to put it onto the bomb so its position would exactly line up.
Now I'm going to go select that bomb object underneath and I'm just going to delete it.
I don't want that object on there anymore.
Now I'm going to right click on my cat bomb and hit create empty parent.
And I'm going to call this bomb.
Let's call it cat bomb transform or catbomb firepoint.
There we go.
And then I've now I've got an object or a transform right here.
Let's hit W on it.
Oh, that's way off position.
So, for some reason, it did not create it at the position that I want it at.
So, what I'm going to do is rightclick and hit create empty.
And I'll name this cat bomb firepoint.
And I think that the reason that this went into the wrong position is it gave me a position in between the parent and the child.
And it really wanted a position at the exact spot of the child.
So, I'm going to take the second cat pom firepoint.
I'll take cat bomb, drag it onto the tail, delete the original cat bomb firepoint, the one that's bad.
Take the second one that I've created, drag it out underneath the tail, and I can just leave it there.
What I want now is to be able to spawn bombs at this fire point.
So, I can just keep spawning objects right here, and then eventually we'll figure out how to launch them away.
So, now that I've got my firepoint figured out, I think I'll actually just uh delete this cat bomb back out.
I'm going to go to my cat and go to overrides and apply my prefabs.
You see that I removed the bomb and added the firepoint.
Now I need to figure out and by the way, another easier way to do that would have been to just replace the bomb object and change it to be a the firepoint, but it was linked up with an animation.
And I don't know if that's going to cause other problems and figured we should show it both ways.
So here we've got our cat bomb firepoint.
We've got our cat.
Our cat now needs some sort of a script to deal with launching objects and deal with its cat behavior.
Remember on our dog, we have a dog script, but that's down here on the animator layer so that it can deal with animations.
And I mentioned that I'm not really a big fan of that.
I don't like having scripts anywhere below the top layer unless they absolutely need to be.
And there are ways around having our dog script at that level.
So, let's take a look at our cat script.
We'll put it at the base level and then see what we can do to maybe figure out how we can tie into animations that are one level below.
So, we're going to go to the scripts folder.
We're going to create a new C script and we'll call it cat.
We'll attach that to our cat here.
And then we're going to open that script up.
up.
up.
And the first thing we're going to want to do is get a prefab reference for our bomb that we want to spawn so that we can spawn a bomb whenever we kind of get to the point where we should reload.
And maybe if to start we can just do that every second or so.
So let's add a serialized field of type game object to start.
And we'll call this cat bomb prefab.
Inside of our start method, let's just invoke repeating that will spawn some bombs there.
So do an invoke repeating.
We'll give it the name of a method.
So saying name of and then we'll call this method let's say we'll call it let's say spawn grenade or let's say spawn cat bomb.
We want to keep it exactly matching the names.
And then we'll do it every 03 seconds.
I'll add a semicolon there and then we'll generate the spawn catbomb method.
See if it gives me the right type.
Oh no, it gave me it wants to return back an object.
We want it to return void instead.
And all we want to do in this is instantiate our prefab, which is going to be that catbomb prefab.
And we want to instantiate it at our catbomb firepoint.
So let's call this a fire point.
We'll generate a field for the firepoint that's going to be a transform.
So let's see, generate variable and field.
We'll scroll up here and we want this to be a transform, not a vector 3.
And we'll make it a serialized field as well.
So now we can assign a serialized field to our firepoint.
And every 3 seconds, oh, we're missing the second parameter here.
We need we need an initial delay and then a repeating delay.
So this will do it after 3 seconds and then every 3 seconds going forward.
So now we'll spawn a cat bomb prefab at our firepoint every 3 seconds.
Let's save, make sure that that works, and then we can figure out the actual logic for when we want to spawn one and when we want to launch it and how we want to do the launching.
Let's just press play though and see if we start to get some bombs.
Oh, we're definitely not going to because we haven't assigned the cat bomb prefab or the firepoint.
If I go look at the errors, you can see got lots of errors here.
An animation event and a prefab that's missing.
So, let's stop playing.
Go back in.
We'll assign the transform for the firepoint right here.
And then we'll go to the prefabs folder and find our cat bomb and drop that onto the cat bomb prefab.
Now, I'll press play one more time.
We should start to see our objects spawning.
They're just going to spawn, spawn, and spawn and stack up on each other.
At least that's what I expect them to do.
So, here we go.
You can see that we've got a cat bomb there.
You got a bomb kind of spinning around, twirling.
Now, there's three of them.
four of them and they're start now there's four they're starting to add up.
You can see more and more of these cat bombs are appearing on the tail.
So the spawning code is working.
The object is appearing in the right place.
And you can see that it moves and animates with it perfectly and it just now needs to kind of fire away and launch off.
Before we do that though, let's get our cat with our launcher checked in.
So, we've got a cat that launches or spawns and reloads cat bombs.
We'll check it in.
Now, our cat spawns bombs, but he can't launch them, and we need to make them launchable.
To do that, we're going to start with our cat bomb object.
Right now, it's just a visual prefab that shows that model that spins.
Just remember it's got an animator on it and it can spin around in circles.
I can hit play and watch it spin and then it does a a line renderer as well.
So it looks nice and pretty, but it doesn't actually hit things.
So let's start by modifying our cat bomb prefab and adding a couple components to it.
First, I've got my cat bomb selected.
I'm not in prefab edit mode and I'm not using one in the hierarchy.
I'm down here in the scene view.
So my changes for the prefab edit will apply.
So, let's hit add.
And I'm going to choose a rigid body 2D component.
This is going to make it so that my cat bomb can fall down.
Now, I also want to add a collider to it.
But if I just add a collider right now, I'm not going to be able to see it.
So, I'll double click, go into prefab edit mode.
See, my rigid body is already here.
And then I'm going to hit add component.
And we'll add a circle collider.
So, let's type CIR.
And a circle collider appears.
I'm going to expand this out and shrink down the radius just by grabbing it and dragging.
It looks like what was that about a 0 2.
That fits pretty perfectly.
So now I've got a cat bomb that should just spawn and drop down to the ground.
If I go back out of prefab edit mode, save and press play.
My cat now should spawn bombs, but those bombs shouldn't just stay on the tail.
They should kind of act a little bit weird.
Let's watch.
You can see it kind of drop down, but it still wiggles around because they're still attached to the parent object here.
They're still attached to the tail, but they are doing physics.
So, they'll fall and do their own rolling and stuff, but they still snap back around when this object moves, which gives it some very strange behavior.
So, I want my cat bomb to be a little bit more intelligent.
So, we're going to add a catbomb script now that can deal with launching it and also impacting players and whatever other stuff we want to impact.
Let's go into the scripts folder.
We'll rightclick, choose create car script, and let's call this catbomb.
Now that I've got my catbomb script, I'll go apply it to my prefab once it allows me to.
I'll select my prefabs folder, go find my catbomb, and hit add component.
Let's go add component.
Catbomb.
So my catbomb script.
This is going to first, I think, just have a method to kind of launch itself so it can detach from the tail right here.
So let's open up the catbomb script.
And then we'll delete the start and update methods.
We don't need those in there right now.
and then add a public void launch.
We don't need any parameters yet, though we might add some.
And the first thing we want to do is just set our transform parent to be nothing.
So say transform set parent and we're going to set it to null.
So we want to be able to launch a cat bomb and and eventually we're going to want to kind of shoot it off in the correct direction or maybe add a target, but for now we'll just set the parent to null so it stops doing that weird thing.
Now I'm not spawning cat bomb.
So, let's go into our cat and let's take a look at the cat script.
Right now, we're spawning game objects.
We need to change this to spawn cat bombs so that we can call that launch method.
We could of course just inside of our instantiate or somewhere in here maybe do a get component and try to get the cat bomb prefab, but I think it's generally or the cat bomb component I should say, not prefab, but it's generally better to reference the type that we want and reference the component that we want here.
So, I'm going to change the cat bomb prefab to be of type catbomb.
Now, we'll instantiate the correct object.
So, right now, we spawn a cat bomb every 3 seconds.
And let's say that we want to launch it.
Let's say var catbomb equals our instantiate method.
So, we'll get a reference to it.
And then we'll say catbomb.launch.
So, this should spawn our catbomb init right away.
and then drop it to the ground.
Or not right away, but every 3 seconds.
And as soon as it spawns it, it will drop it right to the ground.
Let's go try that out.
First though, we're of course going to need to reassign our cat bomb.
Oh, we don't actually need to reassign it.
I'm surprised it caught that prefab change.
So, normally those get dropped.
If you don't see your cat bomb prefab there, make sure that you go assign it.
It's probably because I've added all of the components without tabbing back in at all and it and just kind of lined up and worked.
But a lot of the time that reference will get dropped because we've changed the type.
Okay, so I've got my cat bomb spawner there.
You can see the bombs are spawning and they're no longer attached.
If I look here, I can see that this is the fire point and the bombs are down here.
So the bombs are spawning.
They're not launching in the correct direction, though.
So let's now make them launch forward and to the left.
So to do that, we're going to go back into our Oh, let's open up our cat script.
See if I can get that open.
Oh, there we go.
And then inside of our cat script, when we call launch, let's tell it just which direction to launch our cat bomb in.
I want to go off to the left and up.
So, I'm going to pass in vector 2.up plus vector 2.
Now, I'm just hard coding this guy to shoot to the left for now, but we can of course use our direction later.
Let's add in the parameter to our launch code.
So, I'm going to hit F12, and we're going to add a new parameter to the launch method, which is a vector 2, and we'll call this direction.
Now, we need to add some force to our rigid body in that direction.
Since we're going to be using this catbomb multiple times, and we're eventually going to pull it and reuse it.
Let's cache our rigid body.
And we'll do that in an awake method.
We'll add an awake and say underscore RB equals get component.
And we don't want a rigid body.
We want the rigid body 2D.
Make sure you get that one.
We'll add a field for the rigid body with alt enter.
Get rid of these extra private keywords here.
And then in the launch method, let's say underscore rb add force, which will add force in a specific direction.
And we'll give it the direction.
And we'll multiply that times some force amount.
We're going to give that another or we're going to turn that into another field.
So hit alt enter, generate a field for it.
We'll make this a float so that we can easily adjust it and give it a default of about 300.
We'll change the private to a serialize field.
And now we've got an adjustable amount of force that we can apply on our cat bomb and launch it in the whatever direction we want.
Let's go back into Unity.
Oh, let's make sure that we've saved our cat file.
So, we need to be passing in that launch parameter.
Do a build.
Make sure the build succeeds, which it looks like it did.
And then we'll go back into Unity.
Make sure that we don't have any errors.
Press play.
And let's see if our cat bomb now launches off and to the left.
So, we've got a cat bomb spawner guy here.
There we go.
So, he does spawn them.
He does launch them off to the left, but as you can tell, it's completely unhooked from our animation.
So, let's stop playing and then let's apply our overrides to the prefab for the cat.
Save our scene.
And I want to go into plastic and say that we've added catbomb script and launching.
And next, we're going to tie that into our actual animation so that it fires at the correct time.
Let's hit check in.
Let's take a look at the animations for our cat again.
If I go back to my cat object and I look at my animations, I've got my idol here, which I can see playing on the cat.
looks kind of cool.
He just wiggles around and then I've got my shoot and I play that and you can see that there's a very specific point where it seems like he should be launching the object.
That's kind of how I expect to get my art from an artist.
Let's take a look at it in slow motion.
If I drag it here, you can see that when I get right about here, yep, that's when the thing's about to launch.
And you can see that up at the top there's an animation event assigned.
So, the animator actually kind of specifically thought that this was the perfect time for this object to launch and added an animation event.
We don't have a script assigned to it, though.
That's up to us to do.
And this is going to be the case anytime that we get something with an animation event or we need to tie into an animation.
It's going to be pretty much always up to the programmer.
Sometimes a designer is going to do a little bit of it, but programmer is going to have to set it all up.
So, we need to tie into this animation event.
And if I hit the drop down here, you see that it says no function selected.
And the reason for that is because if I look where the animator is, there's no script.
So I've got some options.
I could take my cat script and drag it down to this child.
And then if I went over to my shoot and found my animation event and hit my dropdown, I can see, oh, spawn cat bomb is now available.
But I mentioned earlier that I don't really like having scripts down at lower levels.
So, I'm going to take the cat off that base object and move it back up to the cat.
And the reason that I don't like that there is um well, here let's hit apply overrides and just make sure that we've got a single cat script there is that it often hides a lot of logic.
If you open up a project that has a lot of prefabs in it and there's not much at the base level, it's very easy to misunderstand what those objects are, how they work, or have a hard time digging into what it is that they're doing.
If there are lots of scripts that are littered all the way down the hierarchy here, it gets much much more complicated to deal with.
Having all of the scripts at the root level of the object usually makes the most sense and is usually the easiest to deal with.
So, how are we going to get messages though or animation events from this animator to the cat? Well, in that case, what I do is add in a special script.
So, we'll add another script that's sole responsibility is to pass messages up from the animator to our cat or to our other parent objects because notice on our dog, we have the same issue.
Our dog is down here.
Just so that it can receive back an animation event, which I believe was the shoot one.
Yeah, is this animation event right there.
So, let's go add in a setup so that we can do that without having to move our cat script down.
We're going to start by going into our scripts folder.
And I want to create a new script.
And I think I want to call this a um maybe like a fire animation wrapper or shoot animation wrapper.
Let's call it shoot animation wrapper.
Um so that way it's very obvious that it has nothing to do with actual fire.
It's it's about the weapon shooting.
Shoot animation wrapper.
We'll attach that shoot animation wrapper script to our base object here.
Oh, got a nice reload here.
We'll go select the cat though, select the base, and drag the shoot animation wrapper script onto it.
I'm going to open that shoot animation wrapper script.
And as usual, I'm going to delete the start and update methods.
And I'm going to add in two things.
First, an event that's an action.
So, I'll add a public event action.
And I'm going to call this onshoot.
Then I'm going to add a public void shoot.
The shoot method is going to call onshoot.
So I'm going to use onshoot question mark.invoke.
Hit tab and tab again.
So we've got an expression body method.
Since it's a oneliner, we'll use the expression body instead of the parenthesis.
And it's going to invoke the onshoot method if it's registered for.
That's what the question mark's doing there.
avoiding a null reference exception if nothing has registered for on shoot.
I'm going to delete out lines two and lines three and line nine.
And look at how nice and short that got.
So now we need to call into our shoot animation wrapper.
To do that, we'll go back into our cat script and inside of our start, instead of doing an invoke repeating, let's get our shoot animation wrapper.
So I'll say var shoot animation wrapper equals get component.
And I don't want to get a component.
I want to get a component in children of type shoot animation wrapper.
I'll hit tab and make sure that I get that semicolon over there at the end.
Let's zoom out just a tiny bit.
And then on our shoot animation wrapper, we're going to register for our onshoot event.
So I'll do shoot animation wrapper.onshoot plus equals spawn catbomb.
Whoops.
Get the B in there.
remove the semicolon and delete out that invoke repeating.
So now whenever our shoot animation wrapper says it's time to shoot, our spawn catbomb will fire off.
Let's go back into our script or our our project, not our script.
And then let's go hook up that animation event now.
So we'll go to the animation window.
We've got the cat selected.
We'll go to the shoot animation and go find that animation event.
We now have a option here for shoot because that's part of our shoot animation wrapper.
And our cat should now be registering for that and listening so that it can launch off a bomb as soon as it uh as soon as it's ready.
As soon as it gets to that shoot point.
Let's go watch.
Boom.
Look at that.
It's now launching my bombs exactly when I want it to.
Looking pretty good so far, I think.
Let's stop playing.
And now before we go any further, let's have a little challenge.
What I want you to do is take advantage of what we've just written here and see if you can refactor the dog so that our dog script is no longer at the base level and is up at the parent here.
And I say the base level, I mean this base level, not this actual kind of base parent level.
So I want you to make the change so that our dog script can go up to the top.
Go ahead and get that done or continue on in just a second and I'll show you the solution.
All right, I assume that this was pretty easy, but what we're going to do is add that shoot animation wrapper to our dog base object here.
Move the dog script up one level to the dog and then we'll open up our dog script in our code editor.
So, let's see where's our dog script.
There it is.
Inside of our dog script, we'll add in a start method.
And then in the start method, we'll get that fire animation event wrapper.
So we'll say get component in children fire animation.
No, a shoot animation event wrapper.
Shoot animation wrapper.
And then we're going to do an onshoot plus equals shoot.
I'm not even going to cache this component because I'm not going to listen for any other events on here.
Now I can make this shoot method not be public.
So I can remove the public there and remove the public here.
Turn this into an expression body method.
Oh, I guess it's not going to let me.
And then realize that when I'm shooting, I don't even really Oh, that's why I had a little extra character there.
I don't even really need to call this code because it doesn't do anything yet.
But let's leave it in here for now.
Let's save.
go back into our game and make sure that our our dog still at least logs out that he's shooting even though he doesn't do anything when he is doing his his shoot yet.
Oh, and first let's apply our overrides to our prefab.
I'm going to press play, go to the console log, and we'll just watch to make sure that our dog is still calling his shoot stuff as well.
So, go to the scene view.
Yep.
You can see he he logged out shooting.
And every time he goes up and down, that shooting counter is going up and down or up again.
Now that that's working, I want to make sure I've applied my prefabs on my cat and my dog.
Save our scene.
And let's go to plastic and say we added the shoot animation wrapper, which we're going to update in the next section.
Now, we're going to do another challenge.
The challenge here is pretty simple.
What I want you to do is try to reproduce or recreate the behavior that you're seeing right here with the cat.
So, watch when his tail goes back, a new grenade appears or a new bomb appears.
And when his tail gets to the end point, it launches.
So, it's not spawning when it's launching.
Instead, it's spawning when it's resetting and getting ready, just kind of sitting there waiting to launch.
And then when it's ready, it launches off.
And then eventually, a new one spawns out.
Let's watch it in slow motion real quick.
I'm going to zoom in here.
And we're going to go frame by frame.
So, you can watch as it gets down to the bottom, a new one appears.
And if I keep clicking fast enough, you can watch it go forward slowly, slowly, slowly.
Oh, it's still doing a whole idle.
Let's just watch.
There we go.
It got to the end.
Ah, I was too slow.
But you can watch that.
It's empty until it gets down to that point and then reloads.
So, that's the mission.
See if you can figure that out.
If you get stuck, don't worry.
There's quite a bit to it, but it's just reusing a lot of the concepts and things that we've already done.
There's nothing new that you need to do.
Just redo a lot of the stuff that we've done.
See if you can figure that out and then continue on if you get stuck or even if you don't so that you can see my solution and we'll see how how well they align and match up.
Now, to accomplish this task, we're going to do something simple.
We're going to extend out this shoot animation wrapper.
Right now, it does onshoot.
Let's add an on reload, so that we can have an animation event fire off when we want to reload, and then have our cat do the reloading at that time.
So, I'm going to select both of these lines, six and seven, hit control D, hit the left arrow, and enter.
I'm going to rename the second one to on reload.
Rename this method to reload and then copy and paste on reload into there.
So now I've got an onre reload and a reload.
I'm actually going to move my events up and then my methods down so that they're kind of aligned in a way that I think looks a little bit better.
I'm going to double check that on reload calls reload and shoot calls on shoot or reload calls on reload.
Shoot calls on shoot.
Let's go back into our cat now and where we call our registering for the onshoot that spawns a cat bomb.
Let's duplicate and add an on reload.
Now, to me, on reload sounds more like something that should spawn a cat bomb, and onshoot should probably shoot the cat bomb.
So, let's rename this one to shoot catbomb.
Hit alt enter, and generate a method for it.
Got to go down and choose generate method.
Now that I've got a shoot method, I can take this catbomb launching part.
In fact, maybe I should rename this.
Oh, no, let's leave it as shoot.
Um, I'm yeah, I'm going to leave it as that name.
I'm going to take line 27, cut it, and paste it over 21.
But you notice that we don't have a cat bomb here.
This isn't a field variable.
This is just a parameter or a local method variable that was around.
So, let's promote this thing up by removing the var keyword and adding an underscore instead.
We'll hit alt enter and generate a field for it.
And we should end up with a private cat bomb right up here.
I'll hit enter on that private to just clean that up.
I'm actually going to hit shift delete on the start method too to get rid of that extra comment.
Not the start method, but the comment right above it.
Now, in our shoot cat bomb, we'll add the underscore so that our cat bomb can launch.
I'm going to remove this update method down here as well and kind of clear out all this clutter and shrink our file down to the size it actually needs to be.
So, this looks like it should work.
It should spawn our bomb at the right time and then launch our bomb at the right time.
For it to work though, we're going to need to hook up our animation event.
So, let's go back in, find our cat's base object, the one with the animator on it, and find the animation window.
Or just go to window and animation.
Animation right there.
Should pop it right back up.
And then I want to find the shoot animation.
Here you can see we've got our shoot animation event right there at the top.
And I want the reload to happen probably right here at the end.
Either that or right at the beginning.
I'm thinking um right at the end so that he has the grenade on his back like at the end of the shot while he's idling.
It's just kind of sitting there ready.
So to add a new animation event, all we need to do is rightclick on this top part wherever we want the animation event and choose animation event or add animation event.
I'll choose the function that I want, which is reload from our script right there.
And then we'll press play.
I expect to see a couple things.
The grenade should appear there.
It might act a little bit wonky and weird for a second.
Let's see.
And then I also expect to see a little error in my in my logs, but the grenade does launch out.
So, couple things to address here.
First, when our grenades or cat bombs spawn, they fall to the ground.
I don't want that to happen.
And they're spinning already by default.
I don't want that to happen.
And if we look at the console, we have an error here, right when we start because our first time that we call the animation event for our launch or our shoot, which is right here, is before we call the first time for our reload.
So, we end up calling shoot when we don't actually have a a bomb loaded up.
So, let's stop playing and address all of those issues.
We'll start in the cat bomb.
When we first spawn our cat bomb, let's make it so that it's not simulated and that the rigid body doesn't move until it's launched.
To do that in our awake, we can just say underscore RB is simulate or no, it's simulated, not is simulated equals false.
I'll copy that and put it down into my launch method right before the ad force and change the false to true.
That should stop it from dropping instantly.
I also don't want it spinning and doing that animation.
And so I'm going to cache the animator in awake with underscorean animator equals.
Whoops.
Let's hit control-z.
It got the wrong thing.
Equals.
And I don't want to get component.
I want to do a get component in children of type animator.
I'm going to hit home alt enter and generate a field for it.
And then on the next line, we'll say underscorean animator.enabled equals false.
We'll copy line 16.
Paste it down here after 22 onto 23 and enable the animator once we've launched it.
Now, this should work at least once.
We're going to have to do some addressing things when we start pooling this object, though.
But for now, let's remove the private keyword on the animator.
I'm going to move the serialized field up a little bit, rearrange things so that it's nice and clean.
Get rid of these two extra using statements and the extra line at the bottom.
Take a look at our script.
And I think this looks pretty good.
We should now be able to launch and have our object look right.
But we still have that issue of we're spawning or we're firing off a bomb before we've actually spawned one.
We've got a couple options here.
We could either in our shoot cat bomb check to make sure that we have a cat bomb, that it's not null.
But I think that it's better that we just start by in our start method spawning a cat bomb so that we already have one ready to go and load it up and we don't have to worry about it.
Um, shoot catbomb should probably set our cat bomb to be null once it's shot.
And then in our spawn cat bomb, we can just check to make sure that we only spawn a cat bomb if shoot cat bomb or if our cat bomb is null if we don't already have one.
So I'm going to zoom in here and we'll say if underscore catbomb is equal to null.
That way if we accidentally spawn a cat bomb some other way, we're not going to end up with two of the bombs stacked on top of each other.
We'll always have one until we launch it and then we'll get our next one.
We won't keep respawning multiple.
Not that I expect that to happen, but I just like to write it a little bit safer to make sure that in the future we don't have to worry about that.
Let's remove lines one, two, and three here with shift, delete, shift, delete, shift, delete.
And I think we are good.
Oh, let's get rid of these extra private keywords as well.
Shrink this up a little bit.
Save.
And then let's go try it out.
This should be the complete solution that solves all of those problems.
All right, we'll press play.
And there's our first bomb.
You can see it starts spinning and launches out.
Second one starts spinning, launches out, and watch when it reloads.
It reloads when it gets right back to the end.
Exactly as I expected.
All right, I'm going to stop playing.
Make sure that we don't have any changes to our prefab to override.
Go into plastic and say that we fixed catbomb reloading.
and check it in.
Oh, got the error there.
It's okay.
We'll just hit check in one more time.
Oh, I wanted to update our animation.
It's good.
I almost missed the animation file.
Now, we're going to start building out some cinematics.
We're going to do this in preparation for a boss fight and create cinematics that both kick off at the beginning of our level and when something interesting happens.
To start, I'm going to go into level one.
You can use whichever level you want.
If you've already got stuff built in level one that you want to keep, you're welcome to just copy your level and make a new one.
But I'm going to take level one here and expand it out just a little bit.
So I'm going to take this grass here on the right hand side that I've got, duplicate it with controll D.
Controll drag it over and just give myself a little bit more grass.
And then I'm going to add a little area I think on top of this platform.
It's going to be an exit that's keyed off.
I'm going to do that by going into my stone section of the ground.
Grabbing one of these stone center tiles, dropping it right on, putting this at, let's go with a 41 and a three.
Switching the draw mode over to tiled so that I can drag it up or make it taller.
And here I'm just going to hit T, hold control, and drag it up so that it's too tall.
I want to watch that height so it gets just to the correct height.
Duplicate that stone center.
And I'm going to hit W.
Move this one up here.
right to about there so that it's at what is this 41 and 5.5.
Then I'll hit T, drag it down so that it's only one tall and then drag it over to the left and again holding control so it's about oh let's go to five wide.
I want to get it kind of wide here.
Next I want to grab some of those locks or the toggle locks that I've got.
I believe those are in my prefabs folder.
Let's go find my yellow lock.
There it is.
I'll drag it and drop it right out here.
I'm going to put it in a kind of snapped position of looks like about 37 for me and three.
And then I'm going to make this one tiled as well so that I can make it fill up the entire wall.
So as soon as I touch any part of it with a yellow key, I can have it open up.
So let's hit tiled and I'll hit T over here.
Oh, switch over here.
Hit T, control drag and get it right up to the top.
Now I can see my collider here is not the full size.
It's that little green box there.
That's because I haven't checked autotiling yet.
So, I'll hit that.
And now I've got a fullsize collider.
So, I've got my lock here.
I want to add in a key that we can show the player.
I think I'll put the key maybe way over here to the right.
So, I'll take our yellow key and drag it over here.
And now I've got some things to show them.
Well, let's add one more thing.
Let's add an exit as well.
I'm going to go to I believe it's under tiles.
I've got an exit sign.
And I'm going to drop that right in here.
And I might even add a door.
Let's do that.
Let's go find a door.
I'll take a door closed mid.
Drop it right here.
And then I'll take a top piece and make that a child of that door.
I'll zero out the position and set it to zero and a one so that it kind of snaps onto the top.
Get that door nicely positioned at what is this going to be? 40 and three.
And then I'm going to do the same with that exit sign.
Just kind of snap it over to I guess I'll go to 38.5 and three.
So, it's right there.
You can see that it's an exit.
Actually, I think I want to move this door over just a little bit.
I'm gonna hit W, hold control.
There we go.
Think that looks a little bit better.
So, now I've got a scene where I can show my player an exit and a key that's passed there that they're going to have to get.
I do still have this flag here, though.
So, we should probably get rid of that since it's not going to be the actual exit anymore.
Or, you know what? Let's undo that.
I'm going to just move that over here to the left.
So, I've got a cheat way into level two.
And then I'll go add that same load level script and a collider onto the door.
So we can use that as our normal exit.
So we got this load level script.
I'm just going to rightclick and copy it.
I'll click over here to the door.
And then I'm going to choose the little buttons here.
And there's right off to the side.
Let's just drag it over so it's visible.
Go right off to the side.
I'll choose the paste component as new option.
Gives me that load level.
But I do need my collider.
So let's add a box collider 2D as well.
I'll drag this back out.
And now I've got a valid exit, a key, and some stuff to show.
Now I'll just clean up the hierarchy a little bit.
I'm going to take my exit signs, my stone pieces, move them into the environment folder.
I think I've got my yellow keys and locks, and my door.
Want to move these as well along with the springs and the spikes.
So, I'm going to drag all of these into environment.
They're just kind of props that I'm not too worried about.
I want to get them out of the way and kind of invisible.
Take my lock and my key and the door as well.
Drop them all into that environment folder.
Kind of shrink this down.
I don't have a whole lot here.
We'll save.
And then I'm going to go into plastic and say that we've set up our initial level for our cinematic or setup.
I'm going to say set up level one for the cinematic.
intro and we'll check it in.
Now that our level's set up, we're going to do our cinematics.
And the first thing I want to do is show the player the exit.
To do that, we're going to start by creating a virtual camera that's aimed right at the exit.
We'll go to game object, cinem machine, and virtual camera.
I'm going to name this virtual camera exit.
And then I'm going to move it by going into transform move mode.
So, click on it over here, hit W, zoom out, and aim it so that it's right over the exit.
If I pull up my game view down below, I can actually see what it looks like.
If you're not seeing it there, you can hit the solo button to force it.
You may have it as a lower priority.
And if it's a lower priority, and it's not in solo mode, like it is right here, you see that it doesn't show up.
But as soon as I put it into solo mode, it shows up or it forces it to.
Now, I want to adjust the zoom of this.
I want it to be zoomed way in on the exit.
So to do that, I'm going to adjust the ortho size.
So just drag this way down here so that it's zoomed in a whole ton and then drag it up so that I've kind of got this just nice view of just my exit.
It looks like about a 2.5 and I'm going to level off these numbers just because I like to, but you don't necessarily have to.
So I've got my camera lined up right here for the exit shot.
After showing them the exit, I also want to show them the key though.
So I'm going to duplicate the camera, this virtual camera.
Let's rename this one to key instead of exit.
I'll move it over here to be over our camera.
Let's get that game view back up.
And then I'm going to adjust the ortho size.
I want this to be zoomed out a little bit more.
Maybe like a 5.5.
And I drag it up here.
Now, I don't really like that there's a blank spot here.
So, I think I'm just going to grab some more water, duplicate it, and controll drag it over to kind of fill in that area.
And I might add some more grass there.
actually think I'm just going to move this camera over a little bit to the left here.
So, there we go.
I've got a view of that key and I've got my exit set up as a separate camera.
Now, I need to make it so that we can show these things and we're going to use the timeline system to do that.
The first thing that we're going to do is create a new timeline, but we're going to create it in a new folder called cinematics.
I'm going to go to my assets folder, rightclick, choose create, choose folder, and call this cinematics.
I'm going to put all of my timelines in here for showing intros to levels, showing bosses, and anything else I want to show.
I'm going to go into that folder, rightclick, choose create, and about near the bottom, about 2/ird of the way down, there's a timeline option right above signal that we'll talk about later.
I'm going to add a timeline, and I'm going to call this level one intro with spaces in there and capitalization.
Hit enter.
And now it should have created my level one intro timeline.
I'm going to collapse some of this stuff down in my hierarchy real quick and then just drag this level one intro right in.
What that's going to do is create a new game object with a playable director and my playable timeline asset assigned.
Now that I have my timeline, I can start to set up the actions that I want to happen.
I need to make sure that I've got my timeline object or my playable director selected.
And then I'm going to create a new track.
Down here in the bottom left, you can see I've got a add new tracks option.
and I can click it and get a popup.
And I'm going to choose a Cinem Machine track.
I want this to work on my main Cinem Machine camera brain.
So, I'm going to hit search.
And it's this Cinem Machine brain one.
I can click on it and find it.
It's the one under my multiplayer camera setup.
That's the one that I'm using right now.
I think the other one was buried underneath my player object.
Now, now that I've got my Cinem Machine track or my Cinem Machine control, I can take a virtual camera exit or my virtual camera exit and just drop it right out here.
This is going to make it show this virtual camera when the timeline gets to that specific point.
Let's grab the game view and I'm going to drag it up here to be kind of side by side with the scene view.
And then I'm going to just scrub through here.
And notice that as soon as I get it over to this point, right where it hits the line, the camera on the game view completely switches.
When I get past the end, it switches right back.
Now, if I just hit play, you should see that.
Well, let's watch.
Here it goes.
And my camera is kind of stuck on this exit one.
I'm not actually seeing a switch back and forth.
And the reason for that is pretty simple.
Just the priority on these two cameras is higher.
It's set to 13 and the priority on our main camera is set to 10.
So, I'm just going to take these two and we'll just set the priority down to a nice low one.
And now, let's go back to that playable one more time.
Press play and let's watch the camera do the transition.
And we should actually see it automatically switch from one camera to the other when it gets to that point.
And then go right back.
There we go.
That's kind of cool, but it's a little bit fast and I don't really like that it instantly pops.
I want to show them where that camera is and have them get a little bit of a quick view to it.
So, to fix that, I can go select this virtual camera exit line.
And then go to my clip timing.
And there's an easein duration.
I'm going to set that to two, give me two seconds to ease into it.
And then let's scrub over and look at what that does.
You can see that that does a nice quick or nice kind of quick but smooth transition over to there.
I realized I'm in play mode.
So, I'm going to stop playing and then I'm going to add in my other camera target, my virtual camera for the key.
To do that, I'll take the virtual camera key, just drag it right here to the right and then drag it over so that they overlap.
And you can see that if I get it to about this 5 seconds mark, it's going to go for 2 seconds to warm up.
It's going to wait from the 3 second mark to the 5-second mark.
So, another two seconds there where it just kind of hangs out for a minute at that exit.
Then for another second, it's going to transition over to the virtual camera for the key.
I think I want that transition to be a little bit longer, though.
Let's make it like 2 seconds long.
So, drag that line out here.
And then I'm going to give my virtual camera key an ease out duration of oh, 2 seconds as well.
So, that way we show the key and then we show the exit.
I think I want to drag this out to maybe about 11.
There we go.
Give myself a little bit of time there.
Now, let's uh save.
And actually, I'm just going to press play down here in the timeline view.
This will allow me to watch the entire thing without having to go into game view without having to play.
So, I can see what it's going to do.
It's going to show that camera, show that camera, and then go back to the player.
Now, the reason that it's automatically playing and playing instantly is because the play on awake option is checked on our playable director.
So, if I press play right now, I should expect to see that we get the full intro.
There we go.
The exit sign shows, the key shows, and then we're back to our player who can run around and do whatever.
All right, it's looking good so far.
I think it's time to commit and then take a look at what we need to modify, especially around that player.
So, let's go in here and say we've added initial cinematics and check it in.
Now, we're going to look at a problem.
Let's press play and let the cinematic play.
But watch what happens when I'm in my game view and I start trying to run around.
So, my cinematic is playing and you can probably see what's going on with my robot on the left hand side.
Just going along and doing all kinds of stuff, bouncing over here and dying, not staying where I want them to, which is generally what you want to happen during a cinematic.
You don't want the rest of the game kind of going on and things happening.
So, we're going to add a way for our game to semi-pause when a cinematic is playing.
Specifically, we're just going to lock down the player's movement, but we could stop anything that we want.
If we want to control and stop other things, it's very easy to add that on.
Let's go to the level one intro and figure out how we're going to do this.
Right now, we only have access to our virtual camera, but we can access pretty much anything in our scene.
If we try to use our players though and do something directly to the player, we're going to find that we have a problem because we can't access things that aren't in our scene yet.
And our players are instantiated at runtime.
They can die.
They could be recreated.
Things could happen to them.
We can't guarantee that we're going to have a reference to them in in our timeline.
So instead, what we want to do is reference our game manager and tell our game manager that a cinematic is playing or that a cinematic has stopped playing.
And the easiest way to do that is to go down into our timeline.
So, I've got the intro selected, go rightclick, and choose a new signal track.
A signal track is going to allow us to create an object that we can kind of link up on our game manager or any other objects and listen for an event and then fire off some code that we want to run.
I'm I've got my signal receiver field right here.
So, I'm going to take the game manager and just drag it down and then choose create signal receiver on player input and game manager.
It's going to create a new component on there.
If I go over to this object, you'll see that I now have a signal receiver.
I could also just remove this though and just hit add component and just type in signal receiver.
Does exactly the same thing.
It just needs to have one on there.
If I go back to the timeline, you'll see that it removed it because I removed that signal receiver temporarily.
So, it's no longer a valid OB object.
So, I just go red drag it and reassign it.
Now, I want to add a couple of signals.
The first signal is going to be when a cinematic is starting.
I want to make sure that I can stop the player from moving.
So, I'm going to do it first by just right-clicking here and choosing add signal emitter from signal asset.
We don't have a signal asset, so I'm going to choose add signal emitter instead.
That's what I meant to choose.
And then we're going to go over to the right hand side and we're going to hit the create signal option.
That's going to allow us to create a new signal that we can use and listen to for listen for in our game manager.
I'm going to create this in the cinematics folder.
And I'm going to call this cinematic started.
So now we've got a cinematic started emitter that's going to fire off or a cinematic started signal that's going to fire off right about here.
If I go over to my game input manager, you'll see that now I have a signal receiver or reaction listening for the cinematic started event or signal to fire off.
I'm going to add another one.
This time though, I'm going to do it on the opposite side on the game manager side because it does exactly the same thing and I just want to show that you can do it from either side and it doesn't make any difference.
We're going to hit add reaction here.
We're going to choose from the dropdown and instead of choosing none, we'll hit create signal.
This is kind of the way that I prefer to do it.
Anyway, I'm going to go into cinematics and we're going to rename this to cinematic ended.
That should create a new one.
And we've got now an empty list here with nothing firing off.
So now what's going to happen when we run through our timeline? Let's go select our timeline intro.
Right now we're going to fire off a cinematic started and never fire off a cinematic ended.
So let's let's go add that real quick.
Right.
Right about here near the end.
We'll right click, hit add signal emitter from signal asset, and I'm going to choose cinematic ended.
And then we're going to go back over to this game manager.
And in here, what we're going to do is just set a boolean to true or false based on whether or not a cinematic is playing.
And we'll just do that in our game manager.
So, we'll open up our game manager.
We're going to create a new boolean and a new method to set that boolean.
Let's make a public void.
Let's call this um toggle cinematic.
And then we'll put have it give it a boolean parameter.
So cinematic playing.
And then we're going to make this an expression body.
So just do the lambda statement and set a public variable named cinematic playing.
Did I spell it right? Cinematic playing equals the lower score cinematic playing.
I'm going to go over to cinematic play and just leftclick on it, hit alt enter, and generate a property for it.
That should give me a public property that's got a private setter.
And I want to make this static so that I don't have to reference the instance.
I know that there's only ever one of my game manager around.
I don't need to get into that.
So, I'm going to jump back over to our player script now and make sure that when our cinematic is playing, we just don't move our player.
To do that, I'll take all of our code inside of our move our update that's for movement.
So, I guess everything after line 82 and we'll wrap it in an if statement.
We'll say if game manager cinematic playing is equal to false, then we'll run all of this code, which looks like a great spot to extract.
So, we need everything down up to the update animation.
If we are playing a cinematic, we still want to update our animation and the direction.
I think that's probably fine.
I think the final step here is to just take this big chunk of code from line 85 down to 129.
Hit alt enter and extract method and call this update movement.
That's handling all of our movement.
And I think that makes our update method a whole lot more readable and manageable.
And it looks a lot better.
Let's do a build with control shiftB.
It looks like it works.
We'll jump back over to Unity.
Now, our signals are going to need to be set up really quick.
In our signal receiver, we just need to choose for cinematic started.
We're going to use game manager.
And let's see if I can get this onto the screen.
We'll just drag it over here.
We'll go to game manager.
And we want to do toggle cinematic, which is also offscreen.
So, we're going to drag that up as well.
Let's see.
We'll do it just like this.
So, go game manager and toggle cinematic.
And when it starts, we're going to say true.
So, we check that box.
And then when it's ending, we're going to do the same.
Game manager, toggle cinematic, but then leave that unchecked so that it sets it to false.
We'll save.
I'm going to go select that level one intro, hit play, and then let's watch what happens as I now try to run around.
And as my cinematic starts and ends.
So here I try to run.
I'm hitting the arrows going left and right.
Nothing's happening.
And I'm just going to hold this right arrow down until the cinematic ends.
And as soon as it did, you can see my player started running.
You might have noticed one other thing, though.
Let's stop playing and play one more time.
And watch what happens if I just click.
I can still shoot.
So this could also be an issue.
And I'm going to leave this as a quick little challenge.
Go ahead and make the little oneliner code change so that our blaster stops shooting when a cinematic is playing.
I'll leave you to that and then you can continue on.
We'll wrap it up and commit.
All right, I'll assume that you've done it, but if not, the fix for this is going to be relatively simple.
We don't need to over complicate it.
We can just go directly into our blaster, which is still a pretty simple script, and just fires off an object with no reload or no refresh times yet.
And inside of our use, we'll just check to see if our cinematic's playing and just not fire off if if our cinematic is playing.
So, we'll say if game manager cinematic playing is equal to false, then I'll tab in that fire statement and do the fire.
So, we'll only fire if we're not playing a cinematic.
We should probably add a reload time and countdowns and all that stuff, but for now, this should fix our problem.
We jump back in.
We'll do a real quick test before we save and commit.
So, play and then start clicking.
No shots.
No shots.
I'm clicking away.
You may not be able to hear it, but I'm clicking as loud and fast as I possibly can.
And there go the shots firing off right afterwards.
All right, let's stop playing and we'll go back into plastic and it's time to commit here.
I'll say that we added cinematic mode to the game manager using signals and we'll check it in.
Now, we're going to take a look at a couple more things that we can add to a timeline.
Let's go down to the timeline that we have and choose the plus button.
You should see a couple more options.
We've got activation tracks, animation tracks.
We're going to look at those later.
Audio control, playable, and signal tracks.
We've already done a signal track and a cinem machine track.
Now, let's add an activation track.
Let's make it so that our key appears after a moment.
So, we'll show the area and then show our key appear.
And then we'll add some sound effects as well, so we can get kind of a nice little pop when that happens.
I'm going to choose activation track and I'm going to go find my key.
I'm going to go to the environment folder.
I think I'll just take the yellow key, drag it out.
Oops, didn't mean to make it a child of the player.
Let's put it right above the player or right below.
Go back to my timeline, take that yellow key, and drop it on as the game object.
I'm going to go over to the part of the timeline where my key actually shows up.
So, that's Let's just drag the timeline over here.
So, I'm thinking right about here, about halfway after we've gotten there, I'll make the activation appear.
So, I'll grab the beginning of it and just drag it right over to there.
And now my key will appear.
And then at the end, it's actually going to watch if I drag this a little bit shorter.
It's going to disappear.
I don't want my key to disappear, though.
I want it to appear and just stay permanently.
So, I'm going to go over to the left hand side on the track itself.
I'll select it.
Let's just rightclick.
There we go.
And then allows me to get the activation settings up here in the inspector.
Really have to get this thing selected.
but it's just kind of hard to select.
Right clicking usually makes it easier for me.
But once I've got it selected up here, I can go choose the post playback state.
And I want this to stay active.
I'm just going to set it to active right there.
And now once I play past there, it'll actually turn it back on or it'll leave it as active when I actually do the playing.
Now, I also want to add a sound effect to this thing.
So, let's go to the sound effects folder or my projects and my audio folder is not really sound effects.
And I don't think any of these are going to work.
Well, I'm going to take this one from Open Game Art, this epic amulet item.
So, I'm going to download this and pull it into the project.
We'll just choose download right here.
Save it off.
And then I'll take that file and drag it in.
Now that it's imported, I'm going to rename this to key reveal so I know what this sound effect is actually for.
Go back to my timeline and go choose the timeline object itself and then choose the plus and we'll add an audio track.
We need to give it an audio source.
We'll just create one on our level intro object.
So choose create audio source right there.
And then we're going to give it the track.
To do that, we'll right click on the spot where we want it and choose add from audio clip.
This will show us all of our audio clips.
And I'm going to go find my key reveal clip.
And I want this to appear or play a little bit before the thing appears.
So you get a little sound effect.
And then it pops up right after.
So I'm just going to drag this over to the left about maybe about there.
I can figure out the exact position.
And then I want to trim this way down.
I don't need this playing sound the whole time.
Um, once we can start playing or moving around, that seems like a good point to end the audio and cut it off.
I'm going to save now.
Let's press play and see what it does.
And make sure my audio is on in game view.
We get the exit there.
I can see the timeline playing.
There we go.
And the key appeared, but the key Oh, the key disappeared.
and then reappeared afterwards.
The reason for that is that I didn't grab the the active.
I need to drag that out to the end of the timeline so that it stays active the entire time and then goes back to staying active at the end.
So here, let's uh may as well drag that sound effect out as well.
And we'll press play one more time and we're going to watch that happen.
Make sure that our key shows and stays active and and doesn't actually ever become inactive.
So here we go.
There's the view.
You can see the key right here should appear and stays there the whole time.
And we can now run around and get over to the key.
Let's go do that.
Run, run, run, run, run.
And we've got our key.
All right, that looks good.
Let's save everything off.
Make sure our timeline is saved.
go into plastic and say that we added sound effects to the level one intro.
And I also want to check in my other file because I just upgraded my Unity version.
And we'll check that in as well.
Now that we have our key and the lock there blocking the exit before we start adding some real challenges to the way to kind of block us, let's make it so that the key actually works.
Let's go select our key object.
Let's go into play mode here.
Let's see.
Go find my timeline.
Let it play.
And we'll go find that key.
And I'm going to move the key over just by hitting zero here on the X so that my player picks it up.
And I'll just run over here over to the door.
Let's go grab it or go run over to the door.
Again, moving the position of the key to zero.
Just put the door or the key right on top of me is exactly where I wanted it.
So, if I jump up here, come over to the door, I can click on it, and I can turn this thing on and off, but that doesn't let me get through.
So, I want to make it so that I can actually walk through this object.
To do that, we're going to add in something new to the toggle locks.
And I think that this is also another good opportunity for a challenge.
If you're up for it, go ahead and try to figure out an easy way that's reusable that you can fire off some code or do some action whenever the keys are unlocked or whenever the toggle locks are unlocked.
Don't worry about when they're locked.
Just worry about the unlocked state for now.
If you can figure that out and make the keys just dis or not the keys, the locks, that little wall there just disappear, you're good to go.
If not, don't worry.
We're going to go through the solution in just a moment.
All right.
I'll assume that you've gone through it or that you're just ready to do it.
So, what we're going to do is find our toggle lock.
Let's go find the actual object here, this yellow lock, and I'm going to open up my toggle lock script.
We're going to add in a Unity event so that we can do whatever it is we want whenever one of these toggle locks is modified and we don't have to add new code every single time.
So, right up at the top, we're going to add a Unity event.
We'll make it a serialized field of a Unity event and we'll call this on unlocked.
We're going to add in a using statement for that Unity event.
So I'll click on it, hit alt enter, and it's going to add using Unity.events.
Make sure it didn't add a different using statement up above.
And then down below here, we're going to add in a call to this on unlocked whenever we toggle and turn it off.
So, right after we change the sprite renderer, let's just say if unlocked, then we want to call on ununlocked question mark invoke.
That's going to fire off or invoke all of the things that are registered for the onunlocked event in the inspector.
And it the question mark again is going to make sure that it won't give us an error if there's nothing registered.
Without that, if there's nothing there, we could theoretically get an error from the invoke call when there's nothing actually registered for it and listening.
Now, let's go add something so that we don't have to worry about that either way.
We'll go back into Unity and on our toggle lock, we now have the on unlocked field here.
And we can hit plus, just grab our own object.
It doesn't matter which one of these components I drag in.
Just drop any component on.
go over here and choose game object and set active and leave it set to unchecked.
That's going to turn this yellow lock off the second I try to use it.
Let's hit play.
And then again, I'm going to just cheat and move my key over.
It's always important that you uh do lots of cheating in your own game development so that you're not sitting around waiting for stuff.
So, find our yellow key.
There it goes.
It appeared.
We'll hit zero.
Move it over to us.
Run over here.
Jump up.
Trying to avoid those spikes in that frog.
Come over here.
Jump over.
Come over.
Click.
And there we go.
The door is open.
And I can walk through and continue on to level two.
So, let's go into plastic.
Make sure that we've saved our scene so that toggle locks now fire unity events and level one can be passed.
Two S's there.
And check in.
Now, we're going to make a boss.
We're going to use this little bee here, and we're going to hook up a couple of his attacks, set up a whole environment, and make a bit of a challenge for our player.
We're also going to use some cinematics to introduce him.
The first thing we're going to want to do is make sure that you've committed to source control because if you didn't, and you have any kind of mistake here, you're going to end up breaking your player's character controller and really wish that you had source control so that you could go back to it.
So, we're going to take the bee and fish package.
You should be able to download that and drag it into our project.
You see here that it's got a bunch of animations for our bee.
And it also has a bunch for the fish.
It's got some prefabs for some of the special effects, the lightning, the explosion, and some bullet spikes that can fly off of the fish.
But there's also right up here, if I look and find the correct spot, there are all of the character animations.
I want to remove those.
Uncheck those.
And then there's an animator controller that I'm trying to find.
Ah, there it is.
The robot character controller.
If you don't uncheck those, you're going to need to go back and undo your changes.
is you're going to want to go back and revert that so that you don't break and lose your character controller setup.
Let's hit import now.
And now I should see all of my things.
Now again, if you messed up, you made a mistake, you can go to your plastic window, go to change sets, and then scroll to the wind the last change set.
So it' be this toggle locks one.
Right click and hit switch workspace to this change set or revert to change set.
And it'll undo your changes.
Revert will actually undo your pending changes.
Switch to will require you to actually locally undo your pending changes.
So, you probably want to hit revert to and it'll take you back to that past version.
If that gives you any problems, you can always go over here, hit the little gear, and hit launch plastic SCM and then do the same thing in there.
It tends to work when it occasionally fails in here, although most of the time it just works in here as well.
All right, so now we've got our B imported.
Let's go find them.
If we go to the prefabs folder, you should see that there's already a B prefab object set up and made.
I can grab it and drag it right into my scene and put it right around near the key.
And by the way, when I said this was set up and made, this is the way it came from the artist.
It's already set up.
It's just with the animations on it.
We're going to flip the rotation now so that it's facing the correct direction.
I want it to face towards my player.
So, just go find the rotation and set that to 180.
And I'm going to rename this object to B root because I'm going to need to be able to move this piece around and reference a whole bunch of different parts of this B object.
Now, I don't want my B to be there initially.
I want my B to appear when my player gets close.
So, I'm thinking my player comes over here, they think it's all clear.
It's nice and easy.
Run to the key.
They get right here and all of a sudden a B pops up and appears and kind of blocks their path.
So, what we're going to need to do is add in some sort of a trigger to kind of activate and start this whole sequence off.
Before we do that, though, I want to set this up as a full encounter.
It's going to be a bunch of different pieces that are all tied together, and I want to group them together so that it's easy to tell that they're related and to work with them in the future.
So, to do that, I'm going to rightclick and just create an empty game object.
We'll call this B encounter.
and we'll reset the transform so that we've got it all zeroed out.
I'm going to take my Broo root object and just make it a child of that B encounter.
And then I'm going to rightclick and hit create empty.
And let's create a B trigger.
I'm going to add a box collider 2D to it and check the is trigger box.
Now what I want to happen is when I enter this trigger, my cinematics will kick off and the whole B encounter thing starts and the fight kind of begins.
This is like a the boss battle begins.
Camera maybe changes.
Maybe my controls change.
I don't know.
Whatever things I want to fire off, they're going to fire off from this B trigger happening.
So, when we enter this trigger, we're going to want to do one or more things.
And I don't really know what those things are going to necessarily be.
So, I'll create a more generic script that uses Unity events that we can hook up to whatever different things we decide we need.
So, we'll go into the scripts folder.
And let's just minimize this down.
And I'm going to create an event trigger script.
So let's create a right click create a new C script.
Call this event trigger or let's call this um do you want to call it event trigger or trigger event? H I'm going to call it event trigger.
That makes more sense.
It's the trigger for my events.
I'm going to go add this to the B trigger object soon as it allows me to select it.
There we go.
We'll take our event trigger, drag it on there, and I'll open up that script.
Now, we're going to want to listen to an on trigger enter 2D because we want to find out when the player comes in.
These event triggers are only going to listen for the player.
So, add on trigger enter 2D.
And we'll first check to see if the thing that's touching us is a player.
So, we'll just check the tag.
We'll say if not collision.compare tag and then we'll check against player.
then we'll return.
Otherwise, we'll fire off our untriggered event.
So, let's let's actually go up to the top and add a serialized field.
There we go.
A serialized field.
The autocomplete and everything popped up right over me.
And the serialized field is going to be of type Unity event.
And I'll hit escape, alt enter, and add that using statement for Unity engine.vents.
Let's call this onevent triggered.
Now I'm gonna call that down below.
So I'll just double click, copy it and controlV to paste and question mark invoke it below.
So now whenever we enter the trigger with a player, we'll invoke this onevent triggered.
Now that's good, but I only want this to happen once.
So let's add in a check to see whether or not it's already been triggered.
I'll add that down below.
say if triggered then return as well and then we'll say otherwise we'll say triggered equals true.
So that way it'll only get called once we don't have a triggered variable.
So I'll hit home alt enter and generate a field for it.
I'm going to double click that private, hit enter there and add in a little bit of spacing.
I want to remove these two extra using statements at the top and that extra little line at the bottom.
Save it off.
And I think this looks pretty good.
We could combine these statements, but I think that leaving them separate is a little bit easier to read in the file small enough that it's not going to make a difference.
So, now we've got our event trigger.
Let's go back into Unity now and use it to toggle some things.
Let's start by just turning on a camera that shows our bee in the player fight.
First, I've got my B.
I've made sure to move him up here.
If you didn't move your B already, just get him out of the way.
But, I'm going to rightclick and create a new Cinem Machine virtual camera.
I'm going to call this virtual camera B and make it a child of the B encounter.
I'll make sure that I'm in move mode and drag it around.
I want to drag this ortho size down to something like a seven though, so that I can see this whole area, but not too much more.
I think um right about to there is probably pretty good.
Now I'm going to go to my B trigger and in our new onevent trigger that we have available, I will hit the plus option and drag our virtual camera B in.
Choose game object and set active and just set it to true.
That means that by default I'm probably going to want to have this B camera off.
But I do want to make sure that the priority is higher than my normal camera.
So I'm going to crank it up to 100 and then turn it off.
Now I'm going to go back to this B trigger and let's take a look at it.
I'm going to hit F and go zoom in.
And look, we've got this little tiny box here.
You can kind of see the green there.
That's not the collider that I want.
I want to have a collider over here that my players touch.
And as soon as they touch it, the encounter kind of starts.
So, I'm going to drag it over here.
I kind of see it there underneath the ground.
And then I'm going to adjust the collider size.
I'm going to take the X, I'll just make it like a 20.
And I'll make the Y about a 20 as well.
Put this over this entire area.
So, if the player gets anywhere over here, it's going to trigger it instantly.
Now, I've got that set up, I think, correctly.
So, I'm going to save and I'm going to press play.
We'll run over there and I'm going to see if the camera switches once I get into that position.
Again, I turned my level one intro off so we don't have to watch that pop up or watch watch the entire intro every time.
Here we go.
Run over.
See if I can dodge the frog.
There we go.
Once I get into this area, yep, the camera has switched and we're ready for the bee to fly in.
So, let's save.
And I think we've gone quite a few changes in.
Let's go save off what we've got.
So, we've added the B to the level and an event trigger to start the encounter.
And we'll check that in.
Now that we've got our bee showing up in the camera appearing, let's trigger some cinematics so that our bee can do a cool flyin.
Let's add a bee cinematics underneath the bee encounter.
I'm going to rightclick, choose create empty, and call this B cinematic.
I'm going to add a playable director.
And then we're going to need a playable asset.
So I'll go into my cinematics folder, rightclick, choose create, and we're going to create another timeline.
We'll call this B intro.
And then we'll drag it onto that B cinematic.
There we go.
Now, we're going to double click and open it up.
And what I want to do first is make our bee fly in.
Let's double click on the bee.
I want to make him fly in from up here and do a little loop and kind of present himself all while he's doing his animations.
So, I'm going to go to the B cinematic that's got my playable director and I'm going to create a new track.
We're going to use an animation track and we're going to take this B root object and use that as the thing that we're animating.
If we look at the B root, you see that it doesn't have an animator on it, but the child down here, the base object is the one that has the animator that's doing all of the animation stuff.
And we're going to dive deeper into that in a moment.
But for now, we're going to go back and go to our B cinematic and we're going to take the B-root and drag it onto that animator track.
And it's going to want to add a new animator to the Broot.
So, we're going to hit create animator on Broot and then hit record.
Now, we can select this B-root object.
Notice that it now has an animator.
We can hit W to go into move mode and start adding some key frames.
So, right now at zero, it's going to be way up here.
I'm going to go to the 2C mark and drag it down to here so that it's going to fly way down there.
And then at the 2 point or maybe the 3 second mark, I'll have it go down a little bit more and forward.
Then at 4 seconds, I'll have it kind of come up.
And at five, let's make it go up a little bit more and backwards.
And six, we'll go back that way.
Seven, I'm going to come back down here.
And you can see what I'm doing.
Just kind of dragging it into a circle.
Go forward a second and kind of loop it around.
And I think that's kind of a good circle.
I'll stop recording now.
And if I press play, I can watch my bee do his animation and see him kind of go through that that entire thing.
But I just realized I don't have a key frame at the beginning where he's off screen.
So I'm going to hit record again.
We'll go select that B route one more time.
Actually, it was already selected.
And I'll just drag him up here.
So now let's stop recording and play one more time.
And we should see him do kind of that full fly in loop around kind of loop loop loop and then drop down and pop back up into that position.
So it seems like a decent enough animation.
You're welcome to adjust yours as much as you want.
Just remember the wings are going to be flapping in just a moment.
Right now they're not.
So we'll go now to our B trigger and we're going to add another event or another event registration on the event trigger happening.
So I hit plus and it added a copy of the existing one.
Instead I'm going to take the B cinematic, drag that in as the target, find its playable director and choose play.
Now I need to also go to my B cinematic and make sure that play on Awake is not checked so that that doesn't play automatically and we'll save.
And now just to save some time and speed things up, I'll go to my player, hit F.
Let's zoom in and let's zoom out a little bit.
Now I'm going to hit W and move him over so he's right near the water.
and then save so that I can just jump right over the water, make sure the cinematic works, and not have to run quite as far.
So, we're going to be testing this quite a bit.
So, we run over here.
View changes.
The bee flies in.
He does a taunting little scary loop and ends in his correct position.
I can still shoot through them.
We haven't really set them all up, but his cinematic is happening and it's doing what I expect it to do.
Now, I think the last thing I want to do is find some sound effect of some bees and have that kick off and start playing.
Open game art.
Looks like it's got a couple of options.
I'll take this single B sound and I'm going to download it.
We'll open that zip up.
And then we've got this one B.wave.
Let's just drag it into the project.
So, you can go find whatever B sound you want.
I'm going to take this one and drop it right into my audio folder.
Copy.
We'll right click, hit show in explorer.
And then now that we're in the explorer folder, paste.
And now it'll appear.
There we go.
Got the B file.
The reason for that was that it was inside of a zip.
So I think let's see.
How do I want to add our B sound effect? Let's do it inside of our cinematic.
Let's just play the B sound when the cinematic kicks off.
So to do that, we'll go into the timeline.
We'll go add a new audio track.
And here again, we're going to need an audio source.
So I'll add the B encounter itself as the source.
And then that's going to add an audio source to the B encounter.
And then right here, we'll add a new clip.
And it's going to be our B clip.
I think I'll just let it play.
Let's just let it play here and loop.
So, to make it loop, we'll just check the loop box and then drag it out.
You can see that it'll loop all the way to the end.
And I'm going to save and press play.
Now we should be able to run over there, see our bee do his animation, and hear a little bit of a a taunting B sound for a second.
All right, I'm going to stop playing.
I don't want him buzzing anymore.
We'll go back into plastic and make sure that we've saved everything.
So, we've added the B intro and we'll check that in.
Now, let's take our bee and make him actually fight.
Let's turn this into a real encounter.
So, there are a couple of things that I want to do.
I want to have some platforms that the player can jump on to try to shoot at the bee and blast, but I want also have the bee shoot lightning back at them.
I also want to have the bee do a straightforward bolt shot that just kind of fires off and hits the player if they happen to be standing in front of them.
We have a couple different visual effects and I want to try to use them all.
So, let's start by adding some platforms so we can get a feel for it.
And then we'll add some powerful lightning effects that can kill the player to those as well.
We'll first take this.
Let's go with the um I've got a grass platform 2 here.
I'm just going to duplicate that and drag it over here to I think right about the same height.
So, I'm going to go with a 50 and a two here.
I'm going to take this and make it underneath my B encounter since it's going to be part of this B encounter.
And I'm going to call this a B platform instead of a grass platform.
Now, I want to modify this platform.
But first, I want to get a couple of them in position and figure out how I want them to be placed.
So, I'm going to duplicate this.
Drag it over here like that, I think.
Then, duplicate.
Drag over a bit more.
I want to go with kind of even numbers.
What was that? 60.
And what was the other one at? 50.
Let's go with 55.
So, we'll go over by five each time.
And um I think three is probably good.
I want to then duplicate those and then drag them down a bit and kind of off center.
So, they're like maybe like that or like that.
I'm thinking maybe more like that.
I'm not sure on the exact positions.
I might want to raise or lower them a little bit, but I think that that's pretty close to where I'd like them to be.
So, we've got some platforms that our player can now jump on and bounce around.
Let's just hit play.
Make sure that those are in a good position.
So, I come over here.
I can go up on these platforms.
Yep.
I can kind of like shoot, blast, go up and around.
Hopefully that bee doesn't touch me.
Go.
Hey, get back, Mr.
Bee.
Um, I'm thinking maybe the bee might even need to end up a little bit further to the right here.
So yeah, let's let's make a couple minor adjustments here.
To do that, we'll just take our B cinematic here.
I'm going to go to the timeline and we'll go find our let's go select that B cinematic.
We'll go find the B animation right here.
Hit the record button and right here at the end, go to that end part, I'm going to just move him so that he's over to the right a little bit.
So we'll go W.
We're going to have him end kind of over there.
Just going to go right around here.
do a loop and then go flying right back.
Let's zoom that in just a little bit.
Broo root W.
There we go.
I I had my my key frame out just a little too far.
I think we're good there.
Let's see.
Just going to go down and then back up.
Okay, cool.
That's in a slightly better ending position.
And I've got these platforms kind of where I want them.
So now I want Oh, let's stop recording.
I want these things to be deadly.
I want them to have a little lightning bolt that can pop up and kill the player.
We've got a lightning bolt visual effect inside of the prefabs folder that came with the B.
So I'm going to go find that.
Go find our lightning.
And I'm going to drag it down to be a child of this B platform.
Look that I've got this big giant lightning here.
If I go to my game view, well, I can't see it in there, but if I go down here, I could play it.
We'll play it in a moment.
Actually, let's first though make sure that it appears on top of our platform.
I don't like how it's showing right behind our platform.
So, we're going to expand it out.
Go find the two sprite renderers that are children of this lightning.
The one and the shadow.
See, these are two sprite renderers we've got.
And we're going to change their sorting layer.
I'm going to hit sorting layer and hit add sorting layer.
We'll hit plus.
And we're going to add effects.
We're going to have effects show up on top of everything else.
So they're kind of like right there in your face.
I think that's the way that they should be.
We go select one and shadow.
Change that sorting layer over to effects.
And there we go.
It's now on top.
I'm also going to move this lightning object up.
I'm going to select it, hold control, and drag it up to right about there.
Now, I'm not sure if I want to keep that size or shrink it down.
I think for now though, I'm going to leave it nice and big.
And then we'll press play.
Let's just run over there and watch it and see it in action for a second.
It's always cool to go check out your actual particle effects.
You can see it's got this lightning.
Okay, my position is actually off.
I do need to lower it back down.
So, let's put that back down to a zero.
No, that's too high.
Let's go to a 0.5.
I think that might be just about right.
There we go.
Looks like it's kind of landing at the right spot.
Let's go with maybe a point 4.
Yeah, that's even better.
So, I'm going to adjust it to a point 4.
I need to stop playing though and then go back in not in play mode and change it to the point 4.
Now I've got this B platform and I don't want to modify the prefab here because if I do I'm going to change all of the platforms including this one over here that's not supposed to be a BP specific one.
So instead we're going to create a new prefab variant.
I'm going to hit select and then that's going to give me my prefabs folder.
And I've got quite a few prefabs in here.
So, I think it's probably time to create a folder for platforms.
I'll create a subfolder and call this platforms.
And I'm just going to take all of the platform objects that we have and I'll move them into there real quick.
And then we'll create our prefab variant after that once we've got these just kind of moved out of the way and a little bit cleaned up.
It's always good to start creating folders once you get too many things.
And I feel like this is probably just about too many.
So, we've got our moving platform.
Moving platform.
Yep.
There we go.
Take all of those and I'm going to drag them up into platforms.
All right.
So, now we've got our platforms folder.
I'm going to take this B platform, drag it down, and make it be a prefab variant.
I've got a B platform variant.
Um, I don't know if I like the name variant in there, so I'm just going to select it and remove the word variant.
I'm going to select all of my other B platforms now.
One through five here.
Right click and find that prefab option.
Choose replace.
And then now I can find my B platform.
And I've got a bunch of B platforms.
I can save, play, and I should see the lightning just appearing at all of them.
And we're just about ready to start taking control of them.
Let's go over here.
Here we go.
Lightning is appearing everywhere.
I'm sure you can imagine that's pretty dangerous and deadly.
That be sorting is terrible, but that looks pretty scary.
So, let's find finish up by fixing the B sorting layer and then we'll start writing code in a moment.
Let's go to the B, find the B route, expand them out, and actually, let's just open up the prefab for it.
I'm going to hit the arrow there and we'll find all of the sprite renderers.
So, up here, we're going to do T equals sprite renderer.
And then that should just select only sprite renderers.
I'll find all of the objects.
We're going to do that equals.
It used to be a colon, but they changed it to an equals.
And now that we've got all the sprite renderers selected, we're going to change the sorting layer.
Instead of it being on default, we'll change it to enemies.
Go back, hit save, and now I want to play one more time.
Just watch that cinematic.
And then we'll save and and commit our changes.
Let's just jump over here though, and make sure that the bee looks good, the effects look good, be showing up in front of stuff.
We can see the transparency in his wings.
I think he's going to look pretty awesome once he's animating and controlling these attacks.
All right, we'll stop playing.
We'll go into plastic and we'll say that we've added B platforms with lightning visuals and check in.
To make this B fight into an interesting encounter, I want to give him a couple of different abilities.
The first is going to be this lightning shock that fires these little sparks.
And you can see it's on our platforms that we've already created and also on the ground.
Now, the way that it works is through a script that allows me to completely adjust and modify this.
If you take a look at my being counter script, you see I've got all kinds of lightning elements here and a bunch of different settings that allow me to change the way that this works.
I can adjust the number of simultaneous strikes.
I can adjust the delay between the strikes.
And I can adjust how long before the player takes damage.
And of course, I could move these lightning areas all around if I wanted to.
So, here is what we're aiming for, and now we're going to go through the process of creating it.
So, here's where we left off.
We've got our platforms with the lightning auto playing, and our bee has gone back to his home position.
We need to set up the script now that's going to control these lightning blasts, make the player take damage, and maybe add a couple more lightning strikes down on the ground.
So, to start, we're going to create a new script.
We're going to go into the scripts folder.
I'm going to shrink this down with control and the mouse wheel.
Right click, hit create, choose C# script, and we're going to call this B encounter.
Again, no spaces, but a capital B and a capital E.
We're going to select our B encounter object.
This is the parent again, not the one that actually has the B on it.
So, if I go to my B encounter, remember it's at 0 0.
And then underneath it, there's a child of a B visual that um the B root object right here that I can turn on and off.
I'm going to go to the B encounter that parent.
I'm going to minimize the audio.
source and I'm going to add a B encounter script to it.
Then we're going to open that script up and talk about the code.
Here's our B encounter script.
And before we get started, I want to mention that when it comes to creating a scripted encounter, there are definitely a couple of different options.
We can write out some code.
We can build some datadriven solution or we can do some sort of visual scripting option as well.
They're all somewhat valid options, but typically in most games, what I recommend to start with is a simple scripted setup.
You don't really want to start abstracting and building up state machines and script stuff until you have a good idea of what it is you're going to be building, how much of it you're going to be building, and who's going to be building it.
When you get to the point where you've got other people that are game designers that have no programming skills working on stuff, you want to start to look at some other options.
And as things grow and get bigger, you do.
But when you're just trying to build out a nice tight, good encounter, it's drastically faster, easier, and a lot easier to just get done quickly.
Well, not just quickly, but quickly and the exact way that you want if you write it in code.
So, that's how we're going to do this.
And we're going to start by just removing the start and update methods completely and adding an on enable.
That way, we can toggle this object on and off.
And inside of this on enable, we'll kick off a co- routine that runs our encounter.
So here we're going to add a start co- routine.
And we're going to call this co- routine start encounter.
I'll add my parenthesis, generate a method with it.
Alt enter.
And then we'll change the return type to not be string, but an enumerator, which is the one thing that Visual Studio constantly gets wrong.
It always wants to put a string there, but it should be an I enumerator.
I'm going to remove my private keywords and then let's talk about what our start encounter method should do.
The first thing I want it to do really is disable all of the lightning.
I want to turn all of that lightning off and then randomly pick some lightning and just turn one of them on.
And I think I'll start with that and then expand from there because the next thing I wanted to do is pick multiple and have them all turn on, you know, in an order and do more of the actions like we described.
So let's start by just turning off all the lightnings.
To do that, we'll say underscore lightning or let's add a for loop instead.
Delete that for each var lightning in underscore lightnings.
And then we'll say lightning not underscore lightning lightning.
Oobject set active to false.
Now, we don't have a lightning array here, but I'm thinking that for our lightnings, we're either going to want to reference the transform, the animator, or the game object.
I'm not sure which one yet.
So, let's just start with the transform.
I'm going to copy lightnings.
Actually, let's just hit alt enter and generate a field for it.
And we're going to change this.
Instead of being an I innumerable of object, we'll make it a list of transforms.
Transform.
We got to get rid of that s.
We'll make it a serialized field so it shows up in the inspector.
And then we'll have to do something after our start encounter.
So this right now should loop through all of our lightnings, set them to inactive.
And then let's do a yield return null and save.
We'll go into Unity.
Let's assign our lightnings real quick.
Make sure that this turns them off when we enable it.
it.
it.
And then we'll finish up the code after that.
So we'll go expand out our lightning objects.
And I don't want to grab my B platforms because I don't want these things turning off.
I want the lightning objects underneath it.
So, I'm going to go back to my B encounter.
I'm going to lock the inspector so that it stays on the B encounter.
Then, I'll go expand out all of these B platforms.
I'm going to go to the bottom one, hit right arrow up, right arrow up, right arrow up, right arrow up, and then go find all of the lightning objects.
I'm going to hold control and click on all of them.
There should be six of them so far.
And with all of them selected, I'll drag them right into lightnings.
Now, if you missed one, you messed one up, um, you can always just say it's that one right there.
If I remove that one from the list.
Did I remove it? There we go.
Hit the minus key.
Then I can always just click that single one that I missed and drag it in or clear it out.
Just make sure that you've got all of your lightning objects there.
I'm going to press play.
And when this enables, it should just turn those off.
If that's good, then we're good.
So, there we go.
It looks like it turned off all of the lightning objects.
Let's stop playing and jump back into code.
Now to turn a random lightning object on, we're just going to at first choose one at random and flip it on.
Now to choose one at random, we just pick a random number between zero and the number of lightning objects inside of our lightning list.
So to do that, I'll say var or let's just call it out as an int.
int is the same length as var.
And I'll call this int index equals and we'll use random.range.
And here it's not going to autocomplete because it's finding system.random, random, not Unity Engine.Random.
And that's because I have a using system statement up there, which is because something in here is using Oh, I think it's the serialized field attribute.
Let's see.
Let's remove the using system statement.
And you can see that now, oh, now we're good.
I guess I wasn't using the system statement.
So, we can do random.range from zero up to lightning's.
Now, if we do need to have the using system statement up there, by the way, we can also just add Unity engine right to the front of random.
So we can use the Unity random generator, not the Microsoft.NET system random generator, which is a slightly different random generator that requires you to instantiate it and deal with the seed.
It's a little bit more work than the Unity engine one.
So I I prefer to use that.
So now we've got a random index.
We'll turn on the object at that index.
So I'll say underscore lightnings at index.
There we go.
Oobject set true.
It already knew exactly what I wanted to do.
And then if we want this to just repeat, we'll just wait.
So we'll say yield return new wait for seconds.
And here we'll add in our delay between lightnings.
Let's make that a variable.
And then finally, we'll just turn this into a loop.
Let's actually first before we do the final part, generate a field for the delay.
Turn it into a serialized field and then give it a default value of I'm going to go with one.
So now we've got our code.
We just need to make this into a loop.
So I'll say for each or not for each while true and we'll add braces around it so that all of the code inside of the braces will run permanently or indefinitely.
It's going to run forever as long as this co- routine is running.
And it's just going to loop over, loop over, keep despawning them all and then spawning the next one.
It's going to actually despawn it a little bit early though.
It's going to spawn, despawn it before the lightning finishes striking.
Let's go check that out.
Make sure that it's doing what we expect.
There we go.
Go over to the lightning.
We can watch it.
You can see the lightnings appearing and then quickly disappearing.
The reason for that is that the delay between lightnings is two or is one right now, but the animation takes 2.5 seconds.
So, I change this up to about a 2.5.
I'll pretty much get a consistent non-stop lightning strike applying at one of these positions.
So, we're partway there.
We've got a somewhat interesting setup.
I think the last thing I want to do is change this to a 2.5 and save my scene.
And then I'm going to commit this and we'll talk about how we can make it a little bit more complicated.
Say added basic lightning control to the B encounter.
And let's check that in.
Our lightning visuals are working.
We've got one strike appearing, but now I want to make sure that it damages our player before we start to add a bunch of other strikes.
Let's make sure that it's fully functional.
So, inside of our start encounter method, we've got a loop that essentially spawns one piece of lightning or spawns a lightning strike and then it waits until whatever time we've got here.
And you saw that our timer kind of has to match our animation time for this to all work.
If we take a look at our animation, I can go into Unity, go find our lightning object, and go expand it out.
There's that base subobject.
I need to make sure I unlock my inspector.
Go take a look at my lightning strike.
Or even better yet, if I go to the base and go to the animation window, not animator, I can look at my lightning strike animation and I can see it actually play out.
I can drag the timeline across and see that it actually is supposed to strike or do damage right here at 1 and a half minutes.
That's what the 130 is.
30 is half of a minute.
So that's the halfway mark.
So it's supposed to stop, go to 1:30, and then it's basically all the way gone before the 2C mark.
It looks like there's some key frame out here at the end at 2:30.
I don't know why it's quite so long, but it looks like it actually ends at just about less than 2 seconds.
So I'm going to modify our code just a little bit to take advantage of that.
And we've got a couple options when we do this.
By the way, there's already an animation event that our animator has put into here.
I'm actually going to delete that out because I don't want to have to tie in an animation event and have my designers have to come in here and modify and move the animation event when I know it's at 150.
And if I want to change it later, I'd rather just have a slider in there for all of my B encounter settings that I can modify this setting on.
Now, using animation event can be good if you have lots of animations, you want to tie them all in and your animators and designers are good at using it that way, but I find that for this situation, putting it in my B encounter is going to make more sense.
So, I'm going to open up my B encounter script, and we're going to add in a couple new fields.
We've got a delay between lightning, which is right now kind of doing its job, but not really.
I want to add an animation length and a delay to damage.
So, I'm going to just duplicate the line twice with control D like I just did.
And I'll put delay before damage.
And then a um let's call this lightning animation time.
So, the full time of the animation, that's going to be two.
And the delay before damage is going to be 1.5.
I already know the values.
I want to be able to modify them, but since I know them, makes sense to put in an actual accurate value.
Now, inside of my loop here, inside of this while loop, instead of waiting for the delay between lightning, we'll wait for the delay before damage.
And then we'll damage players in range.
And we want to do players in range of our selected lightning object.
So to get that, I'll just copy part of line 28 up to the end of the index and paste it.
And that's going to give us a reference to the transform at that index in the list and pass in that transform.
So I add the semicolon home and alt enter to generate a method which should give me a private method that takes in a transform because that's what we're passing in.
I get rid of that private keyword.
Then after we damage players and range, which we'll write the code for in a moment, we want to wait a little bit longer.
We want to wait until the animation is done.
So let's copy line 30 and paste it down here on line 32.
And we don't want to wait for the entire animation time.
Right? If we go up here, if I just did it for this lightning animation time, then we would wait for 1.5 seconds damage players, then wait for another 2.5 seconds.
Now, I could change this to be maybe a.5 so that it's um the delay after damage, but I feel like having it just be the full lightning animation time is easier to understand.
So, I'm going to copy that and we'll just do a little bit of math.
We'll paste in lightning animation time minus delay before damage.
As long as these values are correct, so that this number is always greater than this number, we should be pretty good.
We shouldn't run into any problems.
Now, we can make sure that that's the case by adding an onvalidate.
So, we'll go up to the top and add one quick on validate and just say if the lightning animation time, so I'm going to copy that, is less than or equal to the delay before damage, then the lightning animation time is equal to the delay before damage.
so that our lightning animation time will always get just kind of cranked up if we accidentally mess with this delay before damage.
In fact, probably should adjust this.
Let's do that.
Let's change it so that our delay before damage has to always be less than our animation time.
So, here we'll just say that our delay before damage is equal to the lightning animation time.
I'll just adjust swap the order of those so that we keep the lightning animation time the same.
I think that makes more sense.
All right.
So, now we've got a loop here.
We just need our final wait.
So, we're waiting for that amount of time.
The last thing is to wait for our delay between lightning.
So, I'll copy delay between lightning.
Duplicate line 38 and paste it right in here.
So, we'll wait till the end of the shot and then play again when the next one is ready or play again once our delay is done.
Now, the last thing we need to do is damage our players.
So, here we've got our damage players in range method.
And the easiest way or I think one of the best ways to find all of the things in range of a specific place is to use the overlap circle method.
So we're going to say var hits or let's call this out again int hits equals physics 2d physics 2D dot and then there's an overlap circle.
Find this overlap circle method.
You can see that this will actually return back a number or the first object that overlaps.
That's not what we want.
There's a overlap circle all that will return back all of the objects that are within a circle radius of a specific position.
That's close to what we want.
But there's actually one method that a lot of people don't use.
And I generally recommend you use instead of overlap circle all.
If you're using any of the overlap alls, you should consider or at least look at using the overlap circle nonalloque or the nonalloque versions of any of them.
In fact, I would say you should consider you should almost always use them, especially if you're using it in something that's commonly called.
And that's because it won't create a new array of things to save off the hits into.
Instead, it will you'll use a a preset array or preset collection and you'll just be filling those up.
It saves you on garbage collection and saves you essentially saves you from allocating memory and causing performance issues.
So, we're going to use overlap circle nonalloc and we're going to give it the first parameter which is the point which is that transform right there.
And I'm going to rename this transform to be lightning because I want to make sure that it's not confused with my own local mono behavior transform.
So, I've got this lightning object.
I'm going to paste in lightning.position as the first parameter.
That was our position.
Next, we need a radius.
For that I want a ver a parameter variable and I'll call it lightning lightning radius.
This is that damage radius for it.
And then we need a set of results or an array of colliders.
You can see right here it's showing my collider 2D.
So here I'm just going to use underscore player hit results.
This doesn't exist just like our lightning radius doesn't exist.
And then finally, I'm going to add in a layer mask so that we only look at players and we don't look at anything else.
So I'll call this underscore player layer.
I'll add in a semicolon at the end.
And then I think I'll split these parameters out into new lines just so that it's easier to read.
So you can see I've got my hits call.
We pass in the position.
We pass in the radius, the hit results, and the player layer.
Let's create the radius first with alt enter.
We'll generate a field for it.
Hit F12 and change this to be a serializ field and give it a default of about one.
1 meter away is probably good, but we can always adjust this.
Now we'll go down.
We'll add the player hit results.
I'll hit alt enter.
Generate a field for that.
F12.
And you see we got a private array of collider 2Ds named player hit results.
I'm going to remove the private keyword and add a little bit of spacing here so that it just looks a little bit cleaner.
We got a little separation between our serialized fields and our regular private fields.
The last thing I want to do is add our player layer.
I'll hit alt enter.
Generate a field for that.
F12.
And this one I do want to be a serialized field for now.
So I'm actually going to cut it.
Move it up here.
Add a new line.
Copy the serialized field.
Paste it over the private.
And then we're going to change this from an int to a layer mask, which actually inherits from int.
So it's able to work just fine.
So we can use our layer mask.
Let's go click on it real quick.
Doesn't does not inherit from int.
I lied.
But it has a value from int and and it will work in here.
So, let's go down and um take a look at our code.
We should have no more errors.
Last thing we need to do is damage all of the players that we found.
So, we'll do a for loop and we're going to loop through the number of hits that we got because overlap circle nonalloc is returning back the number of things that it put into this player hit results.
Once we loop through it, we'll just access the player hit result at that index, which is right now is actually going to be null.
Let's take a look at this in a moment.
It's going to give us an error, but we'll access that.
We'll get its player component.
So, we'll say get component player.
Let's capitalize that G.
And then we'll tell it to take damage.
And for now, we're just not going to give it a vector.
I'm going to pass in vector 2 or 3.0 so that we don't pass in any damage vector so that it doesn't go flying off in any direction.
Now, the last thing that we need to fix with this is actually going to be an error.
But before we fix the error, I want to show you the error so you can see what it looks like because you're going to run into this many, many times.
I've seen it, I don't know how many times, and I think it's important to note.
So, we've got our B encounter.
We've got our player layer.
I'm going to switch it over to the player.
I'm going to save our scene.
We're going to press play and let's watch the error appear.
Go to the console and look at that.
Argument null exception value cannot be null.
And it says the parameter name is result.
So think for a second.
Don't click on it.
Think about what this might be.
If you can think about what the possible problem is, what could be null right now before you even click on it.
Think through the code that we've written.
Go take a quick look at it and think about it.
And then come over here and click on it.
Let's take another look.
So here you'll see that it says the value cannot be null and the parameter name is results and it's in the overlap circle internal.
And if I scroll down a little bit more, you can see the actual call stack.
So it was called by uh line 42 and then line which called line 50 which is in our damage players and range.
If I click on it, you see that it's the overlap circle all and it's this results parameter.
The reason it said results is if I hit comma here and go over, you see that the name right there is results.
Ah, if I can get over there far enough, it's that name of the parameter right here.
So the problem is that this player hit results is never initialized.
So we need to initialize it to a new collider 2D array and give it a default size.
Um usually we don't need a number probably as big as 100.
I probably go with like 10 since we're doing this on a player layer, but you can pick a size.
Usually I go with 100 as a default so that we can have up to a 100 things in that hit array.
Um again, it's players.
I'm only going to have one, two, maybe four at most.
So, that's probably fine.
Now, before I jump back into Unity, there's one other thing that I just forgot about, and you may have noticed as well, that I've not turning the lightning back off after the animation's over.
So, I'm going to copy line 40 here and paste it right after 43.
We'll set change this to be a false so that we turn the lightning object back off after the time has run out.
Let's go back into Unity and we'll press play.
And then I should expect to see my damage happening and some decent control here.
Although we can only have one lightning at a time, I can control how often those lightnings appear and uh what their damage radius is as well.
Let's see if I can take some damage.
There we go.
Look at that.
Worked perfectly fine.
And I expect it to work fine no matter what spot I'm on.
Let's crank up the radius though, just so we can see that it actually does impact things.
Like that I took damage there.
And if I want to turn down the delay between lightnings, I can put it at a zero and we'll just constantly get lightnings firing off over and over and over with a huge radius.
Let's turn that back down to one so that doesn't insta kill me.
But now you can see that I've got some control and it's very very easy to modify.
Let's stop playing now.
Go into plastic.
Say we've added player damage and some lightning control.
And then wait for them all to finish.
That way we can give ourselves a little bit of a delay without having to write very complicated code.
To start, let's grab our lightning and start extracting and refactoring some of this code.
Our start and counter method is already what is this almost 20 lines long.
I think it's about time to start shrinking it down and turning it into some things that are easier to digest.
The first thing I want to do is grab our lightning object after line 39.
So on line 40 say var lightning equals and here we're just going to get that lightnings at index.
Then we're going to replace the lightnings at index down below with the word lightning just so that we can get rid of and stop accessing it from the array.
We just kind of pull that reference to the object off.
add in a space and then do this awesome trick of selecting the entire thing, hitting alt enter or let's see, control shiftr.
Let's see if it's going to let me do it.
Rightclick and find the extract methods, quick actions and refactorings.
It's not going to let me refactor and extract.
That's fine.
Sometimes it works, sometimes it doesn't.
Depends on the code editor.
So instead what I'll do is select all that code hit controll X and then I'm going to write the code or the line start co- routine and here I'm going to call show lightning li ht n i n and I'll pass in the word lightning or our lightning object and add a semicolon.
We'll generate this method and get ready.
I've got my stuff on the clipboard.
I'm just going to paste it right in.
I do need to replace this string with iie numerator.
But now I've got code that's going to kick off a co- routine to show a lightning object and then wait for it.
So what if I wanted to show two lightning objects? Well, I could just duplicate this.
Well, actually, if I did that, it's going to just show that same lightning object, but I could duplicate the part that picks a lightning and then shows it um and then show it right afterwards.
So, I could take this bit of code right here.
Let's just copy it all and paste it.
Just got to get rid of the declarations here because they're already declared.
And then this would show another lightning.
Although theoretically it could pick the same random index and show that same lightning object.
Let's just do this for a moment.
Let's add a yield return new wait for seconds.
And we'll wait for a delay between strikes.
And then we'll add an alt enter, generate a field for it.
Hit F12.
We'll cut that.
I'm going to move it up here.
Um, we have delay between lightning and delay between strikes.
Um, I kind of feel like these are somewhat redundant, but they're not actually.
So, this is the lightning.
This is a between each individual attack, and then this is between each individual strike.
I'm going to put this delay at maybe like a 0.25.
And we'll do a build.
control shiftb jump into unity and let's just see that in action.
Make sure that we're getting two lightning strikes that our two co- routines are working and that everything is somewhat okay or see if everything just goes completely wild and haywire which is kind of what I expect.
Let's watch it.
So, here we go.
We're in the scene view and well, let's see.
If I go to the console tab, you see that stuff isn't really showing up, but I can see some lightning's kind of appearing and then disappearing instantly.
And what's happening here, let's take a look here.
If we go back to our code, is that we're in this while loop.
And in this while loop, we're doing a little bit of a wait.
We wait between strikes and we um is that it? Yeah.
And we do one yield for a frame.
But right after we kick off these two co- routines, we go right back to the loop and we turn these objects back to false or not active.
So, we're just disabling all of the objects again right at the end of it.
Now, if we waited, if we moved this outside of the while loop, it would get a little bit better.
Our first lightning might actually show partially, and our second one would still end up getting overwritten or disappearing or doing something weird.
Let's actually see that.
Let's cut this.
We'll move it up here to the beginning.
And we can actually delete out the while yield or the yield return null statement that was there.
And let's change it to be just like this.
and go take one more peek at Unity and see what that looks like.
See the behavior and then we'll talk about how we can wait for these co- routines to finish instead of having it kind of run them and keep kicking them off in a loop.
So let's see what happens if it's insta kicking them off in a loop without turning them off.
We're going to see lots and lots of lightning.
Get ready.
I'm going to go.
Let's just run over here.
There we go.
Tons of lightning appearing constantly.
some of them are getting interrupted halfway through because a new one starts it up and then eventually or really quickly my player dies.
So what we need to do is wait for these two co- routines to finish and we can do that with a simple statement which is a yield return wait until.
So do yield return wait until which waits until the condition inside of the lambda statement afterwards or the condition that's passed in is true or met.
So, we're going to create a lambda statement.
And the lambda statement is going to be that our active lightning objects are all um not active.
Now, to get access to know what our active lightning objects are, we're probably going to need to store them off somewhere.
So, let's create a list of active lightnings.
Let's create a list right up here.
list active lightnings or no list of transforms sorry named active lightnings and we'll just assign that to a new list and then we'll add in our new lightning objects to it.
So when we kick off a co- routine we'll say active lightnings.add and we'll add our lightning.
I'll do that down here for the second one as well.
And then we're just going to wait until all of the active lightnings game objects.
So, we'll do doall all of its game objects.
And here, I'm just going to do another lambda inside of this.
And we'll say t um no, not t.active self or game object.active self.
There we go.
And close that off.
So, we're going to wait until all of our active lightnings have their game object inactive.
So, that means that they are no longer active.
And then we'll clear out our active lightnings.
So say active lightnings.clear.
And I've got a typo right here where I missed my new keyword.
It's a new wait until.
Whenever we do the yield return, it's always yield return new wait until or it could be anything that we've cached off so that we're not creating a new one every frame or every time, which is even better, but beyond the scope of this for now.
So I've got my build, I think, working.
I should be able to jump back into Unity now and then control the number of active lightnings and the delay between them and the pause between them.
Let's go see if that's the case.
See if it's all up and working as we expect.
So you can see lightning lightning got two shots firing off.
Two more shots firing off.
Now I've only got one shot firing, two shots firing, two shots firing.
Let's turn up the number of shots.
Oh, I didn't.
And make it variable yet.
So, we won't turn up the number of shots, but we turn down that delay and they should fire at the exact same time.
Turn it up to like a 1 second and I can see that they fire about a second behind.
But let's watch one more time and see if we get the case where it doesn't fire off two.
If I change the delay between strikes to zero, eventually we should see a scenario where only one fires off.
And the reason that that's going to happen as soon as it does happen is that it's picking the same lightning object twice.
So, let's see if it happens.
Come on now.
It's never going to happen.
There we go.
It happened.
So, that happened again because we picked the lightning object and then we don't check to make sure that it wasn't the same lightning object that was picked before.
So, instead of adding our lightning and then um just picking it again, let's make sure that when we pick a lightning object, it's not already in our list.
So to do that, we could just do a check right here and say, say, say, let's see, how do we want to do this? Let's actually first let's take this bit of code here, line 49 through 53, and just delete it.
I'm going to get rid of that for a moment.
And I want to take the code here from lines 41 through 47.
And we're going to turn this into a method called spawn new lightning.
Let's do that.
Can we hit alt enter and extract a method? Maybe or Visual Studio let us.
If not, we'll just cut Crl X and say spawn yield return spawn new lightning.
Now we generate a method for that spawn new lightning with alt enter.
Make sure that it returns an IE numerator and then paste in our code here.
So this will spawn a new lightning object.
Oh, but we do need a reference to our active lightnings.
So, we've got to now decide, do we want Active Lightnings to be a field variable or a member that's just passed in? And this is a good time to promote this up to be a field.
To do that, we'll just change the name here.
Control-r, add an underscore to it.
Go home.
Control delete.
Control delete three more times.
Hit alt enter and generate a field.
Then I can just add that underscore right here.
And my code is fixed.
If I hit control-click on this, you can see that it just added that public list or private list, sorry, up at the top.
Let's delete out that private keyword.
So now we've got a spawn new lightning method that will spawn a new lightning.
Um, no.
And that's essentially all it's going to do.
We can duplicate that method or we can make it spawn any number of times.
But before we spawn a lightning, let's make sure that the one that we've picked isn't in our active lightnings list.
So in our spawn new lightning method, we'll say while active lightnings.contains contains lightning.
Then we're just going to pick a new index and create or select a new lightning.
So I'll copy lines 50 through 51 all the way up to the index part cuz I'm going to have to delete that int.
We'll add a brace here, paste it in, and delete out the var keyword.
And now we've got a loop here that's going to keep picking a random one until we pick one that's not in our list.
There is a theoretical and a very easy to cause giant crash bug here.
So before you start running this code, make sure you save your scene, save everything, and make sure that I would even say that you commit because you will crash the editor if you start playing with these values and start moving things around cuz you can get this while loop stuck and break the whole thing.
We'll talk about that in the next section though.
For now, I want to make sure that we can spawn any number of lightnings.
So we'll add a loop here.
We'll say four tab and we'll change length to number of lightnings.
And then we'll move line 45 inside of that loop.
We'll generate a field for number of lightnings.
Hit F12.
Change that to be a serialized field.
And I'm going to default it to one.
We'll cut it and move it right up here.
Oh, I did not cut that correctly.
So, cut it with Ctrl X and paste it up here.
So, now we've got a number of lightnings to show.
We've got the delay and we've got all of our other settings.
I think that we are ready to now go play with it, cause everything to blow up and have some fun adjusting some settings.
So, let's save.
Make sure that the whole scene is saved.
We'll go into plastic.
So, we've added a variable lightning count and check it in because again, we're going to be able to crash things.
May as well get us get our stuff in a perfect safe state before that happens.
We'll press play and let's just watch everything in action.
I'm just going to go to the scene view.
See the one lightning appear.
If I turn this up to two lightnings.
The next time we should get two appearing.
And there's a little bit of a delay between.
If I turn it up to three, we should get three appearing.
And notice that we're going to get three every time.
We're not going to get situations where we get one or two.
If I turn it up to four, we're going to get four appearing.
I can turn the delay down to zero and I'll get four appearing all at once.
I can turn it up to five and I get five appearing.
Turn it up to six.
I I'm guessing you know where this is going.
Let's turn up to six.
I get six appearing.
I turn it up to seven.
And my editor has completely crashed.
The game has blown up and I can't work anymore.
So hopefully I committed.
Hopefully you've committed too.
In the next section we're going to talk about what's going on and how to fix that.
Let's take a look at the code that blew up and see why it happened and what we can do to fix it.
But I also want to take this chance to introduce some more AI stuff because I think that when you run into some scenarios like this, if you can't figure out the problem on your own and you're having a hard time finding somebody else to help walk you through it, this is another great way to figure out what's going on.
So, instead of explaining the actual problem and solution to you, I'm going to copy the code that we've got right here, paste it into chat GPT and see if it can tell me why this is causing a hang.
And if so, then we'll continue on and we'll um we'll make it better.
So, I've got my chat GPT window open here, and I'll say, can you explain why this code is causing my Unity editor to freeze when I have more and let's go look at the actual name of my variable here.
More um light no uh let's see what is the actual variable number or variable name.
a number of lightnings higher than um the num than available lightnings when I have more number of lightning than the available lightnings.
And then I'll paste in my code down below.
Hit enter and let's see what it's doing.
It's saying that it gets stuck in an infinite loop when all the lightnings are already active.
See, it already is explaining and telling us exactly why we're trying to get one from the list that isn't active, but the number is higher than the actual available number.
And to fix this issue, again, why I wanted to show this, you can add a check to prevent an infinite loop to make sure that active lightnings never exceeds the total number of available lightnings.
Look at that.
Place that condition at the beginning of spawn new lightning and it will just bail out and say, "Hey, too many lightnings.
We're good to So I can copy that little bit of code, go paste it right at the beginning of spawn new lightning, save, do a build, and notice this yield break statement.
What that's going to do is actually return from here and not continue on execution.
So it's going to log out an error continue or break this code or not break but break the execution of the code so it stops executing it and then allow the code to continue back at one level up.
So, that should fix our issue.
Let's press play.
Not only should that fix our issue, but that should show you that AI is starting to make things um drastically different.
And the way that you solve these problems, like not knowing the pro the actual issue here is, I think, a lot easier to to solve.
Now, you start searching, start putting in your code and finding the solutions for this stuff.
So here we've got a very simple, very easy solution that works, solves the problem.
Our error is gone, and now hopefully you're kind of inspired to start looking at chat GPT for some other ideas and other types of code and things that you might want to do.
Done a lot of it lately.
I highly, highly, highly, highly recommend it.
All right, let's stop playing and go check in our change that we've fixed the being counter or the infinite while loop.
and check that in.
Now that our bee is shooting lightning, you might be tempted to make it start moving around and maybe blasting off laser beams and doing a bunch of other cool stuff.
And while that is what we're going to do, there's something else that we need to do first, and that's make our player character movement a bit smoother.
If you look at our character right now, you can see that it's pretty easy to jump and get stuck on a platform.
Kind of jump up and bounce around.
You can I can even get stuck in between these platforms.
Sometimes you can get stuck in the water and not be able to jump out.
And there's a scenario here.
Watch what happens if I just keep jumping.
First, I'm not getting a jump animation.
And second, notice that my jumps are infinite.
So, there are a couple things going on with our player character that we're going to adjust.
We're going to make it so that our player feels a bit smoother, more like a natural platformer.
And then we'll add in the extra functionality for our bee.
Cuz right now, I could fight our bee.
I can make him really good at fighting, but our player doesn't handle well.
So, we can't really test that and get a good feel for it.
So, let's work on the player first and then we'll dive into the bee.
The first thing that I want to take a look at with our player is our jumping.
Let's take a look at our jump right in here.
You can see that I've got unlimited infinite jumps and we're not playing any animation.
And there's a very good reason for that.
Let's go take a look at our code.
We'll start by opening up the player script and let's look at the part where we see where we're grounded.
In our update grounding, we check against a center point.
We're doing array cast downwards.
If we hit something, we mark as grounded to true.
Then we check the left and do the same.
And then the right.
If any of those hit, if we have a ray that goes down from our character and touches any collider, then we say that we are grounded.
So, why is that happening when we're in the air? Let's go take a look at our character again.
And now, let's go look into at him in scene view, though, instead of in the game view.
So, go to the scene view, and we'll double click on our player, zoom out, and see that there don't appear to be any colliders here.
And if I select my player and go to the rigid body and expand out the info section where I can see the actual things he's contacting or touching, I can see that when he's on the ground, he's just touching the grass mid object there.
And when he's jumping, he's not touching anything at all.
So there's no collider that's following him or anything like that.
So I'm going to add in a line in my code to log out what's happening and tell me a little bit more about it.
I've got a couple options.
like I could log out a line or add a breakpoint.
We'll do both.
Let's go in here and when we find something in our update grounding that we've hit, we're just going to log what that object is.
So if is grounded is set to true, then we'll just log out the object and a reference to it.
And then we'll add in a breakpoint too just to debug and attach and show both ways to do it.
So here we'll say debug.log touching and then here we're going to give it the object that we're touching.
So, we'll use a braces and I'll put hit.c collider.
This is going to add the closing braces.
And it didn't automatically add the dollar sign at the beginning like Ryder usually does.
So, I'll go up there, type it, and add a semicolon at the end.
So, now this is going to tell us what object we're hitting.
I also want to be able to just click on the object.
So, I'll add in the second parameter to our debug.log, which is the context object or the object that you'll select when you click on it.
And we'll use the hit.colid.game object.
I'm going to copy this line 153 and paste it down here under 162.
So it's 163 and it looks like 173.
We'll save S.
Do a quick build with my control shiftB.
And then we're going to jump back into Unity and see what object is touching our ground or what object is being found to make us think that we're grounded.
If you already know what it is, don't worry.
You're you're ahead of the game.
If not though, we're going to show you exactly what it is by popping up this error log or debug log.
It's not actually an error log.
All right, here we are.
If we go over to our console now playing, you can see I've already got lots of log entries.
Touching B trigger, touching B trigger, and touching B trigger.
And if I select it, see that B trigger object appears.
I can jump and then eventually I get a touching ground, but I'm always getting a hit on this B trigger.
Let's go look at the B trigger.
I'm going to pause.
We'll go into scene view and we'll look at that trigger one more time.
Remember, this is the activation area for our B.
So, what's happening is our raycast is hitting that trigger and then thinking that it's the ground.
So, we're going to need to refactor our raycast a little bit and make it a little bit more intelligent so that it's not checking against triggers and other objects that we don't necessarily want it to.
We should also probably not have all of this copy and paste here.
We've got check center, check left, and check right.
They're all doing the same thing with just a very minor change, and it's very difficult to see what that change is.
You can see it's actually right here, the plus foot offset and or minus foot offset and plus foot offset.
So, get ready.
We're going to refactor this, clean it up, and make it a lot easier to understand and fix bugs along the way.
To fix our player controller and make it a lot more versatile, we're going to start by refactoring our update grounding method.
Instead of copying and pasting a check center, check left, and check right, we're going to call in a single check ground method and then just pass in the different positions that we want to check against.
That way, we can check the center, the far right, the far left, or any number of other points along the way, or just use totally arbitrary points.
To do that, we're going to start by taking the lines from 148 to the end of 154 and just extracting this into a method.
The reason that we're selecting this is because if you look at all of our lines below, the only thing that changes is the origin.
So, we're going to select everything after the origin.
So, the origin will be passed in as a parameter to the method that we're extracting.
If I select the origin here, in fact, let's do it real quick.
Select the origin, hit enter, alt enter, and extract.
You see that I get a method with no parameters named new method.
And I could call this check grounding.
But I wouldn't have a way to duplicate or reuse this with a different origin.
I'd have to go in and change it.
So I'm going to z.
We'll select again all the way up to the beginning of the hit, but not including the origin.
Alt enter.
And then extract the method.
And we'll call this check grounding.
And now we're passing in an origin.
inside of that check grounding method.
You see that we do our raycast just like before and we check to see if we hit a collider and do absolutely nothing different.
So nothing has changed in our check grounding.
We're just now extracted that into a separate method.
I can also delete line 148 here because I'm not going to need it.
If I delete it though, I'm going to get some errors.
Let's watch it.
So I delete it and you'll see that here on check left and check right, I was trying to use that hit variable or my code was and it's not there.
So, it's giving an error.
I don't want to do that, though.
I just want to call check grounding in each of these positions.
So, I'm going to copy check grounding, select lines, everything after the origin essentially down to the beginning of the check right and paste over it.
Do the same here on the check right side.
Replace hit all the way down to the end of the brace with a check again.
And now we're checking against the center, the left, and the right.
If I save now and do a build, I should have zero functional changes.
So, let's just go make sure that it works and that no nothing has actually changed functionally yet.
All right, we're back in and I can jump and double jump.
That seems good.
Jumping resets when I land on the ground and it should still bug out over here and I should still stay in like an infinite jumping state.
Okay, so no functional changes yet.
Just wanted to verify that.
Now that we've moved our check grounding code into a single method instead of copy and paste it or our raycast part here, we can modify this code to check and see if we're in a trigger so that we can ignore that trigger.
So let's do that now.
We'll go right above line 164 and let's add a check.
We'll check to see if we are in a trigger and if so, we're just going to return back out and not set that we're grounded.
So we'll say if hit.c collider and hit.c collider is trigger.
So if I'm if I hit a collider and I'm in a trigger in that case let's just uh return.
We won't say that we're inside of a or we're grounded at all and check grounding will not return if we hit a trigger as our thing that we're we're hitting with our raycast.
Now if I go back into Unity, you'll see that this somewhat fixes the issue.
Look, my character just got a little bit bugged out.
I can double jump now and I'm not getting the extra unlimited jumps here.
But my character will still occasionally bug out.
Look at that.
It still thinks that I'm in jumping mode right now.
And the reason for this, if I clear out my log, let's go back to the console and clear out the log and do a jump and see if we can see it.
Is that we land, we're touching the grass, and we're touching the grass and we're touching the grass, but then we stop touching the grass and we're not we're no longer grounded.
So, it thinks that my character is not grounded.
If I go to the player and go select them and then let's go check the is on is grounded and see that he doesn't look like he's grounded.
He actually doesn't think he's grounded.
And the reason for that is that our raycast notice that it's not hitting this showing this touching grass mid.
It's actually hitting the the the background here and never getting to the part.
So, not the background, the trigger area.
It's hitting the trigger area here on line 166 and never getting down to the next line.
Let's go into debug mode now.
like I mentioned before and see that in action.
So, if I put my breakpoint there, just click to the left and add a breakpoint and then press F5 or attach to Unity.
F5 is the default and the hotkey that I'm using.
It should now run our check grounding method multiple times per frame.
Let's see.
We should get a pause and a break any second now.
There we go.
And we'll see that we're hitting a collider.
That's the B trigger.
And then if I hit F10, it just wants to return.
And it's never going to get down here to line 169 to say that we're grounded.
So we need to change this.
The reason that this is happening, and it may not happen for you, it's going to be very dependent on your system and the scene setup.
Exactly.
The reason that it happens is the physics 2D raycast method only returns back the first thing that it hits or the first thing that it finds in the list.
And I believe it's doing them by the internal um object ID, but I'm not completely sure.
What we can do, however, is find all of the objects and then just loop through them.
So, we're going to change this check grounding method.
Instead of doing a raycast, we're going to do a raycast all.
I'm going to stop debugging.
We're going to change this from raycast to raycast all.
And then we're going to change from raycast hit 2D to arraycast hit 2D array by adding the two braces.
and rename this from hit to hits.
Then we'll add a for loop.
So we'll say for each var hit in hits and we'll add a opening brace.
I'll delete out that closing brace.
Go way down to the end of our if statement here.
Add a new line and another closing brace.
So now we've taken what we were doing against one raycast.
Hit these lines right here that I've selected 168 through 176.
And now we're running them against everything that we hit in our check in our raycast instead of just the first object.
Now, this is going to cause a little bit of a problem though because on line 169, we don't continue on and check all of the things.
We return back out if we hit a trigger.
That's not what we want to do.
We want to just continue on and check the next object so that our loop actually works and we've solved the problem.
Let's save now and go check it out.
see if we can now see our character working properly in that area or in our trigger area.
All right, here we are in the trigger area.
If I jump, I jump again.
Got my double jump, one jump, two jumps, and I'm good.
And it looks like my jumping is working.
I'm no longer bugging out.
I can land on the ground.
And things are getting a little bit better.
Let's go into the water, though.
So, I go into the water and I jump.
Land, jump, land, jump.
Oh, I can't jump anymore.
So, we need to make one more change to our check to make sure that if we're in the water, that also counts as being on the ground.
So, to do that, we'll stop playing, go back into our player script, and now we have that one single place to check.
We can check it right here on line 168.
So, if we hit a trigger and that trigger is not water, then we'll continue on.
If we hit a trigger and the trigger is water, then we're going to just mark it as grounded.
We'll say that yes, we are grounded because um the the object um well it's water so it's it counts as the ground.
So we'll say if the collider is trigger is true and hit.c collider.getcomponent water is equal to null.
So we did not get a water.
Now I'm going to add these out as separate lines because I think it makes it a lot easier to read.
And then let's evaluate it one more time.
make sure that it's all easy to understand.
We can probably refactor and change things around even a little bit more.
In fact, let's we I can see that we've got this hit collider check twice.
Let's move that up to the top and do an early exit so we can simplify this down a little bit.
So, I'm going to take line 173, cut it, move it up here to 168, and we'll say if hit.colider, and let's add a knot.
So, if it hit there's no collider, then we'll continue.
That way, I can get rid of the hit.
Check in the other spots.
So now on 171 I can get rid of that and simplify this statement down a little bit.
And then I can get rid of the braces on 176 and one now 179.
Kr D to fix my formatting.
And I think it's getting a little bit easier to read.
Let's do a shift delete on 175.
And now let's evaluate it one more time.
So we're looping through all of our hits.
If we didn't have a collider, somehow we've got something in here that doesn't have a collider.
Shouldn't happen.
But if that does happen, we'll continue on and just keep going.
If we hit a trigger and the trigger um does not have a water on it, then we'll continue on because water triggers, we want to count as ground, but everything else we don't.
Otherwise, we've hit something that's not a trigger and is is or is water.
So, we mark grounded to true and then we check to see if we should be marked on the snow.
Now, there is an issue here.
is on snow um could be set to true in one frame and false on another frame or another part of the frame.
So we could call in check grounding the left foot could be on snow and then we get is on snow to set to true and then we check the right foot right after that and if the right foot was not on snow then we could be setting it to false.
So if we want to make sure that if any piece is on snow that it gets set to true.
We can also make one quick modification to line 176.
And instead of doing an equals, we can do an or equals.
We do the it's shift in the key right above enter or shift in the the pipe that's right next to backsplash or backspace, not backsplash, backspace, and that will make it be set to true if it was false, but not set to false if it was true.
So it'll turn it on, but not turn it back off.
Now is on snow is already getting set to false at the beginning of the frame.
So it'll only get set to true.
It'll never get improperly set back to false.
All right, I think that's all we need.
We're going to save our code, do one more build, and then go test it out.
And here we are.
I should be able to jump normally on the regular ground.
Looks good.
In the water, I can jump unlimited, I assume.
I'm always marked as grounded.
Look at that.
Yep, jumping is good there.
And then if I go into my trigger area, jump.
Jump.
Looks good.
I can run around.
I still get stuck on things.
We haven't touched that yet, but I can still run and jump and properly get into the correct jumping and landed and grounded states.
Things are looking good.
So, I'm going to stop playing, go into plastic, and before we commit, let's do a quick diff and just take a look at our changes.
So, we'll open up the player diff.
And we can see that we've just added in well here's a little bit of extra spacing there.
But down below the part that matters, we've added in a check grounding method and we've refactored our update grounding to call that.
You can see that there's still a little bit of room to clean this up, I think, but it's getting quite a bit better.
And now we've got one spot that now works properly in triggers and in water.
So, let's close that out and say that we've fixed jumping in triggers and water and refactored the grounding method and we'll check that in.
Now that we've got our raycast refactored, we're going to pause and take a quick look at performance.
There's actually a good opportunity for some simple optimization and a good explanation of some of the things that are changing with the 2D physics system.
So, let's take a look at our character here.
I can run around and jump, and I can see that it's working fine.
I've got my double jump and all, but I want to look at how it's actually performing.
So, I'm going to open up the profiler.
I've got the tab here, but if you want to open it, you go to window and then go to analysis and profiler.
That'll bring up the profiler window.
I do have deep profile turned on.
You're going to want to stop playing.
Make sure that you go to the profile mode and turn on deep profile.
It turns on.
it gets that little uh you know the Unity visualization it's off and now it's turning back on.
With deep profiling on I can get performance characteristics of every single line of my code, not just at the top level.
If I don't have deep profiling on, I won't get full info about what's going on.
I'm going to press play now.
And when I say full info, I'll get things like the update for player took how much time, but it won't tell me how much each sub method that got called from inside of there.
If you enable deep profiling, it's going to give you the entire stack trace all the way down.
So, I'm going to go into profiler.
I've got my game running right here.
Go to the profiler tab right here.
And I'm just going to click on any old random frame.
I know that I call my grounding code and all the raycasting stuff every frame, so I don't really need to care which frame I'm on.
But if I scroll through here and I just look at the overview down here at the bottom.
Let's drag this up here to the top.
So I've got CPU usage and rendering showing.
I don't really care about rendering yet.
So I'm just going to drag this all the way up.
So just CPU usage is showing.
Here's a a scroll bar on the right hand side that allows me to go through all of the different things that are being profiled.
Again, I'm going to go up to the top and just select CPU usage and grab a frame here down in the hierarchy.
If you don't see the hierarchy and you see it as a timeline or maybe as a raw hierarchy or something, just make sure that you go select hierarchy.
And then if you don't see the thread correctly, I mean, it should be on main thread unless you went and selected something else.
Then scroll up to the top and we're going to sort by time.
So just click time ms right here.
So that the arrow is pointing down and the thing with the highest time is at the top.
We can see right up here at the top we have our update script run behavior update.
This is our code being run.
This is our own scripts being run.
And underneath it, we've got the behavior update, which is the update method for all of our scripts being called.
If I expand that out, you'll see that it's calling players up, player update, debug updater, event system, blaster shot, and some Cinem Machine update.
So, all of these things have an update in them.
The only one that's taking a good amount of time and doing this GC allocation, which is our garbage collector allocation, is the player update.
If I expand that out again, you'll see that it's actually all inside of the update grounding method.
And I can expand that out again.
I just use the right arrow and down arrows, by the way.
And I can see that check grounding is doing it.
I can keep expanding out and see that the biggest impactor right here is the debug.log.
That's usually the case.
If you have a debug log, it's going to destroy performance.
So, I'm going to remove that.
And then let's take a look at what else we can remove, though, or what else we can change.
If I go down a little bit further, you can see that much much smaller but still there as an issue is the physics 2D raycast all method.
If I expand that out, you see it's calling raycast all internal.
It's allocating some memory.
The GC alloc means that it's creating objects that are going to have to be cleaned up later and it's taking a little bit of time.
Now the time amount here I'm not too worried about.
It's 002 milliseconds.
It's not horrible, but the allocations I don't want happening.
So, we're going to fix that as well.
Let's stop playing and go look at the code now.
Now, in our code, the first fix, and the biggest one, is to just get rid of this line 177.
I'm just going to comment it out with my two forward slashes.
The next thing that we want to do, though, is change this raycast all.
Instead of using the array cast all method, we want to use one that doesn't allocate memory.
One that just reuses or restores off an array of things that it's hit and then fills that.
The reason for that is again so that we don't have to have objects that are being created and destroyed every single frame because that causes memory fragmentation, eventually causes garbage collection, and then that causes a freeze or a pause or a hitch on your game depending on the system that you're on.
But if you're not on a high-end system with fast memory access, you can expect that to happen.
So you want to minimize these allocations.
Now to do that, we've got a couple options.
We can use the raycast all nonalloc that appears as an option.
But what we actually want to do is switch back to raycast.
And that's because the way that the physics system is being updated, the raycast method is getting a bunch of overloads.
and the raycast all and raycast nonalloque.
In fact, all of the nonalloque overloads or methods are being removed or deprecated.
And we can see that easily by let's just go put the raycast nonalloc here and hitting F12.
If I hit F12, it's going to show me the decompiled code in my code editor.
And this is shows me that it's marked as exclude from docs.
And if I actually go look up this up in the documentation, you'll see that it does say that it's going to be deprecated soon.
So, what can we do? Well, what we can actually do is use one of these raycast overloads.
If I look right above it, you see there's a raycast that takes an origin, a direction, a contact filter, and has a list of results.
Or there's one up here with an array of results.
So, I can use one of these two methods as my um as my thing or my my call and then pass in the list or array of results.
So, let's go back and rewrite this.
We're going to just add a new line and I'm going to say int hits equals physics 2D raycast and we'll do the open parenthesis and I want I believe it's overload four.
So I'm just going to hit the down arrow until I get to the fourth one and I can see it.
Oh, is it four? No, it's number five.
So I know that the first parameter is my origin.
I'll pass that in.
Then our direction, which is vector 2 down.
Then we've got our Let's see if I can find my overload again.
overload 5, our contact filter.
So, we'll put let's just do a new contact filter for now.
And in that contact filter, we'll set the layer mask equal to underscore layer mask.
And then our next parameter for the array cast is going to be the results.
So, do underscore and oh, is it actually let's make sure that it's results.
Go down to number five.
Yes, results.
So, raycast hit array.
Let's call this underscore results.
And then finally, we need our distance, which we've used a 0.1, so we'll use a 0.1 for this as well.
I'll put the semicolon at the end.
And then I'm going to get rid of line 165, and we'll generate the results field.
We'll hit alt enter and generate a variable for it.
Hit F12.
We should have a private raycast array right here by our player data.
I'll get rid of the private keyword.
And then we're going to initialize the array to be a new raycast hit 2D array.
and give it a size of 100.
That's way larger than we'll need.
We're never going to have 100 colliders that we hit.
So, if we have more, we'll just overallocate it by quite a bit.
It's still a tiny amount of memory, but way more than we need.
All right, let's go back to our code.
I'll just hit the back button a couple times.
And I'm going to split this raycast into a few lines because feel like it's a little bit harder to read now because we've got our contact filter in there.
So, let's just split this all into new lines.
And then instead of looping through each hit, we need to do a for loop because hits is now an integer and not a collection.
And now we have an an array here of results.
But if we loop through all of these results, we'd be looping through a bunch of empty entries every time because it's got an 100 entries there.
And it may or may not be filled.
The array cast method is going to tell us how many things were put into the results array.
So we can just loop through that many times.
So we'll replace our for each with a for loop by typing four.
I'll hit tab a couple times and replace length with hits.
Then I'll delete out the brace here on 173, the for each loop, and that brace again on 173.
And then we'll add a new line here and just say var hit equals underscore results at index i.
So we give it the braces.
And now we're looping through all of our results and assigning their first result to hit, checking it, and then assigning the next result to hit and checking it.
And so on.
So, we're looping through them all without creating a new array.
We're now should be running this without allocating any extra memory.
Let's save, go into Unity, and try it out and see if our change worked and if our performance has improved.
All right, we're back in Unity with the profiler running.
I'm going to go over here.
We'll just find a random frame.
And we can look here at check grounding and see that it is now allocating zero and taking 002 milliseconds.
The raycast has shrunk down just a little bit and we've got zero allocations.
Things are looking good.
This is again a nice easy optimization and something that we should do on anything that we're doing a raycast for that's continuous.
If we're doing a raycast every frame, it should almost always be nonallocating.
In fact, there's very there's almost no excuse not to use one that doesn't allocate.
The overloads are there and they're kind of the default.
So, go with that on anything where you need to raycast continuously or where you're just going to do it often enough that the allocations are going to matter.
So, now that we've got that change in, I think I want to go into plastic and commit our changes.
We've also got um some extra junk here.
Just cleaning up and version updating.
But let's say that we've Let's see.
Let's do a diff real quick.
We'll pull up the player.
We'll diff.
And I guess the only note here will be that we've uh switched to ray casting a non-allocating version of raycasting.
So switched ground check to nonallocating raycast.
Now, we're going to dive into our character's wall sticking issue where you can run against walls and just keep kind of running and sticking in them or jumping up on them and you can see it kind of floating in through there or sticking on little ledges like this.
We're going to make it so that when you're pushing off to a direction and you're up against a wall, we know that you're touching a wall and we stop trying to run against it like a weirdo.
So, to do that, we're gonna make a couple of quick changes to our character.
But first, I'm going to stop playing and we're just going to grab a little wall and move it down here just so that we've got something to kind of block ourselves when we're not running.
I think I'll just take this grass platform, duplicate it, and move it right down here so that it's off to my left.
So, now I should be able to run against it.
And I want to be able to have just something that I can test to make sure that I don't have to jump every time.
Okay.
So, there we go.
I've got a little platform there, and I want to be able to stop running when I'm touching it.
So, let's stop playing and think about how we're going to go about doing this.
We've got a couple of options.
One thing that we could do is just make our character have zero friction so that they could slide down and it would fix the issue of them jumping up against the walls here.
So, they would kind of slip down, but it wouldn't fix the problem of me just running at a wall constantly.
I want to know a little bit more about what's going on with my character and be able to have a little bit tighter control over that.
So, just like we do a raycast downward for the ground to see if we're grounded, we can do some ray casts off to the sides to see if we are touching something that should stop us.
And then we can even specify what types of things should stop us and what things shouldn't.
So, if we want to have things that we can run up against and push, we can specify that those things are pushable.
And if we want to have things that just stop us, that can be the kind of default behavior.
So, to do that, we're going to need to modify our player script.
And we're gonna set it up so that we do raycasts out each side of our collider.
Now, we've got two different colliders.
Remember, we've got our standing collider and our ducking collider.
There's our standing collider and the ducking one.
And we want to do a raycast probably from the center of each collider out.
And then maybe one from near the top and one from near the bottom.
We could do any arbitrary number, but I'd say at least three like we have for the feet.
So, let's start by visualizing that inside of our player.
We'll add some gizmos in there that show the positions that we're talking about so we can make sure that we're actually raycasting from the right spots.
And then we'll hook it up to actually use those and fill in some fields.
Let's open up the player script.
And then let's find our ondraw gizmos.
And after we draw the right foot, let's go down and draw some gizmos for our left and right sides.
Let's make a method called draw gizmos for side.
And here I'm going to put in vector 2.
And we'll give it a number of points.
Let's say we're going to draw three gizmos for that side.
Then I'm going to duplicate that and do one for vector 2.
Now generate a method for this that's going to draw gizmos on each side.
And then we'll generate the method.
We're going to rename the first parameter from right to direction.
That's the one that we're facing.
And then the int here to be the number of points.
Now, we're going to need to figure out where to draw these.
It's going to be somewhere from our center and then um off in that direction, I think.
So, I think we'll start by just using the center point plus the offset to the right.
So, I'll say var origin equals transform.position plus direction.
And then um we'll just use that as our initial one.
Then we'll add in a oh this wants to be cast as a vector 3.
There we go.
So that it can combine them.
That's because the transform position is a vector 3 and vector the direction was a vector 2.
So now we've got a vector 3 for our origin.
And right now we're just going to draw a gizmo at that origin.
So we'll say gizmosdraw.
Let's do a wire sphere at that origin.
And we'll give it a default value.
I don't like a value of uh three.
I think that maybe like a 0.05 is good.
Give us a nice little wire sphere.
So that should give us a wire sphere right at the center there.
And then we'll set it up to do the number of points right afterwards.
Let's go back into Unity.
see if we have a wire sphere showing up somewhere off to the center and one meter over to the right and left.
There we go.
We've got one right and one to the left.
And if I go into prefab edit mode right there by clicking the arrow, see it becomes a little bit easier to see.
So, I've got my two points there.
Now, let's make it do points all the way up and down.
To do that, we'll change our code to use a loop.
So, instead of doing one at the origin, we'll do a loop.
We'll say four tab.
and we'll go through the number of points and then we'll move our code inside of that loop.
Now, we're doing them all at the exact same point.
And what we want to do instead is evenly distribute them from the top or the bottom.
So, we're going to need to figure out how tall this thing is and then divide that height by the number of points.
So, we'll create a collider height.
Let's call it float collider height.
And let's just start by using the height of our standing collider.
So say standing collider dotbounds do size.y.
And then we're going to use a like segment size.
Let's call that segment size.
So float segment size equals our collider height divided by our number of points.
It should give us a nice amount to go up by from the beginning.
Now take that segment size and we're going to go up segment size times number of points from the bottom of our character.
So let's spell that out kind of step by step.
Let's start at the bottom of our character.
So that's going to be our transform position minus half our collider height.
So that' be transform position minus a new vector 3 of 0 comma collider height divided by two and a zero.
So that's going to give us a base or the feet.
Now we want to go up however much our segment size is.
So say origin plus equals our segment size or actually it needs to be a new vector 3 first.
new vector 3 of 0 comma our segment size time I.
So we'll start at zero.
We're not going up at all.
Then we'll go up by whatever it is 33 or whatever the third is or 2 if we do five and then we'll go up to 04 and 6 and so on.
You kind of get the idea.
This assuming I did five had to three here.
So it' be 33 66 and one.
And then for our final parameter we'll put a zero for the Z.
So that should give us our origin going up from the center.
Again, we're using the standing collider only.
And right now, we're completely ignoring the direction.
So, we also need to offset it by the direction some amount.
To do that, we can just add another line here and move the origin over in that direction times some multiplier that we put in.
And so we'll say origin plus equals direction times and let's call this wall detection detect ci.
And then we'll generate a field for our wall detection distance.
Hit F12 and then go turn it into a float because of course it wants it to be a vector 2.
We'll make it a serialized field and then I'm going to cut it and move it up by the rest of our serialized fields.
and then give it a default value of I think about a 05.
I think that's that should be good based on our current character, but we can modify it now and adjust it.
Let's go back here and take a quick look.
So, our direction times wall detection distance is going to give us a vector 2 and origin really, really, really wants to be a vector 3.
Let's just um cast our direction as a vector 3 for now.
There we go.
and we'll do a quick build.
Now, we should be able to see our gizmos off to the side and specify how many of them there are.
And then we'll be ready to use those positions for our ray casting.
Again, I think it's always a lot easier if I do the gizmos first.
I can see where things are going to happen.
There we go.
I've got one point there and one point there.
And let's see.
Let's go find our values.
So, we've got our wall detection distance.
I can drag that in and out.
Oh, our number of points is not variable yet.
Let's go check that out.
So, let's replace this three with a variable.
Let's call it a point count.
public int point count.
And we'll move this in a second.
I'm going to set this to five.
We'll copy and replace these two threes here with this point count variable.
Let's do a quick build.
We'll jump back into Unity.
And then let's watch our points go up and down.
Then we'll move that and figure out a good name for it.
I'm thinking like a wall point count or wall check count.
Uh something like that.
We got to come up with a good variable name.
So I've got my point count here.
And if I adjust this up and down, I get absolutely no change.
And the reason for that is that we're using the standing collider.
And if I turn the collider on, you see that suddenly all of my points are working.
And that's just because our code was looking at a collider that wasn't on.
And we actually need to look at the correct collider.
So instead of using standing collider.bounds bounds size.
Let's pick the correct collider.
We'll say var active collider equals.
And then here we want to check if we're ducking.
We'll say is ducking question mark.
We'll use the ducking collider.
And then if we're not ducking, we'll use the standing collider.
I don't think we have an is ducking variable yet.
So, we're going to need to go add that.
We'll copy is ducking.
And I believe in our is ducking code, we actually have a lowercase version of this variable.
Let's go find it.
Is ducking.
There we go.
Right here on line 140.
I'm just going to replace the var here and the is ducking with the c capital is ducking and then we'll replace it right there.
Replace it right here and replace it right there.
And then we'll generate a field for it.
I hit F12.
We'll move this field up by our other ones like is uh let's see is on snow and is grounded.
And then we'll make it public so we can sit there and watch it evaluate our is ducking and see what's going on in the inspector as well.
All right.
Now, let's go back to the code where we were using that right here.
Oh, I was already right at it.
And just make sure that we use the correct collider.
So, instead of using the standing collider, we use the correct active collider, the one that we're actually showing.
Let's go back into Unity one more time and look at our little wires or our little uh wire meshes up here.
We've got two, one, and two.
Change this up to three.
Now, I've got three there.
And I can change this up to like a let's go to five and see I get lots and lots of points.
And I can scale it up and kind of adjust the number of points that I'm going to get.
So this is mostly working, but I'd also like to add in a little bit of an offset as a final thing so that we're not checking against the bottom position right here.
And we kind of move this up so that it's off of the center instead of off of the ground.
We'll do that in the next section though.
So, for now, let's go in and commit our change to the player that we've added gizmos for wall detection.
And actually, before we check that in, let's make sure that we've moved that one variable that we had to move.
In fact, let's go back in and do a quick diff.
Rightclick, do a diff.
It's always good to do a quick diff before you commit.
Make sure that you've got things finished and in the right place.
And remember our point count.
That's the variable that I want to move up.
So, I'm going to cut that.
I'm going to move it up here.
And I can actually do this inside of the diff tool.
I don't generally recommend that you do it, but you can.
As long as we don't mess up and make any typos, we should be good.
I've got a serialized field for my point count.
Now, I'll save that, close it, and then commit our changes soon as it finishes completing domain.
Terrible name for a thing, but anyway, there we go.
Check in and done.
Currently, our rays or our gizmos for our rays aren't distributed evenly from the center.
And that's kind of intentionally.
So, we can use a cool trick to figure out how to make them be evenly distributed.
If we adjust the points and see if I go to like one point, it's down at the feet instead of in the center.
If I do two points, I have one at the feet and one in the center.
Three, I kind of get one split up here, but I never get one all the way to the top.
I get them kind of at the edges, but not where I really want them.
I want them to be centered.
If I have three points here, I want them to be centered from here and have one above the middle, one below the middle, and then have some offset there.
And I could figure out the code for it and explain the math and probably get confused.
But in a real scenario, if you get stuck and you want to do these kinds of things, the tool that I've been using and highly recommend everybody get into is the generative code AI stuff.
I like chat GPT, but any of the code options will do.
Let me show you why.
Let's take a look at our draw gizmos for side method.
And I'm going to copy it.
We're going to go back over to chat GPT and we're going to tell it that we like this method, but we'd like it to evenly distribute the points along the side from the center instead of from the bottom.
So, I'd like the following method.
Let's see if I can spell following to distribute points along the side of the collider from the center.
Let's say too evenly instead of from the bottom.
I'd also like to be able to specify a buffer for from the top and bottom for the points that's shared.
and let's paste in the code and let's see what it does.
My expectation is it's going to give us a buffer parameter or a buffer field and then it's going to modify the code and give us essentially a working version.
So here we go.
We've got a draw gizmos for side.
It's taking a look at the collider height and using the buffer.
Now it's figuring out the segment size which is the number of points.
Oh, minus one.
probably part of the problem with our our code.
And then it'll loop through the number of points.
Let's see.
It's almost done.
Start from the bottom instead of the center.
I don't know why it's starting from the bottom.
Well, I guess it's explaining what it's doing.
It makes sense that it would start from the bottom though because the way the math works.
And then it's going to loop up and give us our code.
So, let's let's copy the code.
We'll paste it into the editor and see if it just works.
So, we paste.
We save.
We go back into Unity and as soon as it recompiles, oh, it doesn't look like it recompiled.
I haven't passed in that last parameter.
So, once we've saved, we know now have this buffer parameter that we need to pass in.
Let's just call this uh underscorebuffer.
And we'll generate a field for it.
Copy that in and paste it into both of these calls.
Should probably just make this like a global field.
And we'll give this a value of 0.1.
I'm going to make this a serialized field.
I spelled serialized totally wrong, but I'm going to cut it, move it up here, and then just copy and paste.
All right.
Now, if once I get my F on the end there, we should be able to jump into Unity and see if the AI was able to give us working code, which nine out of 10 times it just does.
Look at that.
We've got some nice evenly distributed points here.
We can adjust this barrier kind of up and down.
Oh, the buffer isn't working correct.
It doesn't give us one from the bottom, but we can adjust the point count and see that that's working.
So, let's set this buffer back to a zero here and adjust the point count up and down and watch the values.
You can see that it's filling in pretty good, but our buffer doesn't work.
So, let's fix the buffer part.
To do that, we'll go back into chat GPT and say the buffer only works from the bottom.
I'd like it to work from the bottom and top simultaneously.
I think I spelled that close enough.
And it's going to apologize, I'm sure, and then give us a corrected version of it where the buffer works on the top and the bottom.
So, we get our updated gizmos code.
And then once I'm done with it, if I'm curious on what the difference was, I can just ask it, hey, what was the difference? And why does this one work? Why did the other one not work? A lot of the time though, when it comes to simple stuff like this, this is the code that I'm gonna write once and then forget all about because I once it works, it works.
I don't need to think too much about it and I don't want to spend a ton of time just uh locking it into my head.
So, I'm going to copy this code again.
We'll go back into Unity.
We'll go find our method one more time.
Draw gizmos for side.
We'll paste over it, assuming that everything is okay.
One thing I did notice is that the word detection is wrong here.
So, let's replace this.
Wall detection.
I think I typoed that before and uh put that into the bot and the bot got confused.
All right.
So, now we've got our code.
We jump back in.
We should have a working buffer is my guess.
I haven't even checked it.
I'm just guessing that it's probably going to get a buffer that works.
Oh, nope.
Now we got a buffer that works only from the top or only from the bottom.
So, let's try it again.
That buffer only works from the bottom.
I'd like one that works from the top.
Bottom and top at the same time.
There we go.
Now it's explaining the problem.
The buffer should be added to the base of the collider.
Yep.
when computing the origin.
Okay, so version three or the third time should should solve the problem.
This happens again a lot when you're going through AI stuff.
Um you're going to get code that just doesn't quite work.
And if you correct it, you'll get the fixed version most of the time and doesn't always work and it's getting drastically better, but by the time you watch this, it could be 10 times better than this even.
So don't just avoid it because it gets things wrong the first time.
just continue the conversation with it until it starts to understand what it is you're trying to do.
Unless, of course, it's just taking you way longer than doing it yourself.
Don't obviously don't do it for things where you already know the the solution.
So, let's fix this detection distance again.
I just pasted over the code one last time in hopes that the system has finally figured out the problem.
Let's go see.
So, I've got some points.
They look pretty evenly distributed.
I changed that buffer to a 0.1.
That looks good.
Change this to maybe three points.
All right, I am liking what I'm seeing.
My buffers are good.
My points are good.
And I'm ready to do the raycasts.
Before we do that though, let's go check in our code that we've uh added buffer and proper spacing to wall detection points.
And we'll check that in.
Now that our player can jump around and dodge the bee's attacks, let's give him more attacks and give our player the ability to kill the bee.
And that's where we're going to start.
We're going to add some colliders to our bee and make it take some damage.
This should be a pretty simple process.
We're going to start by going down to our Broot object underneath the B encounter.
Remember, our B encounter holds the bee and the platforms and all of the other things related to this boss fight.
The Broot is the actual character that has an animator that we haven't set up yet and then has underneath it all of the different body parts.
The first thing that we're going to want to do is add some colliders to the parts of the body that we want our player to be able to shoot.
Now, that might not be the entire body.
A lot of the time we want it to be specific parts or sometimes it's even just specific parts that are only activated when they're in the middle of some certain animation.
This character has a couple pieces that we could use like that, but we're going to start with just adding colliders to the body and the head and leaving it off of the wings and the little tentacle things going up.
Make it a little bit harder to hit the guy, but not too difficult.
To do that, we're going to select the body parts that we need.
Looks like the head on is one of them.
We'll add a polygon collider to it.
And then I'm going to select down.
Let's click again until I don't want the effect parts.
No, we'll click right here.
This is the body front.
So, we'll add a polygon collider to that as well.
And then I want this big base part of the body, too.
So, I'm going to click and select it.
It looks like that's body back number one.
And I'll hit add a polygon collider there as well.
Now, again, I mentioned that these change.
So, we've got a part two.
If I turn this on, you see this is a slightly different one.
Um, you can't really tell the difference, though.
I think let's see.
Switch it.
You You probably can't tell unless Oh, yeah.
There you can see it.
So you can see that's the one for when he's animating and trying to shoot out.
But it does some rotation and stuff.
So it's a little bit more difficult to see it.
For now though, we're going to turn that back off and just make it so that you can only shoot the bee when he's kind of in these normal modes.
Although I believe you can hit his head anytime that he's not dead.
All right.
So we've got some colliders on him.
And if we shoot him right now, nothing's going to happen because he's not set up to take any damage.
Now to make him take damage, we've got a couple options.
We could go add a script where we've got these colliders here for our polygon colliders and implement the I take damage method and then figure out how to pass that along to our B.
But a simpler and less involved solution that I think works a little bit better, requires a lot less setup and is less likely to break is to open up our blaster shot script and have our blaster shot look for parent objects that take damage if it doesn't find one on the collider that it hit.
So to do that, we'll just add in a line here after 49 and say if damageable, let's see, I spell it right.
Equals null.
Then we're going to just assign it.
So I'll copy line 49 except for the var.
And we'll use get component in children.
So if we don't get an object, we'll find a child or not in children.
I said the wrong word, in parent.
So we'll find an object in the parent or up the hierarchy that has the I take damage interface.
If we find that, then we'll tell that thing to take damage.
So, let's go back and look at our character one more time for our B.
So, our B has these different parts here that are all children of the B root object.
We could put our damage part on the B route, but really the B-root is just the animator and the piece that's moving around kind of moving those colliders and stuff.
The part that's got all our logic is the B encounter.
So, we're going to add the I take damage to our B encounter.
We'll go right up to the top, implement the interface or declare that we're going to implement it.
Then hit alt enter and generate the method.
Whoops, I hit F12.
I want to go down to the bottom.
We'll go to our take damage method.
And in here, we're going to make our character just take some damage.
So, we'll decrement the health that doesn't exist yet.
Underscore health minus minus.
And we'll check to see if the health is less than or equal to zero.
If our underscore health is less than or equal to zero, then we probably want to die.
And to die for now, let's just disable our B's object.
So, we'll say B set active to false.
So, we don't want to turn the whole encounter off, just that B object there.
Now, we going to need to implement or create these fields.
We're going to need a health field.
So, we'll generate that.
And then we're going to need a B field.
So, I'm going to generate that.
And we're going to make that into a serialized field.
Let's hit F12, go up there, and grab our fields.
So, the B first I'm going to move up right below our number of lightnings.
We'll make it a serialized field and we'll make it a game object cuz I want to be able to just turn that object on and off.
That's the moving bee.
Then we've got our health.
Let's make that default to about five so I can kill the bee pretty quickly.
And I'm going to make it public.
I want to be able to see and view this number temporarily, but I don't want to get it confused and make it a serialized field until it becomes a max health or something that's not changing at runtime.
For now though, we'll jump back into Unity.
Let it compile and then we should be able to now run over there and shoot our bee.
Have the messages go up to the bee encounter and kill our bee as the first step of being able to fight this actual battle.
Let's see if it works.
So, we'll get in, run around, run and jump, jump, jump, go blast our bee.
We should see the shots landing on him.
If I can land a shot.
Oh man, I'm terrible at this.
See if I can land a shot here.
I'm just going to go over next to him and shoot him.
There we go.
Shot him.
and he disappeared and died.
Looks like it's working so far.
So, I'm going to go into plastic now and just commit that our bee can take damage with his colliders and check in.
Oh, and save our scene, of course.
Now, we're going to work on the process of making our bee encounter much more challenging.
actually making it kind of fight back instead of just shooting some random lightning.
We're going to start by allowing our bee to move.
We'll give him some destination positions and move them along there and then talk about how we can use AI to make that even cooler.
Let's dive in though with our B encounter.
What we want is for the B object here, the B routt, let's hit W and go into move mode to move around during the fight, stop at different locations, and eventually let off that big laser blast that he's got.
So, we're going to start by creating some positions that he can move to.
We'll predefine four or five of them.
And then we'll dive into the B encounter script and see how we can hook those up and make him move among those points.
We'll start by right-clicking on the B encounter, choosing create empty, and making an empty object.
And that's going to be way off at 00 0, like way over there.
So, I'm just going to zoom in where I want it kind of loosely, and hit control shift F, and then zero out the Z position so that it's right there along the line.
This looks pretty good.
But I think like somewhere right around here in the middle is good cuz it's going to do like a laser blast down there.
So I'll take uh this point and then I'll duplicate it.
Actually, let's rename these real quick.
Let's name this destination_1.
I'm going to name it B destination_1.
Delete that duplicate.
And then I'll duplicate this one and get my second one with the underscore.
I'm going to put this one kind of up and maybe a little bit closer to the uh the top.
And then I'll duplicate again.
Maybe do one that's down low here somewhere.
and then one that's kind of uh I don't know maybe maybe in the middle something like that.
All right, I've got four destinations now and I want to hook those up to my B encounter and have him move around those points.
Let's go into our B encounter script.
And first the thing that I like to do is just give myself a reference to those points so that I've got something to use in my code.
So we'll add a serialized field and this is going to be a transform array because we have multiple transforms.
It could also be a list of transforms.
Let's just use a transform array.
And we're going to call this B destinations.
We'll go back into Unity and assign those real quick.
First, I'll do a quick build.
Control shiftB.
Jump back into Unity.
We'll assign those and then we'll hook up the code for it.
I know if I don't assign them now, there's a good chance that I'll forget to assign them later.
That's why usually when I make a serialized field, if possible, I just go assign it.
So, it's locked.
I've got the window locked on the BN counter.
We'll drag the destinations onto the destination section and we get all four of them.
And then I'll unlock this so I don't get confused later.
Go recheck my B encounter and open up the B encounter script.
So in our on enable, we kick off a co- routine that starts the encounter.
I want to change this up a little bit.
Let's make multiple co- routines.
Have our start encounter be something like a start lightning and then have a start movement method that we call as well.
So, we're going to rename start encounter to start lightning.
And then I'm going to duplicate line 33 and change lightning here to movement.
We'll create a new co- routine with alt enter just generate a method.
It's going to of course have string there.
So, I'll replace it with i numerator and then we're going to add in our code.
So, first thing we want to do in this code is create a while loop.
We want just a loop that's going to run indefinitely.
Um, just like we have here on line 50.
We don't have any real setup to do.
So, we'll say while true.
So, for the rest of this thing, as long as this object's around, we want to get the next destination.
Figure out what that is.
And then we want to move towards that destination.
So we'll say var destination equals_b destinations at and then let's create a variable for this which should be our destination index and then we'll generate a property or a field for this.
I think I want to do this as a field so that I can see it in the inspector just kind of debug it although it could just be a local variable declared right here above line 39.
I'm going to generate it as a field though.
And then I'll just add the uh well, let's make it I'm going to make it a serialized field for now.
I could make No, I'm going to make it public because I don't want to accidentally get confused that it is a serialized field that I want to be serializing, but I do want to debug and view it and be able to change it and play around with it for a little while before I make it private.
So, I'll probably in the end make it private and have a show in inspector or something.
But for now, we want to be able to also just slide this and adjust the value and and try out different things.
All right.
So, in our start movement method, we're getting our destination.
Next, we need to get the direction to that destination.
To do that, we say var direction equals.
And here, we just use our local position transform.position minus the destination.position.
And this is actually wrong.
This is broken.
And it's a problem.
And it's a problem that's very easy to fall into when you start moving around child objects.
Let's think about this for just a second.
The transform here is the B encounter transform.
It is not the transform for our B's object, the B root here.
This animator that that we have.
We need to use that object and move that around instead.
So we need to move the underscoreb transform, not the B encounter transform.
To do that, we'll just change this code right here to say underscoreb.transform.
transform.position.
So now we've got the direction to the destination.
Next we need to normalize it because when we subtract those two vectors we don't actually get the direction.
We get the entire distance in xy coordinates how far away it is and in the direction essentially we get the direction ma with the magnitude.
We want the direction normalized though which is just setting it down so that the vector max or the vector's magnitude is one.
And so if it's straight up and down, it'd be like a one on the y and a zero on the x.
And if it's at a 45 degree angle, it's whatever it is, like 7.77 on both of them because it I think it's 707.
It it normalizes them out so that the total magnitude, the total distance from the center is still one unit.
That's what normalizing is.
It makes it so that the distance from the center point in the direction is one unit, which in unity is typically 1 meter.
So we're normalizing our direction.
And now we need to move in the direction of that normalized direction.
So to do that we're going to create another while loop.
We'll say while vector 2.d distance and here we want to check the B transform position and our own destination.osition.
So while that is greater than and here we want some sort of movement threshold.
Let's just start with a 0.1.
So a tenth of a meter.
While it's more than a tenth of a meter away.
Oh, missing an closing parenthesis there.
Um, what we want to do is move towards that position.
So, we'll say underscoreb.t transform.position equals vector 2 dot whoop.
See if I can get that right.
Vector 2 dot move towards and we'll give it our current actually really we don't even need the direction here.
We'll give it our current position b.transform.position and our destination.position.
position.
Now, now that I'm realizing that we don't need that, oh, we'll need the third parameter, though.
So, we'll need our speed or our movement amount, which for now, we'll start with time.
Delta time, which is going to move it 1 meter per second because over a time of 1 second, it'll move one meter distance.
That's what that third parameter is.
Let's fix the formatting here and talk a little bit more about this code.
So, our distance check is I added an extra parenthesy.
Our distance check is good.
And now our B movement is I think solid.
But again, we don't need the direction part now because we're using the move towards method instead of actually adding direction.
So I'm going to delete outlines 42 and 43.
I did want to leave them in there though because that's kind of the default thing that I start to do when I start writing code.
I end up writing things to get the direction and then half the time realize, oh yeah, I don't need the direction.
I'm using move towards.
So we use move towards to move towards our destination.
And there we go.
clean up our formatting.
And then finally, we want to yield return null.
Once we've reached our destination, we just want to increment our destination index.
So, we'll say destination index plus+.
And then we need to check to make sure that our index didn't go past the number of B destinations that we have.
If we got four B destinations, we get an index of four.
We're going to get an out of range exception.
So, we'll say if underscore destination index, did I get it right? There it is.
is greater than or equal to our B destinations.length, then we simply want to set the destination index back down to zero.
So, we're just going to loop it back down over to zero.
So, right now, we're looping through all of these points and our character or our B should move between them when the start movement method kicks off.
Let's go into Unity now and see if it works.
We should have our B destinations assigned.
Just got to go double check that.
Yep.
And our B is in there.
And our destination index right now is at zero.
So we'll press play and run on over here.
Let the encounter start.
He's going to go do that animation playing back.
And then he's going to go snap over, jump over to that first position, and then he's going to move to his second position and his third position and his fourth position.
and then back down to the fifth position or the fourth pos the first position.
Sorry, getting my words mixed up.
Oh, no, actually he's going to three.
Now he's going to the first one.
And you can tell that by looking at the destination index and see he's going to one.
Now he's going to two.
And the reason I wanted to leave this open if I just change this to a zero.
Then I can force it to go to the the next one.
I I think I'll probably just make this read only though, so that it's just visible in the inspector because I'm not seeing a lot of value in being able to change it.
But I do see a lot of value in in being able to debug it and see what it is.
So now we've got our character moving around.
We're going to go into plastic and commit that before we make the changes to make him choose something at random instead of picking the same point.
And we're going to do that with a new class and something really cool and exciting, I think.
So for now, let's say the B moves between basic points, and we'll check that in.
Now, our bee moves, but he picks the same destinations every single time.
And I'd like him to randomize or choose a different set or different order so that our player doesn't know exactly where the bee is going to go.
It could go to one of the spots, but not necessarily always in the same order.
Got to add a little bit of variation here.
And there are a lot of ways that we could go about this, just like anything with coding.
And what I wanted to do for this section is actually dive back into AI and asking AI a couple questions for ideas because I think that it's important that you remember that when you're building out code systems, there are multiple different ways to go about doing things and there are different um algorithms and solutions available.
So, let's go into chat GPT and I'm just going to tell it that I have a character in a Unity game that needs to choose random destinations from a list of transforms and just asking it what options do I have for randomly picking the points.
And I assume we're going to get back a probably a very basic answer at first.
So, it says that we could use system.random or Unity engine.random and then pick one at random with a range.
So, here we get the code.
We can see it's giving us a choose random destination method.
which just uses random.range from zero to the number of destinations and then picks one and gives it back to us.
Um, that'll work.
That right there will give us a random position and move our B towards it.
Uh, we may end up with situations where we choose the same destination twice.
But in that case, we would still um we would still probably just we would continue moving on because RB would be at that point and we pick another destination.
Although that might be kind of problematic if we wanted to do that and we wanted to do it with a stop and a pause.
So if we pick if we move to a destination, stop, pause, shoot, and then pick another destination.
If that same destination is picked, then that could be an issue.
So let's ask it if there's a way to do it without choosing the same destination twice.
Is there a way we can not choose the same destination twice in a row? I didn't even put a question mark, but it knows that I want an answer.
It says yes, you can check to ensure the same destination isn't picked.
And now it's going to give us another method for doing it.
So here it's got a interesting a do loop.
Not a fan of do dowhile loops.
So I'm sure we'll ask it to refactor this again.
So it says in this code we have a last index that stores the last index of the chosen thing and then uh okay and then checks to see if it was the val invalid one.
So actually let's just use this code.
I was thinking you know let's just change it and pick something else.
But it's important to be able to understand and read what this does even if I don't necessarily like Actually I'm going to tell it to refactor it.
But let's take a look at the do code right here.
So a dowhile loop actually runs kind of a lot like a for loop except it always runs the code in this do part first.
So it's going to run that and then it's going to continue looping it while this statement is true.
It's kind of like a while loop but it always does it the first time.
So let's copy this code and see if we can get it to work.
I'll hit copy code.
We'll jump back into Visual Studio.
And right below my start movement method, I'm just going to paste in this choose random destination.
And I'm gonna make it do a couple things.
First, I don't want it to return void.
I want it to return back the actual destination.
So, right now, I get back a destination.
That's a transform.
Let's just return back that same type.
So, we'll get a transform from our choose random destination.
And we remember have this list of B destination or this array of B destinations.
So, instead of using or just destinations, we use B destination.
So, I'm going to copy that and paste and paste and paste.
But now we've got a couple errors on count and that's because B destinations is not a list like destinations was.
It's an array and arrays have the length property, not the count.
So we'll just copy length over the counts.
Uh for this random message, it's thinking that we want to use system.random because we have a using system statement up at the top and we can't remove that.
So we'll just go back down to the error and put that it's a Unity engine.random.
There it is.
So go find it right here and say Unity engine.random.
random.range.
And then finally, oh, we've got one more instance of B destinations.
The last thing we want to do though is remove these kind of last two lines of code.
We don't need to cache the destination and we don't want to move our character to it.
So, let's delete.
Let's see what do we got here? Line 73, 74, 73.
Just keep deleting.
And then we're going to return back out that B destination at the index.
So, just do a return.
And I think uh oh, at the bottom, we'll need to return null.
If we have no destinations, we're going to get back null.
So, we should probably just be ready to deal with that.
Although, realistically, our code doesn't deal with that anywhere else.
So, we could probably um h we should probably just leave it there.
Let's leave it.
We'll do a build.
We should probably deal with it in the part where we choose a random destination.
So, let's put in choosing a random destination.
We'll copy choose random destination and paste it over line 41 here where we're setting it to the destination index.
And then we'll just say hey um if destination is equal to null let's do an error unable to choose a random destination for the B stopping movement and then we'll just return.
So we're going to exit out if we somehow can't get a point and we can't actually do a return.
What we have to do instead is a yield break.
I I always almost put yield return break, but it's a yield break, which is going to just exit out and return and stop our co- routine.
So, if we get to the point where somehow we can't pick a random destination, it means that our data is wrong, something's bad, we should stop, log out an error, and be ready to fix it.
The next thing we need to do is just delete out lines 53 through 55 because we don't need this destination index anymore.
So, just hit delete.
Delete.
And then let's go find that variable and make sure that we delete it as well.
We had that destination index right here.
This is line 23.
Shift delete.
We'll get rid of it.
We'll do a build.
And now we should expect to see that our B can move around randomly between positions and doesn't choose the same position twice.
Let's see if that's the case.
So run over here.
We'll watch our B.
We've kind of lost that destination index.
So we're just going to have to watch him move around.
There we go.
He gets to spot one, spot two, the next spot, and where is he going next? Down.
Back.
Oh, that back down to that bottom one.
Then back up and then back down.
I'm not liking the movement pattern that I'm seeing at all.
He's just going back and forth.
Oh, and now he went to a different one.
So, I don't particularly like this.
I I think that perhaps he should randomly choose all of the positions or from all of the positions at the beginning and then um loop through them once and then reset.
So let's ask chat GPT if it can give us a version that does that instead.
I'm going to start by copying my code.
So I've got my choose random destination method.
I don't want to continue the previous conversation because I've already modified this code and I want to be able to keep that code that I've modified.
So I'll take that.
I'll go into chat gpt and then before I paste in my code I'll just ask it can you rewrite this method so it chooses all the available positions before resetting or or res re returning to a position it's already been at make this reset once it's passed all of the positions and then I'll paste in my modified code and let's see what we get back.
So it says the current method is choosing a random index from array and making sure the chosen one isn't the same.
But my requirement is now changed and I want to make sure that they've all been visited.
So it says that we can do this by creating a list of indices from zero to length and every time we just pick a random destination we'll move the index on that list.
So here we can see what is it writing here if b destination's length is greater than zero.
If indices is null and indices count is equal to zero then indices is equal to the range.
Oh okay.
So the number of val in integers between the point or between the zero and the length and then it randomizes them.
Oh no.
It picks a random one from the indices and then okay gets it and then removes it from the the list.
This is a little bit confusing.
I'm going to ask it if it can write a less confusing one so it's less confusing.
I mean, I can follow what it's doing, but describing the um the steps is, I think, a little bit confusing.
I think that the having the extra indices is extra and probably not necessary.
So, let's see what happens here.
It's going to choose a random destination.
If we have no destinations, we return.
If they've all been visited, then we reset the indices.
Okay? It's going to select a random one and then it's going to set the destination index to that random one.
Okay.
So, this isn't is this making them go in uh yes, it is into the a random position of them.
So, this does kind of work and it's describing it a little bit more.
Let's ask if it can do it without the indices.
because I feel like that's the extra confusing part.
It doesn't need to be there and um could probably be refactored out.
There we go.
So now it's going to create a copy of B destinations array and shuffle it and then iterate through that shuffled array.
And I think that this is probably the solution that I would end up on unless we end up creating a separate class that does the randomization too, which is another option.
So maybe we'll let's see what this does and then we'll ask it if it can turn this into a class that can transform or shuffle transforms.
So here's a method that shuffles the transforms.
I don't think that we need something that that that necessarily written out.
we can probably use a link statement.
And then it's got a choose random destination method that's uh using that array.
So this this part I like.
The part I don't like still is that the shuffle is uh not not using um a simp it's it's a little bit more complicated than I think it needs to be.
So say can you convert this to a class that randomizes transforms like a grab bag or something? Sure, I can convert it.
It's going to be named transform grab bag.
And a grab bag is just a thing where you sh throw a bunch of stuff in and randomly pick out items and tell it's empty.
So that's just one of the many types of uh or terms for randomization system.
So here we go.
We've got a transform grab bag that takes a array of transforms that shuffles them and then allows us to grab one item.
And let's ask it real quick.
Can you write the shuffle or can you replace the shuffle method with a simple link statement? So here you'll see that it's going to rewrite it again.
But I also wanted to while it's doing that look at this code.
So here it's you create a grab bag and then just get a destination out of it.
I like this a lot more than I like having all of that extra code inside of our B encounter.
Since this code is going to be responsible just for randomly picking transforms, we can now use this anywhere.
We can use it for anything that needs to pick a random transform or a shuffled transform that needs to follow this the same rule.
And we don't have to clutter up our our B and encounter code again.
So, let's copy this code, the transform grab bag, and we're going to jump over to Unity.
We'll just paste it down here at the bottom.
and then I'll move it to its own class.
So click select the class name right here.
Alt enter and move to transform grabbag.cs.
We'll go back and we're going to delete out the using statements here.
Those extra ones that got pasted over.
And then we'll go to our transform grabbag.
Make sure that this looks good and built and check the code.
I don't see any errors here.
Sometimes the copy paste stuff from chatg could have code error typo or some weird formatting.
So I just got to double check it.
And now we'll go back into our B encounter and actually use this.
So if we look at the example from chat GPT.
Let's see if we can pull that one up.
It was recommending that we call the method like this.
We create a grab bag and then we get a destination from it.
So I'll copy that.
We'll jump over to our code and inside of our choose destination or get ran choose random destination.
We'll delete that or where we call it right up here.
We'll paste our new code.
So we got transform grabb bag that takes the destinations and then we'll take a destination from the bag.
So here I'm going to cut line 39 and paste it over 43.
Let's get rid of the all this duplicate stuff.
We got destination equals grabbag.grab.
And here we've got that grab bag being initialized.
Now the one thing we want to do is reinitialize this grab bag.
Um if it gets empty, right? Does it do that automatically? grab.
If it's greater than the length, then it shuffles.
Yep.
So, it does.
It'll automatically reset it.
We don't have to do anything else.
It's looking good.
Let's do a build now and see if it works.
And if you're thinking, hey, couldn't we make that more generic? The answer is yes.
We'll do that next.
So, let's hit play though and watch our B move around.
We should see him come in and then choose some random positions, but never going back to the same.
He shouldn't do that back and forth.
So, go up.
Okay, it's going to that position, that one, then he's going to go down.
Okay, we should just never see him kind of going back and forth through those same points.
We should see you'll go through all of the points and then reset and pick a new a new set of points.
So, he's going all the way up to that top one and then back down.
I think things are looking pretty good.
The last thing that I want to make sure of though is that if he does a reset in that loop, so with the grab bag, I want to make sure that it also checks to see that we haven't um we don't go back to the new the first last destination when we reset the grab bag.
So, when we shuffle our transforms, I want to make sure that we never pick the one that we ended on at the beginning of the last one.
So, let's copy this transform grab bag code one more time.
And I'm just going to again ask I could write the code for it, but I'm going to tell chat GPT to do it because I want to see if it can.
And we'll just go down here and say, can you change the method below so that when the the the when when when shuffle transforms is called because it ran out of options, it doesn't choose the last position as the first new position for shuffle.
Oh, and then I need to actually paste the code in.
All right, so we can modify shuffle transforms to ensure the next position is not chosen.
So here we go.
We should get the last one and it's just going to memorize or remember the either the index or the transform of the last one and then make sure that that's not the first one.
That's all it really needs to do.
Let's see.
We should see the change inside of the shuffle.
So shuffle is looking at okay knows what the last transform is and it's is it rewriting the link statement? Ah yep.
So it rewrites the link statement.
Oh and then it adds the last one.
Huh.
So, this is going to work, but it won't work properly because it's going to take the um the last transform and shove that in as the last one.
I just want it to not be the first.
I just want the last transform to be first, not always last every time.
Can you fix that? Again, sometimes it gets a little bit slower writing code with uh chat GPT, but I think that if you're not sure how to write these things, you're not sure how to solve the problem, having these conversations with it.
And writing the code back and forth is going to make a huge difference and make it makes so you can actually get things done that you weren't able to do or kind of got stuck on before.
So, here's our shuffle transforms that's now caching the last transform.
And here it's saying, hey, if it got shoved into number one, um, move it into numbers, or if it got shoved into index zero, the first spot, then move it up one.
So, this should do it.
We'll copy that code.
Go back into here and take our shuffle transforms.
And we're going to paste in that new shuffle transforms method.
Let's zoom it in just a little bit.
You can see the entire thing.
Add in a space here.
And we'll just reevaluate it one more time.
So, it's going to order all of the transforms randomly using a link statement.
It's not the best for allocations, but it doesn't matter because it's once per loop on our encounter.
It's not something we're going to need to worry about performance-wise.
We could always optimize it if it becomes an issue.
And then we're going to look to see if the last transform was put at the beginning.
If so, then we just move it down to the next spot so that it doesn't become the the same spot.
We're go back to the same spot.
Let's save.
We'll go back into Unity one last time, test it out, and then assuming I'm not crazy, we'll make our commit, assuming chat GPT didn't break my code, too.
Let's see.
So, we press play, run over here, jump, jump, try to dodge that lightning.
There we go.
And let's watch the B.
It's going to one position and another position.
And another one.
And another one.
I just want to make sure that it's working as expected.
I think it's looking good.
He's looping through.
And I'm not seeing any issues.
So, we'll go into plastic and commit our changes.
First, I'm going to stop playing.
Make sure I've saved my scene and say that we added the transform grab bag and randomized B movement.
and we'll check that in.
Now, we're going to take a quick detour because we have a perfect example here of something that could be using generics.
And if you're not very familiar with generics, don't worry.
They're very simple and you've actually been using them quite a bit.
Often people don't realize that they're using them because they've never created a new one and don't really know how it works.
It's actually super simple.
So, we're going to do that right now.
Let's dive back into our code and take a look at the grab bag example.
So, go find that code window right here.
There we go.
And we've got our grab bag right now that takes a set of transforms, an array of them, and then shuffles them up and gives us back a transform.
What if we wanted to do this with game objects, though, or sprites or items or weapons or any other type of object in our game? Well, we could copy and paste this and just replace transform with game object or with whatever thing it is that we wanted to grab from grab.
But there's an easier solution and that's the generics that I was just mentioning.
So to use generics, all we need to do is tell it that we want to use generics.
Really, we give it a less than and then a type declaration or a type name.
I'm going to put T here because that's the most common.
And we're just about done.
Now, this isn't going to allow me to pass in any type of object because transform grabbag still takes an array of transforms as a parameter.
So, I'd want to change that.
Instead of taking an array of transforms, I'm going to want to take in an array of t or whatever the type is that's specified by the thing that's using the scrap bag.
So, let's put a t here.
And notice that we don't have an error.
And if I put my mouse over it that you are seeing that these are referencing the same thing.
Let's zoom it in a little bit.
You can see these T's are the same type.
So whatever type I declare for my grab bag will be the type of object that I have to pass into here.
Now that obviously causes an issue here on line 12 because the transforms that I'm passing in are of some type.
We don't know what it is.
Just type T.
And the transforms that we're assigning to are an array of actual transform.
So the first thing I want to do before we change this type is rename some of these variables.
Instead of calling these transforms, let's call them underscore things because there could be any number of things.
they different types of things and they're not going to be transforms.
And if I have the word transform everywhere, it's going to get confusing.
For shuffled transforms, let's call it shuffled things.
And then for the parameter here, I'll just call this things as well.
And I think I'll rename the method here to be shuffle things.
I want to get rid of transform as much as possible except for in the types because we still have to do some actual code changes for the types.
Oh, the last thing we have here is last transform.
Let's rename this to last thing.
Whatever that thing is.
Now, we'll scroll up here and we're going to fix the error.
So, on line 12, we're assigning an array of t or whatever it is to an array of transforms.
That won't work.
So, we're going to need to change this transform here to be t as well.
Very simple, right? All we're doing is replacing transform with t or whatever the type is.
Remember, it doesn't have to be coming from a transform.
This could have been something that worked on game objects, on uh sprite renderers, or any other thing that we want to randomly pick from.
Okay, so we've got T there, we've got T here, we've got T there.
It's looking good so far.
If we scroll down to our grab method, though, we've got an error on 26 that it's trying to return back a transform, but shuffled things is an array of T's.
So, we're going to replace transform with T.
And remember again, T is not a specific class.
It's not a thing that exists yet.
It's just the placeholder that we've declared right here.
T is the placeholder for whatever class we decide to use this with or whatever class the consumer of this class decides to use it with.
All right, let's go down to shuffle things.
In shuffle things, we actually have an error that we're going to have to do something a little bit more complicated with, but it really ties in perfectly with generics.
On line 38, we check to see if we're past the number of things and if the thing at index zero is equal to our last thing.
And this doesn't work.
And the reason for it is that we can't apply well here it says you can't apply operands of type T and transform.
So we can change this transform here to be T.
That will get rid of one error down below.
But this still doesn't get rid of the error because now it says can't be applied for operands of type T and T.
Really helpful, right? Well, the problem here is that it doesn't know what T is.
And T could be some type of object that can't be compared.
That can't just be compared with a double equals.
So, we need to go up to the top and tell it that T is always going to be a class because it it it is always going to be a class in our situation.
So, to do that, we just put where T colon and you can see it's autocompleting class.
Now, this doesn't have to just be class.
It could be where T is a mono behavior.
We could put like mono behavior or if we had some inheritance chain where we had like NPCs that inherited we had dragons that inherit from NPCs or something we could have where it's an NPC and it only randomizes things that are NPCs or derived from there.
For now though, we just want any type of class cuz this is randomization.
We really probably could just randomize just about anything.
Randomly order just about anything.
So there we go.
We've got our shuffle things method.
It should be working as a generic with the last thing I want to do to it is rename it.
Instead of being transform grabbag, let's just do control-R and rename it to be a grab bag.
Now it's just a generic grab bag.
That should rename our file as well.
Let's go check the file.
Yep, we got it renamed.
It's now moved to be grabb.
And the old one is now marked as moved.
And then the last thing we've got to do is actually hook it up.
So we're going to use this grab bag.
If I try to do a build, I should see an error because it's trying to reference it without the type.
Right here on line 38, we have a grab bag that has a it's being assigned a new transform grab bag.
So, first thing we got to do is delete the word transform there and create a new grab bag, but we also have to specify the type.
And here, remember, we're using transforms.
So, we'll just use transform.
And then we'll do the same right here.
And we're good.
So we should be able to build and save.
Now one optimization we could make here is we could um maybe not pass in the transforms or not do transforms and do a grab bag of vector 3es that just returns back those vector 3es.
But I generally prefer to um stick with transforms a lot of time especially when I'm earlier in development.
I want to be able to move things around at runtime and play with stuff.
So just an idea there, but I wanted to make sure that you you know it's there.
So think about generics when you're writing code.
when you write something that you want to reuse and you find that you're like copying and pasting and just changing a couple things in a class, that's a perfect opportunity for generics.
So, keep an eye out for for options where where they make sense and uh just just remember that they're there.
All right, let's jump back into Unity.
Oh, and also remember that you use them all the time.
Get component in children, get component and parent, uh find objects of type, all of those use generics and a lot of other built-in Unity methods do as well.
So, say we added generic grab bag and we'll check that in.
Now that our bee can pick random locations, let's make him do something interesting at those locations, like stop and blast us with a giant laser.
The first step to make this happen is pretty simple.
We'll add a little bit of a delay once we've reached a destination and just wait there.
First though, let's actually delete line 57 because it's unused.
You can tell it's unused because it's light gray there, just kind of sitting there underlined, letting us know that we don't need it.
So, we'll delete it with control X.
Now, inside of our while loop for our start movement method, let's add in a delay.
And we'll have a delay that's randomized between some minimum and maximum amount of time.
So, to do that, we'll add a yield return new wait 4 seconds.
And then we're going to give it a time that's random.
So, we'll use the Unity engine.random.range between some minimum and maximum idle time.
Let's put a min idle time and a underscore max idle time.
We'll let that auto oops.
Let's let that autocomplete there and add the semicolon.
And then we'll go generate two fields for this minimum and maximum idle time.
So, I've got min and we've generated a max.
Hit F12 to go to them.
And let's add the serialized field attribute.
Hold alt and drag over the private keyword.
Add those square braces and the serialize field.
I'm going to move these up so that they're up by our other serialized fields.
We'll cut and paste them and then give them some default values of maybe one and two.
So, we'll wait between 1 and 2 seconds.
That should be enough for our delay to happen.
Let's go test it out.
Here's our bee.
He's moving around and he should stop in just a moment and wait for 1 to two seconds.
There we go.
And then move again and wait again for 1 to two seconds and so on.
Looking cool, but I really want to see this guy animating before we do an attack.
So, let's add in some animations to our code and then hook up the animator controller.
Let's go into the B encounter script and when we start moving, so right here before our while loop, let's tell our animator that we're moving.
To do that, we're going to say underscoreban animator set bool.
And we'll just set a boolean named move to true.
We don't have a B animator yet.
So, let's go create one.
I'll copy B animator.
I'm going to go up to the top.
Control and home to cut right up to the top.
And then we'll add a serialized field.
I think right below line 17 below my B object.
So I'm going to duplicate, put in B animator by pasting and change this to animator.
It's probably not going to be at the same level as the B.
So I don't want to replace that B game object.
I've got my B animator.
Now I'm going to go back down to my code and we set move to true while we're moving.
And then while we're doing this idle, I want to set move back to false.
So I'm going to copy this line, paste it right here on line 60, and set move to false.
So, we'll set move to true.
Move, keep moving, keep moving, keep moving, and then set move to false.
And then wait.
Okay, let's go back into Unity now and hook that up.
The first thing we're going to need to do is assign our B animator.
Let's expand out the B encounter and the B route and take a look.
So, if you see here, I've actually got an animator on this base object and an animator up at the B route.
And I know that the one on the B route is wrong, but I want to show you how to be able to tell that it's the wrong one, too.
What we can do is go into this B controller here.
And if we just give this any clip, let's go give it maybe our B idle.
We're actually going to delete this in just a moment.
And then go back up to this base B object.
Go to the animation window.
Instead, I've got this idle B and it looks good and it plays.
If I select the B route, you'll see that that same idle B does not play and everything says it's missing.
That's because this is at the wrong level in the hierarchy and just needs to be removed.
So, I'm going to remove that animator component.
Go back down to this base.
And like I said, I don't like this B animator override controller that we've got.
So, we're going to delete it and create a new animator.
Our B doesn't need to act the same way as our robot or anything else.
So, let's delete it and create a new controller.
We'll rightclick and choose create and choose an animator controller.
There it is.
And I'm going to name this B with a capital B so that way I know it's the one that I created.
I'll go to this base object underneath my B and take the B animator controller, drop it on there.
We'll double click it to open it and then take the idle animation to make that our default.
Now I want to be able to go from idle to moving.
So I'm going to take the move animation and drag that out as well.
We're going to need a transition from idle to move.
And I want that to be either when we're moving true or when we're not moving false.
and nothing more complicated.
The up and down animations here don't really work great for just ba basic movement.
They're more for attacks.
So instead of using them, I'm just going to add a boolean here and call this move.
We'll then add a transition from idle to move and add a condition here.
If we scroll down the preview window, I can see my conditions.
We'll hit plus and we'll make it to be conditional on movement being true or move being equal to true.
We'll add a transition back from move to idle.
And this one will of course be on move equals false.
All right.
Now that we've got our transitions going, one thing I want to change is this idle to move transition.
I want to get rid of the exit time because I want it to be really fast and immediate once I start moving that I see that transition happen or that I see the animation start playing.
Let's save.
Now, I want to go make sure that I've assigned my B correctly.
I think I talked about it, but I didn't actually assign it.
So, I've got the B encounter here.
take the B animator.
We'll drop that down.
We'll save.
We'll press play and then go watch our B animate.
So, here he is.
He's flying down.
Flying.
Flying.
Flying.
And then I expect he's going to go into his idle.
Yep.
And then flying.
And then once he reaches his next destination, he'll go back to an idle and then fly.
And then idle again.
Now that our bee can pause, let's give him an attack.
We'll open up our B animator controller to start.
And let's take the attack B blast animation and drag it right above idle here.
I'm going to line it up nice and cleanly and then add a new trigger.
This trigger will be named fire just like our other triggers.
And we'll rightclick, make a transition from any state into that attack animation.
I'm going to click on the transition and add a condition to be the fire condition.
So that when we fire trigger or when we trigger fire, our animation will play.
After our animation plays, we want to make a transition into idle and we should be good.
Now we can call fire and call the trigger this animation to play any time.
Let's save and jump back into the code.
Now to do our fire, we're going to need to set a trigger.
Let's just duplicate line 60 with control D.
Change this to set trigger and then make it be the fire trigger.
We don't need a parameter there, so we'll remove it.
So, we're going to stop moving and set the fire trigger.
Actually, I think I want to do this right after we wait for our delay, though.
So, let's move that down one line.
And then, let's add in a weight.
So, we want to wait until our animation has blasted or fired off.
And let's take a look at that to see what I'm talking about.
If we look at the bee's attack B blast animation, let's just go click on it and then press play and watch it play.
and it fires off.
He kind of does this charge and then finally does a launch or a blast part right there.
And if we double click on it, you can see that there's actually an animation event that the animator already added for us right at the point where he should be doing that firing off or that launching.
Let's see if we can select the B right up there and drag and kind of watch it.
Let's go select the correct animation, the attack one, and I drag it up.
You can see it's right about here where it wants to do the shot and then it would kind of end over here.
So, what I want to do is fire or wait until it gets to right about here and then enable the big blast object.
So, how are we going to do that? Well, we're going to do two things.
First, we're going to wait for a call back from this animation event.
And to do that, we can just go to our animator object and just use our shoot animation wrapper.
The same thing that we've used before that has an onshoot and an onreload.
Once we've added that, we can click on our animation event and just go choose shoot.
So now we've got a call back that we can register for when we get to this point and enable our object.
Let's go back into the code and make that change.
Here we are.
Let's just add a new yield statement.
We're not going to yield return null though.
We'll yield return new.
Wait until we're just going to wait and we're going to add a lambda statement here.
So we'll wait until shot started is true.
And then we'll generate the shot started boolean value.
And let's go find it real quick.
I'll hit F12.
It should be up here at the top.
I'm going to remove that private keyword because we don't need it.
And then in our on enable, let's just register for the onshoot event in that animation wrapper.
And then when that happens, we'll call shot or we'll set shot started to true.
So we'll say get component and children shoot animation wrapper and then we're going to register for the onshoot and when we register or when we get the onshoot we'll run this lambda statement that simply sets shot started equal to true.
So now whenever onshoot is fired from that animation event shot started will be true and we'll be able to continue past line 66.
Once we've got the shot started, we'll just enable our blaster shot or our B shot.
Um, what do I want to call this? Let's call this the be laser.
We'll say be laser set active to true.
We're going to need to create a be laser game object reference up here.
So, we'll copy that and go add a serialized field of game object named be laser.
Let's jump back into Unity and grab that be laser now.
Here we are.
Our B laser should be inside of that prefabs folder.
This blue laser lightning is the lightning or blast object for our B.
And we're just going to drop it right on the effect shoot.
So, I'm going to take it and just drop it right onto effect shoot.
It should be all zeroed out for its position and the scale and everything should be at one.
Now, if I press play, I'm going to see this thing just constantly blasting.
Let's just go check it out, though.
Make sure that it's moving around with our B and just constantly shooting.
Yeah, that's exactly what I expect.
And now let's go back into the code and turn it off by default.
Here we are.
We'll copy B laser onto the clipboard.
And inside the beginning of start movement, I'm just going to set active to false.
So our B laser is not playing.
Now our B laser is getting turned on down below, but it's not turning back off.
And we're going to need to make sure that it turns off as well.
And since we already have a shot reload, why don't we use that? We can register for the reload event on that animation wrapper.
And then when it's the shot is finished, we can just use that as the reload.
And then turn our be laser active to false.
So to do that, first I'll just copy lines 68 and 69.
I'll just hit select them both and hit control D.
Click right here, hit enter two times, get a little bit of space.
And let's say we'll replace shot started with shot finished.
And then we'll set active on the be laser to false.
And then we'll go up to where we register for shot started right here on line 39.
And we don't necessarily want to get this component twice.
So we'll take the get component part and we'll just turn that into its own line.
So let's call this wrapper equals get component in children shoot animation wrapper.
Then we'll say wrapper.shoot plus equals.
And you get it right here.
The shot started equals two.
Oh, I called this wrapped instead of wrapper.
And then we'll duplicate it and have an on reload.
And that's going to say shot finished equals true.
That is what I named my variable.
Oh, I haven't generated the variable for shot finished.
So we'll copy that.
I'm going to go up to shot started, duplicate, and paste.
So now we have a shot finished that gets set on reload and a shot or shot started that gets set on shoot.
The one last thing that we're going to need to do though is deal with this looping because shot started is getting set and shot finished is getting set, but they never get set back to false.
So after we've done the weight, we also need to just set these variables or these booleans back to false so that they'll be ready for our next use or the next time we loop through here.
So say underscore shot started equals false and underscore shot finished.
And it's already autocompleting.
Let's hit control Krl D to fix up the formatting.
Save, do a build, and go test it out.
We'll have to make sure we assign the be laser before pressing play.
But once it's done, we should see something like this.
Here comes our B.
Going to fly on in.
Stop.
Load up.
Blast.
And stop.
And look at our blast is firing again.
Ah, that's because we never set up the reload animation event.
So, let's do that.
Now, the final thing we're going to need to do is go to our B.
I'm going to select the B part with the animator.
Go to our animation window and let's go find that attack B blast.
We have the animation event right here for shoot, but I forgot to tell us to add the animation event for reload.
So, right near the end, not all the way at the end, about one or two frames before, we're going to hit the plus on animation event and add a new animation.
You can see that little tiny blue sliver there on the animation event.
We'll choose reload.
We'll save.
Press play.
And now everything should work.
And here we go.
The bee is flying down.
Let's let him shoot.
And it's looking good so far.
There we go.
And it goes away.
We still got two little things to adjust on this, but we'll do those in the next section.
For now, let's stop playing, go into plastic, and add our commit notes that the B moves and blasts properly.
I guess it just blasts properly, but we'll put that in there.
All right, let's have another challenge.
It's time to add damage to our B.
And I want to see if you can do this without adding any code at all.
Let's watch our B.
Bam.
blast my player and try to jump.
You can see that every time that I get hit with one of his laser shots, I'm going to take some damage and go flying.
So, go ahead and pause.
See if you can figure out how to do this yourself.
And if not, go ahead and continue on.
Or either way, continue on and I'll show you the solution.
Bam.
I'm dead.
All right, let's go take a look at the solution.
So, what I've done here to make this happen is actually very simple.
So, if you go expand out your bullet laser lightning and go look at the different objects underneath it, you'll see there are a couple different sprites here that represent different sizes of those glows.
I just want the damage to be on this inside glow and I want it to just kind of match with that.
I don't need it to be on the outside glow or anywhere in between.
So, all I've done is add a polygon collider and then our damage player script.
With that alone, we should be able to now, well, we actually not just should be able to, but you can see that we're able to damage our players and cause them to go flying back.
Now, if you wanted to do something special with our damage so that they don't go just launching up in the air, maybe you want to do some other type of check, then you could just replace the damage player script with something that behaves slightly different.
Perhaps one that damages and stuns a player or even add an option to stun a player instead of moving them so that maybe they stand still can't take damage for a while or something like that.
For now though, let's just stop playing.
Well, I've already stopped playing.
Go in and commit our laser prefab.
So, say updated B laser prefab to deal damage.
And we'll check that in.
We're going to give our bee one more special attack.
But before we do that, we're going to fix up the death and hit animation so that our bee can be hit multiple times, only in certain states, take damage, and then play an actual death animation.
And then we'll crank up the health and add in that extra attack.
Let's go to the bee's animator controller, double click it, and open it up.
And the first thing I'm going to do is remove my transition from any state to be blast.
Let's make a transition from idle into the be blast and on that transition have it have our condition of fire.
And the reason for that is that we're going to add another transition from any state into dead.
And we don't want to go into be blast if we're already dead.
So we've got a transition into our beast there.
Let's add in our hurt animation next.
So we'll take our hurt animation and just drag it down below idle and move.
I'm gonna make a transition into hurt from idle and from move and then make a transition out of hurt back into idle.
We're gonna need to make a trigger here.
So, we'll add a plus or hit plus and add a trigger.
And let's just call this hit.
This will be the trigger that will fire off in our code whenever our B is hit.
We'll have that trigger be the condition for the transition from idle to hurt.
So, hit plus and go find our hit.
And then the same from move to hurt.
So go find it and hit plus and choose hit.
Now if we go into our code, we can hook up our hit trigger and watch the hit animation play.
Let's make sure that works before we add in our death.
So we'll go into our B encounter.
And right down in our take damage method, we'll tell it to play our hit animation.
And so I'll say else B animator sett trigger hit.
Oops.
Let's get the semicolon in there.
Do a quick build and test it out.
We're back in Unity.
And before we hit play, I'm going to crank up the health from 5 to 50 so I can shoot this guy a whole bunch of times.
Let's press play and try it.
All right, here we are.
I've selected the bee and moved the animator window down below so you can see what's going on.
Let's watch him do some animation.
Goes idle and then does his attack.
Oh, I just got hit by some lightning and lightning again.
Now he's going to move.
I'm going to shoot him a couple times and he does a transition.
Well, look like he's trying to do a transition.
Let's see.
He's going to do another shoot.
Let's jump up and blast him a couple more times.
So, we shoot him and he does do the transition, but look what's happening with the animations.
So now he's got that hit trigger.
He's going to go into idle, go into move, and then play hurt.
So he's actually waiting quite a while to make those transitions.
Now I don't want him to go from be blast into hurt because I don't want to be able to interrupt his blast and have it go into a hurt animation, but I do want the transition from idle and move to be instantaneous.
So let's select both of those transitions and uncheck the has exit time so that the transition will happen immediately.
Again, it still won't happen if we're in the attack state, but it'll happen immediately.
Other than that, we're now getting an error, and that console error that we saw a moment ago is the cause of this.
We've got an animation event that is not running anything.
And this happens a lot when you grab animations from other people.
So, it's important to know how to fix this.
All we need to do is go to our animator or our animation window.
I'm going to select this B.
Go find that new animation that we just hooked up because that's most likely the culprit.
It's the hurt animation.
And look right here, there's an animation event that has no function on it.
We don't need to hook this up to anything.
If I drag it over, you'll see that it's for this point when the B is kind of uh halfway through the hit.
I don't know what I would use that for necessarily.
So, I'm just going to delete it.
Go back into the console.
Let's stop playing and play one more time.
And now I should be able to run over there and have our animations look proper.
There we go.
would run, jump, blast this bee in a moment once he starts gets on screen.
There we go.
Shoot him a couple times.
See, he's taking hits.
Taking hit.
Taking hit.
Taking hit.
Taking hit.
Taking hit.
Keeps taking hits.
And there we go.
He's dead without ever actually hitting me.
Now, how is this happening? Let's take a look at our animator one more time.
If we scroll down and look at the transitions here, our idle to attack animation requires the fire condition.
Our idle to hurt animation requires the hit condition.
So let's see what happens when both of those conditions are set to true.
So I've checked them both and we'll just skip through one frame.
Here you see I've clicked and the hit trigger is off and we've started a transition into hurt B.
So why is that happening? Why is this transition happening? instead of this one.
There actually two causes to that.
The first is very simple that our has exit time is checked here.
So our transition into attack can't happen until after our idle has finished.
Which means that our hit that doesn't have a has exit time can happen immediately and we'll get priority.
So first we can just uncheck has exit time.
Let's check both of these again though because that may not fix our problem.
Let's hit play and click them both.
If I can click them both fast enough.
wait for after the attack and see what happens if he attacks again.
Oh, he went into an attack again.
Now, there is a scenario where he may not attack again.
Let's take a look at the animations again.
If we select the idle state, you can see here we've got a bunch of transitions and this shows which transitions take priority.
If I move the hurt B up above the attack blast and then check both of these, watch what happens.
Now, it goes into hurt B first instead of going into fire.
and we get that big long weight.
So, we also need to make sure that our transitions are ordered properly.
We'll select the idle estate again and just make sure that hurt is probably um well, actually, I think we want attack all the way up at the top and then hurt and then move.
That looks like a good set of transitions.
All right, now that we've got that set up, let's go back and try it one more time.
We'll press play.
Remember, we've moved that has exit time from the transition out of attack and we've rearranged these transitions a little bit.
We'll go shoot this bee.
Let's go blast him.
Can't hit him when he's blasting, which is exactly what I expect.
Let's blast him again while he's moving.
Oh, did I get him? I am terrible at hitting this bee.
There we go.
Got a couple hits in.
And now the shots start to go through him once the animation begins.
And he's firing back.
All right, that's looking good.
Before we go any further, let's save our scene and commit our changes.
Here we've added the be hurt animation and well, I just added be hurt animation and check in.
Now that our bee can take hits and show those animations properly, let's finish up as death and create an actual death sequence.
We've got our animator tab right here, and we need to add in the death animation.
First, let's go to the project view and take the dead bee animation and drag it right up here to the top right corner.
I want to be able to transition into death from any one of these three states.
Either attack, idle, or move.
If we're in hurt, we'll go back into idle and then straight into to dead as well.
So, let's do transitions by right-clicking and hitting make transition and dragging one from each of these three points up to dead.
Next, we're going to add a parameter.
And we're going to add a dead boolean here.
You can see I've already added it.
I'm going to delete it and read it again.
You can just name it dead.
And the reason that I want this to be a boolean is pretty simple.
instead of a trigger.
And that's I want to be able to transition back from dead into idle and bring my be back to life if I want to do some testing or I want to reuse this character.
So to do that, I'm going to rightclick and make another transition back into our idol from dead.
But first, I need to well actually after I need to go in and add in all of my conditions.
Let's start with the exit out of dead.
We'll go select it and choose the condition that dead is false.
For the transitions into dead, we'll select them and choose the condition that dead is true.
But we're also going to uncheck has exit time because I don't want the full idle animation to play or the move or the attack to finish.
I want dead to play automatically if we die.
Let's go to the next transition from move to dead.
Add in our condition of dead equals true and uncheck has exit time.
And the same from our attack.
We'll go choose dead equals true and uncheck has exit time.
So now we should be able to set the dead state on our B and have him switch into that animation.
To hook that up, we'll go back to our take damage method and let's just replace the set active with a B animator.
Let's just replace that B animator set bool.
And we're going to set the dead boolean to true.
We'll save.
And then let's jump back into Unity and go try it out.
I'm going to make sure the bee's health is down at five.
so that he's nice and easy to kill.
Go blast him a few times and then let's see what happens.
Go shoot him.
Here we go.
All the way down here.
And he's dead.
He plays his death.
And uh it looks like it it actually worked.
So, he died, but he's not doing exactly what I want him to do.
I also want him to fall down to the ground.
And I want all of this lightning to turn off.
I want to make sure that he's not moving around.
He's not moving because of his rigid body, but I want to make sure that the lightning and everything, all of my scripts are turned off and that he drops down.
So, let's go into our B.
First things first, I want to give him a rigid body so that he could drop down.
So, we're going to go to the base part, the part that has our animator.
We're going to give him a rigid body 2D.
I'm going to set the body type to kinematic so that he doesn't fall automatically on his own.
And I'm going to freeze the rotation and position so that he can just drop down.
Oh, let's just freeze the rotation.
Actually, I don't think I want to freeze my position.
I'm just going to freeze the Z rotation so he doesn't spin around when he drops.
He's not going to drop yet, though.
Let's save and go into our B encounter and hook that up.
So, we'll go to our B encounter script and we're going to expand out this bit of code here.
We're going to add in some braces and instead of just setting our character to dead, we're going to stop our co- routines.
So, we'll do stop all co- routines.
That's going to stop the two co- routines that are running on our B encounter.
If we go up here in our on enable, right now we're turning them on.
We get to move these to the end of our intro, but for now we've still got them in on enable.
And this will turn off both of these.
So our movement code will stop.
Stop moving our character around and blasting lasers.
We definitely don't want that happening.
And our lightning will stop as well.
That's kind of the behavior I want.
The other thing I want to do though is stop our rigid body.
So we're going to say underscoreb rigid body.
I say stop.
I really activate our rigid body.
And we're going to want to set its body type.
We don't have a reference to it though.
So let's copy this.
Go to the B animator by Ctrl + left clicking.
Duplicate it with Ctrl + D.
Ctrl +V to double click.
Crl + V to paste and get our B rigid body.
And then make this a rigid body 2D.
We'll go back down to our code on take damage.
This is line 157 for me right now.
And we'll set the body type equal to and we want this to be dynamic so that it will fall on its own.
Now we can save.
Let's jump back into Unity and try it out.
Before I press play, I've got to make sure that I assign my rigid body or we're gonna end up with a bunch of errors.
And I'm going to turn this health down to five again before I play.
So that way I don't have to keep remembering to do it.
Let's now jump in there.
I should be able to blast this guy and watch him hopefully fall right down into the water.
Let's see.
There we go.
He falls down and now he's just bouncing in the water.
That is exactly what I wanted.
There's an issue though.
Take a look at this.
I can stand on him and I can't really walk through him.
What if he is in the way? What if he lands somewhere important? Let's take a look at our B real quick.
Let's just drag his position over here.
What if he lands like over there? Well, then I'm kind of stuck and I can land on him and bounce around him, but I can't move.
So, I can't walk because he's not counting as grounded and I'm slipping off of him.
And really, I think I'd like to be able to walk through him.
And I think we'll deal with that in the next section cuz that's going to be a slightly more complex thing.
Let's go into plastic for now.
Make sure that we've saved and say that our bee falls to his death and check that in.
Now, let's take a look at our dead bee and the collisions and see what we need to address.
Still, if I run over here, you'll see that I still can't go through the bee.
I can land on it and I can't really walk because I don't think I'm getting counted as grounded.
If we go check our character, let's go find the player, we should see that I'm guessing is touching right wall is true, but oh, is grounded is true.
Good.
So, I can keep jumping it at the very least.
But I can't move left and right because it thinks I'm on a wall.
I can't walk through it either because it thinks I'm on a wall.
And I can even blast it and knock it over to the side because it's not locked in position.
So, what I want to do now is make it so that my bee doesn't get interacted with by the player or the player's bullets, but I still want it to be able to fall to the ground and do all of the the typical physics stuff so that it's there, but it's not interacting with the players just with the world geometry and I can walk through it.
And to do that, we're going to need to add a new layer.
What we'll do is set all of our B here to be on a layer that's maybe for our dead objects that doesn't interact with our player.
Let's start by adding a new layer.
We're going to go to the layer dropdown and hit add layer.
It doesn't matter what object you select because that just opens up the tags and layers inspector.
Doesn't actually change the layer of the object we're on.
We're going to add a dead layer here.
And then we're going to go into our code and set the layer to be dead whenever our character dies.
Before we do that though, let's make it actually do something useful, having it on a separate layer.
And to do that, we're going to go to window or edit, not window, and then project settings.
and we're going to find our 2D physics collision matrix.
If you haven't found it yet, it's find physics 2D, not regular physics.
Go off of general settings over to layer collision matrix.
And we want to uncheck dead and player.
Ah, looks like I've already unchecked it.
Just make sure that it is unchecked so that dead things don't interact with players, just like player bullets don't interact with players.
Remember, the player bullets are on that player layer.
Now, let's set our character colliders to be on that dead layer.
To do that, we'll go into our take damage method and we're going to just find all of the colliders.
So, we'll say for each var collider in get components in children.
Let's find the plural one.
And we're going to do collider 2D.
We don't care which type of collider it is.
And really, we're not worried about the performance characteristics of this because it's only happening once when the thing dies.
It's not going to be enough of a hit to make any difference at all.
So once we've got each collider, we'll just tell the collider to have its game objects layer be set to layer mask dot and we want to use name to layer, which is going to take a name and then give us back a layer mask.
So it's not actually the layer number, but it's the mask or the bit mask for that specific position.
And we're going to give it the layer name dead.
We'll save that off and let's go back into Unity and see what this does.
You might be a little bit surprised.
All right, we're back in.
We'll run over here.
Let's blast this bee.
Make him fall to his death.
And check it out.
So, here I still can't run through him.
But watch what happens if I jump.
I don't land on him either.
And now I'm stuck inside him and can't move left or right.
Let's get back on there one more time and see why that is.
So, if you look, when I'm standing inside, it still thinks that I'm touching walls on the left and right.
So, even though the collider is not colliding with my player, the code that's checking for wall touches is detecting a collision.
Let's go take a look at that code one more time.
So, we're going to find the part where we're touching and that's checking for wall right here.
If we go up the call stack a little bit, let's just go find it again.
I was already there, but is touching right wall.
If we look for that, it's called or set by calling check for wall, which then goes through and does our raycast.
And it does a raycast against a layer.
And our layer is probably set, right? If we go back in here and we look at our layer mask, see that? Yeah, it shouldn't be interacting with player or dead.
So, what's the problem? Well, take a look at this code right here.
The issue is actually on line 117 or 117 to 121.
And what I want to do is present a small challenge.
See if you can figure out why this isn't working.
It's a relatively small problem.
It's a small solution and it's right here in the code.
It's just something that needs to be modified or added.
So, go ahead and track it down.
see if you can figure it out and then continue on and I'll show you the solution.
All right, I'll assume that you've either found the solution or just want to continue on.
The problem is that we're using a layer mask, but when we use a contact filter 2D, it has all of these use options that are boolean toggles like use layer mask, which is defaulted to false.
There's use triggers, use angles, and um use depth as well.
We're going to just enable use layer mask though.
Now, that also means that the other place where we're using a contact filter 2D, if it's using a layer mask, which it is, should probably also have use layer mask set as well.
So, we'll say use layer mask in both of those.
Do a save and a build.
And that was for our check grounding.
So, it's technically allowing us to ground on things that weren't in our layer mask.
Now, if we come back into Unity and kill this bee, let's give him a couple more shots.
I should be able to walk through him, jump through him, and everything else.
and even shoot blaster shots right through them.
That's exactly the behavior that I want.
Now I'm just ready for them to start floating in the water.
Let's go to plastic and commit our changes first.
Make sure I've saved my scene and so that the oh cuz there we go.
We got our B our tag manager and our physics settings and make sure that those are pulled in.
If you don't see those, go to file and do save project as well to make sure you force those.
and say B death now doesn't or let's say B switches to dead layer when dying.
I'll understand what that is and check it in.
Now, we're going to add the last piece of our boss battle.
We're going to set it up so that when the bee gets to about 50%, the entire ground floods and the player can no longer land on the water or land in the ground.
they land in the water and get kind of pushed around.
Let's start by just adjusting the environment.
The first thing that I want to do is take my ground that's right here and just kind of lower it.
Actually, let's lower the water first.
Let's select the water object here.
I'm going to move it down about 1 meter.
So, hold control and drag it down.
I'm going to take this one that's right at the beginning.
I think I'll go down about one so it's at 5.5.
And then I'm going to hit T and make it wider.
So, hold control and drag all the way over so that it's the same width all the way to the edge of this.
What we're going to do is have this one water object come up and kind of take over the ground.
Now, we need to expand out the child as well.
So, I'll just click on it and select it, holding control, drag it over, and get it into position.
It's a lot easier to do it this way than typing in the numbers there.
And then I'm going to make my water a child of the B encounter.
So, I'll drag it down here.
Since it's part of this encounter, I'm going to make it a child of that encounter.
Next thing I want to do is drag my ground down.
I've got this piece of ground here, and I want to kind of give the player a little bit of an indicator that something's going to happen here.
So, we're going to move this piece down.
Oh, let's hit W and just drag it down until maybe about just the top is there.
So, is this about a negative 5.25? So, I think we went down about 75.
I think that that's probably a good height except now the grass in the background doesn't line up anymore.
So, let's just grab it.
And we've got a couple options.
I could put in a sprite here that kind of fills and matches that color.
But, I think I might just grab this background and move it down one on the Y instead.
So, just do like a negative one on the Y and get it down there so that it's below.
And then if I have other things at this kind of level, they'll be fine as well.
Let's now remove that second water.
So, I've got a water that was over here to the right.
I don't need that anymore because the water now extends to it.
And I can see here that I actually need to move this background down just about maybe 0.25 more.
So let's go to one negative 1.25.
It's just right below that waterline.
Once I've got this lined up and had a solid position for it though, I probably wouldn't drag it down and we just add some green sprites.
But for now, I think that it's fine.
It doesn't really lose anything there.
We're still getting a good background view and everything looks right.
The top here, however, I don't like.
Right now, we have this big blue, this uh I for it was a corn something blue.
Whatever it is, it's a blue that doesn't match our sky.
So, let's go fix that real quick before we continue on.
We're going to go find the player, not the player, the camera system.
Go find our multiplayer camera setup and go find the actual camera here.
And then underneath the camera, we can find the environment section.
Remember, we've got a URP camera, so it's slightly different than the built-in one.
And we got to find environment and change the background type from skybox to solid color.
Use the color picker and just go pick that color.
And tada.
Now we've got our nice, beautiful sky.
All right, let's get back to our water.
So here's our new water leveling game.
It's a nice drop down from the cliff.
And then we've got this little ledge that we can walk along.
And now the goal here is going to be that when the bee gets to 50% health, this water rises up and starts flowing and pushing the player in one direction or the other.
or you could even make it alternate directions.
Since I want this to start when the bee gets to 50% health, let's begin in the take damage method.
We'll do a check after we've taken some damage to see if our health is at exactly the 50% mark.
So we'll say if underscorehealth is equal to and now we need to figure out half of our max health.
And right now we don't have a max health.
If we look at our health, that's our only field.
So this is the one that gets serialized and it's the one that we use as our temporary variable.
This is a temporary thing so we could see it and adjust it.
Let's make a change now so that we have a maximum health and a current health instead.
So the first thing we'll do is rename health to be current health.
Find that it's a lot easier to understand which one it is if you put the word current there instead of just having a health and a max health.
Then we'll delete that public keyword.
I'm going to copy this line.
Just copy and then paste it right up here.
We'll add a serialized field attribute and then replace this with max instead of current.
So it's a max health and I'm going to set it to 50.
Now we don't want to necessarily set the current health right here.
I want to make sure that's being set somewhere else.
So I'm going to just remove that initialization and then do it down here in on enable when our character starts.
So say current health is equal to our max health.
Now we can go back to our take damage and we can finish that check.
So if current health is equal to and here we'll do our max health divided by two.
So if we're at half health then we want to start this flooding.
To start the flooding let's do a co- routine.
We'll do start co- routine and we are going to call this maybe start flood but then we're going to need to stop a flood too.
So let's maybe call this toggle flood and then pass in a true.
So we're going to turn the flood on and then we'll be able to turn the flood off as well.
Let's generate a method for toggle flood.
Hit F12 to go to it.
And then change that return type to be an ie numerator.
We're going to need a flag here that's better than in v.
Let's say um enable flood instead of v for our variable name.
For our initial implementation, let's just move the object or the water up or down one meter depending on if we've enabled it.
If we enable it, we'll move it up a meter.
If we've disabled, we'll move it down.
And that'll be our our starting version of this.
So we'll say um target let's say var target water y equals and if we're enabling the flood we want to do our current y + one or plus vector 2.up.
And then if we were doing it down we'd want to do minus one.
So we'll say it's equal to our if we're enabling flood it's going to be our transform.position.y y y y + one.
Otherwise, it'll be a transform.position.y minus one.
There we go.
And then we'll just move our transform position to that.
So, we'll say our oh, we need not our transform though.
We need our waters transform.
So, let's get a water reference.
We'll add a public water_water.
And then we'll replace transform with water.transform.position.
There we go.
So this is going to give us our target y position for this new water.
Then we'll set the water's position to that.
So say water.transform.position equals a new vector 3.
And we'll just give it our current position.
So water dot or no, we need to give it our yeah water.transform.position.x the wrong words there.
And then our target Y.
That's what we want.
And then our water transform position Z.
All right.
So that should instantly move our object up, but we're in a co- routine and we're not waiting for anything.
Eventually, we're going to want this to go over time so that it floods up kind of slowly.
So let's just add a quick yield return null.
Go assign our water.
Make sure that works.
And then we'll continue on.
All right, we're back in Unity.
So we'll assign that water transform to the water.
It's actually a water object.
And then save.
And if I press play, I'm going to have to go blast this guy 25 times to get his health down.
So, let's add a little shortcut down here at the bottom of our B encounter.
Let's add a method that sets our character or our be to half health.
I'm going to call this method half health.
We'll call void half health.
And then in this, we'll set our character's health.
So, we'll say underscore current health equals max health divided by two.
And then we'll just add one.
So, current health plus+.
I could also say it equals max health divided by two plus one, but this is a little bit easier for me to read.
We'll add one and then we'll tell it to take damage, tack damage, take damage, so that it'll actually call the take damage method and go down to that exact amount of health.
Now, I want a context menu to be able to call this.
So, I'll say context menu and put in name of and put our half health right here.
Now, I also kind of want to be able to um kill this thing.
So, let's just copy this method and add a method for killing them as well.
So, say kill and we'll change the method name here to be kill as well.
And we'll set the current health to one and then tell it to take damage.
And then finally, let's just do like a full health restore.
So, let's say uh full health and I'll paste that in.
And here we'll just set the current health to max health and do absolutely nothing.
All right.
Now, we'll go back into Unity.
All right.
And here's our water.
We're in it.
Let's move it up by moving that B.
We'll say half health.
And you see the water pops up and gives us this this nice risen water that's over the ground.
All right, that's close to what I want.
Let's make sure that we can now drop it down.
So, we'll say kill.
And see that the bee dies, but it didn't actually kill.
Um, it didn't it didn't get rid of the water and it's still acting up a little bit.
So, let's go adjust that now.
Let's go back into our B encounter and then when we take damage here, if our current health is less than zero, let's call the co- routine to turn the flood off.
So, we'll say start co-outine toggle flood false.
Now, I don't want to do this right here because if I do this on line 161, look what's going to happen.
line 162 is going to stop that co- routine.
So, what I actually want to do is cut this, move it down one line here, and then remove that.
So, we're going to stop all of the existing co- routines.
Those are the ones for moving and shooting.
And then we're going to kick off the flood disabling co-outine when our bee dies.
Let's save, go back in, and test it out.
All right, here's our bee.
Let's put it to half health.
We see the water goes up.
Be should still be kind of flying around over here.
And if I right click and kill the bee, he should fall to his death and the water drops back down.
All right, this is looking good.
I'm going to go into plastic now.
Make sure that I've saved my scene and commit real quick.
Added be water that instantly raises and lowers.
And check that in.
Now that our water works, it's time to smooth it out.
We're going to make it so that our toggle flood method will slowly rise or lower the water depending on if the flood is being enabled or disabled.
We already have a co- routine here.
So, we're just going to need to add in a while loop and smooth out this movement.
So, instead of just snapping to the new position, we'll move over time.
This should be a relatively easy problem to solve, but since we're going to go in two directions, it's going to get slightly more complicated.
The first thing that I want to do is just cache this initial position here.
the position that we're getting for the Y because I want to be able to lurp from that position to my target position.
And if I don't cache it and I keep moving my Y position, then that value is going to change and I won't be able to do my lurp properly.
So, I'm going to cut this and call this initial water Y.
I'll add a variable up above, a float initial water Y.
Well, not W equals transform.position.y.
I'm going to copy that and replace the other instance where I'm grabbing that y position.
And then I'm going to change this to be a float instead of a var so that the names and the parameter lengths match up.
Actually, I don't need an underscore here.
I don't know why I added one.
So, I'm going to remove that.
It's just out of habit.
I automatically started typing an underscore.
So, now I've got my initial Y and my target Y.
And what I want to do is loop over them or loop for a certain amount of time and move from that initial Y to the target.
So, we're going to add a couple of fields.
First, we'll add a float for our duration for how long we want it to take to loop.
I'm going to make that 1 second.
So, just do a 1 f.
And then, we'll add a float for our elapsed time.
So, call this elapsed elap sed.
There we go.
Time.
And we'll set that to zero.
We'll add a while loop.
Look at that.
It's going to automatically autocomplete that for me.
And while elapse time is less than the duration, we want to well of course increment the elapsed time.
And then we want to move our object towards that new y position.
So let's take this vector 3 part of line 186.
I'm going to hit shift and end to go to the end of the line.
C to copy it.
And up here on line 84, I'm going to say var destination equals and paste.
So this is going to give us our destination for where we want to go.
Now, I don't want to necessarily go directly to that target Y.
So, I need to figure out my Y value for this current frame.
We're going to start it off at the initial Y and then move towards that target Y.
So, let's create another float.
We'll say float Y equals.
And here we're going to use the lurp method.
So, we use math f.lurp, which is going to interpolate between our start value and our ending value.
We'll give it the starting Y, our initial water Y, and then we'll give it our target water Y.
So this is the initial y value and the target or the ending y-value.
So imagine this is going to be if we jump into unity.
We've got this y at 5.5.
So it's going to go it's going to go from that to like a negative uh 4.5.
So it's going to raise up.
So let's go back into the code.
And then here we need to give it our elapsed.
But I don't want to use elapsed time.
So, if I use just that elapse time like it recommended, then what we're going to end up with is we won't be able to do durations greater than one because it's going to always do it at one and it's going to ignore our duration completely.
So, what we need to do instead is figure out a progress.
So, we'll add another variable up above float progress and it's going to be equal to our elapse time divided by our duration.
And then we'll put in our progress right here.
Finally, we'll set our destination's Y value to that Y.
Well, actually, we'll add a semicolon first.
Then, we'll set our destination's Y value to that new Y that we've calculated and then move our object to that destination.
So, we'll say water.transform.position.
Let's just copy that.
Paste equals destination.
Now, of course, you could shorten this down into less lines, but I feel like having it split out makes it a little bit easier to see what's going on.
The last thing I'm going to do here is just delete line 189.
and it snaps it to the target position.
I don't necessarily need that, so I'm just going to take it out.
Although, you could leave it in if you want to make sure that um it ends up at that position at the end, but it's going to end up at that position at the end either way.
So, I don't necessarily need it.
I'll just delete it because it's extra code that's not really going to make a difference.
All right.
We also want to move this water because our water is a public field that's down here at the bottom, not a serialized field.
So, I'm going to cut it.
Delete that extra space.
Go up to the top and let's add in a serialized field for our water.
So, add water.
We'll add the serialized field attribute.
Save.
And do a quick build.
Oh, before I can build, I've got to add a semicolon to the end of that line.
Let's do one more build.
And that should be a successful one.
Build succeeded.
And we'll go back to Unity.
So, now we'll play and watch what happens when we set it to half health.
Well, it instantly popped back up.
If I set it to kill, it instantly pops back down.
So, let's take a look at the code one more time and see if we can figure out what's going on.
What I want you to do now is just evaluate this code.
Look at the toggle flood and see if you can figure out where the issue is.
Why is it not smoothly moving up? Why is it snapping into position? Go ahead and evaluate this code for a minute or two or however long it takes and then continue along and we'll dive into the solution.
All right, hopefully you found the problem already.
It's actually a really simple one.
We're in this while loop and we're running through elaps modifying our elapsed code or elapse time, incrementing it by timed delta time, continuing on the progress, moving our y up, figuring out the destination, and then moving and then we continue on and do the same thing again and again and again.
And once we're done, we wait for a frame.
See the problem now? Well, the problem is pretty simple.
We just need to wait for a frame after each movement.
We're doing all of this movement in one frame in one go and then it's just snapping our object up.
We've got to move that yield return null right here so that we can let a frame complete and pass before we just run through this loop.
This happens all the time in co- routines with while loops.
You forget that yield and usually you'll end up with a crash or something else if it goes on indefinitely.
But luckily this one has a time limit of 1 second so it kind of ends quickly and can't crash it for us.
All right.
Now, with that in, we should be able to jump back into Unity and see our water move smoothly.
All right, here's our water.
Let's go jump in it.
In fact, let's go stand on the platform here and set our character to half health or our B to half health.
And okay, now I'm floating and see that the ground is still a little bit high here.
I'm still kind of able to touch it.
And I don't really want to move it.
Instead, I think that the best solution here in this case, let's go look at it in the scene view here.
We've got this ground piece that's just kind of right down here below.
It's not that one.
Let's see if I can find it.
We'll go select the ground piece real quick and then show the solution.
So, we got to go find it in the environment here.
Let's just turn off the water.
Easy way to do this.
Go select that object.
And right here, there it is.
This is the grass that I'm worried about.
Oh, I've already moved it to my B encounter.
So, make sure that you move your grass mid underneath your B encounter here.
This looks like mine right now is named grass mid6.
Let's modify it real quick.
So this is the grass that's that blank platform.
Let's call this a flood ground platform.
And then let's go make our collider for this object turn off when our flood waters rise and turn back on when our flood waters go down.
To do that, we'll go back into our B encounter and we're just going to add a reference to that collider to the flood ground platform.
I think instead of typing out the reference, I'll just do it right here at the beginning or the end of toggle flood.
I'll say underscore flood ground platform.
Let's call it flood ground collider enabled equals enable flood.
And then we want it to actually not be enable flood.
We want it to be the opposite of enable flood.
So we'll add a not sign.
I'm going to add a reference for our ground collider.
Let's go duplicate water.
Put in the name floor ground collider and change this to collider 2D.
2D.
There we go.
Got no S, not 2Ds.
It's just 2D.
All right.
Now, I should be able to Oh, should be able to build once I put the D at the end of enabled.
All right.
Back in Unity, we'll assign that platform here.
So, we can turn the collider off.
Save.
And let's go try it out.
All right.
Here we are.
We'll jump over here to the platform.
We'll set the B to half health.
And now I am definitely floating around.
See that it's definitely it's going to get more difficult for me to move.
Ah, hitting my head on some lasers.
And I think uh things are looking pretty good.
Let's say that the bee died.
We'll set the be to kill.
And the water goes back down.
Um oh, we don't turn the collider back on, though.
Oh, actually, we do turn the collider back on.
But check this out.
Look at the platform real quick and tell me if you see anything obvious that stands out that could be the issue.
If you see right here, the platform got set to the dead layer.
So, our character can't collide with it.
Also, I can't jump anymore because it's not detecting that I'm in the water because I kind of fell in when it was dropping down.
So, we're going to make two quick changes.
The first one is a fix for the layer.
So, we don't want to be setting our layer to dead on all of the objects inside of our B encounter.
We only want that to happen on things that are inside of this Broot object.
Let's go back to our B encounter and see the part where we set that layer.
So, you see here in take damage when we die.
Let's add a little space there.
When we die, we loop through all of the children components that have colliders or all of the child colliders and we set them all to that dead layer.
But we don't want to do that for the B encounter.
We just want to do that for the actual B object.
So, if we add an underscoreb dot at the beginning there, that should fix the first issue.
The second issue is not any harder to fix.
When we're in our water and we're doing our raycast down, a lot of the time, our character's raycast is starting right down here and shooting into this object that has absolutely nothing.
Because of how tall our character is and where the buoyancy is, there's a good chance that it shoots down into here and hits this collider on our water bottom that didn't have a collider.
So, I've just added a collider to it.
Go add a box collider yourself and then make sure that you check the auto tiling so that it fills out the entire area.
Otherwise, you just end up with a little collider there in the middle and it's not going to help.
So, let's press play and try it out.
Here we are on the platform and we'll set the B to half health again and see that we're now floating around.
I can run, I can jump, I should be able to keep jumping multiple times.
It doesn't just reset.
And once I kill that bee, I'm in dead zone.
Let's kill him.
I should be able to still use colliders.
I can land on platforms and everything else.
All right, let's stop playing now and commit our changes.
First, we'll save our scene that we smoothed water rising and falling for B encounter and check it in.
To make the water part of our B fight actually difficult, we're going to make some changes to the way that our player handles water movement and water detection.
Specifically, we're going to make it so that when you're in the water, the water can push you around, but you can't move left and right.
You have to jump out of the water to be able to well move left and right.
So, how are we going to do that? Well, we're going to make a couple changes to our player script and a tiny modification to our water.
And then eventually, we're going to also update the sprites so that the water flows visually as well.
We're going to start by detecting when our player is in the water and caching that as another bool field here.
So, we'll duplicate the is on snow and change this to is in water.
And then let's scroll down to the part where we actually look for water.
Right now, currently in our check for ground, if I just search for water, there you go.
See how on line 249, we check to see if we hit a water trigger and then continue on so that we can try to mark ourselves as grounded.
Let's not do that anymore and add in a new little call down below so we don't have to have this get component call on every single collider when we're checking our ground.
This is probably the worst part of our code for grounding right now.
So, we're going to delete that out and we're going to add in a new set of lines right below.
In fact, let's delete out this extra debug line as well.
And what we're going to use is the physics 2D.
So, here, let's say var water equals physics 2D, if I can find the word physics 2D or spell it right, do overlap point.
And that's going to give us back a point or any colliders at a specific point that match our layer mask.
That's not this overload, but once we give it the correct overload, we'll see that happen.
So, we're going to give it our origin where we're checking for ground.
And then we're going to give it a layer mask.
Let's call this water layer mask.
Add a semicolon here.
And then we're going to generate our water layer mask.
Actually, I'm going to copy it.
Control leftclick on layer mask.
Go up here, duplicate, and paste.
I want those to be right next to each other.
All right, let's scroll back down or hit the back button.
There we go.
There's our water.
And if we get a water object, so if water is not equal to null, then we'll just say is in water is equal to true.
Now, if we're in water, I want that to allow us to jump as well.
So, let's start looking for our grounding code.
Let's go do a quick search for the checks for we see if we're grounded.
So, here you'll see see uh is it this one, right? Nope, that's jumps remaining.
Ah, okay.
So, here we get our jumps remaining and we do that with our grounded.
I also want to just set our jumps remaining to true if we're in water or if we're grounded.
So, let's make this an statement where we say if is grounded or is in water.
Whoops, that's not in water.
In water.
And then we're going to put that in the parenthesis so that this will get evaluated with the or.
If either one of them is true, it'll continue on and then evaluate to make sure that our rigid body's velocity is going down.
So, if we're in the water and we're headed downwards, we're going to set our jumps remaining up to two.
Now, I don't know why we're calling get component on our rigid body.
Let's cache that or use the cached version of it RB to optimize our performance there.
Now, we're also going to need to look for the other places we set is grounded to false, for example.
So, right up here, we'll say is in water is equal to false.
And let's just do a quick check to see if there's anywhere else that we need to address it.
So, we do shift F12.
You see that we set it we set an animator here to jump if we're not grounded.
That I actually don't want to happen when I'm sitting in the water.
So, that's actually perfect.
And uh the only other scenario is that yeah, we set it back to false and then we set it to true.
So, that should be good for allowing us to be grounded when we're in the water.
But that's not the key thing that I want to do.
What I really want to do is make it so that if we're in the water, we don't use our horizontal velocity at all.
And we just use whatever the existing velocity was.
So, we're going to add a line here right at right at what is this going to be? 211.
If is in water.
So, right at the end of our movement code, then we're not going to do this.
I'll duplicate the line though and add an else statement.
Instead of setting our velocity to the horizontal and the vertical, we're just going to set it to the underscore rb.vlocity.
velocity.x and the vertical.
So, we'll keep the velocity on the X exactly the same if we're in the water, but we can still jump out by using the vertical.
Let's hit control KR D to fix up that formatting.
Save and go try it out.
We're back in Unity now and need to set a layer mask for the water.
I'll make sure to save and override.
Let's do an apply overrides on it and save one more time just so we can make sure that our prefab has that water layer set.
And then we'll play and run over to the water.
So we go get in the water and I can still move left and right.
Let's check if my in water state is true.
So in is in water is not true.
If I check it obviously it gets set to false.
Now what's going on here? If we look at our scene view and go find our character and see that these are the origin points where we're doing our overlap check.
Let's take a look at the water there.
So I select this water object here.
You see this has a box collider not on the water layer.
This is actually that bottom part and it's not set to a trigger.
Let's look at the top water.
The top water oh is actually also not set to the water layer.
And uh it's other than that it looks like it's good to go though.
So let's make the changes real quick that we need.
So we'll stop playing and first thing we're going to do is set our water to a water layer.
Go to water right there.
And then the second thing we're going to do is go to our water bottom and we're going to change this to be a trigger.
And I'll show you why.
Let's um do it in play mode first.
Well, the one of the reasons is so that our code hits and lands and looks right, but also so that when we float, see how we're kind of standing up a little bit.
I hit is trigger, and now we're actually floating down into there.
And let's go check out our player.
Our player is now in the water.
So, I can't move left and right really.
I can jump and move around, but moving left and right doesn't work.
Now, how is this going to be interesting? Uh, you should be able to move a little bit, right? Well, what we're going to do instead is use the water and we'll use thatctor that we have, our buoyancy.
Go find it and expand out the flow and we can start giving it now a flow magnitude.
So, if I want it to push enemies toward or push the player towards the enemy, I can give it a value that's positive and it's going to push them over to the right.
So, let's stop playing and make both of those changes outside of play mode.
So, we'll go back to our water, choose that water bottom, and make sure autotiling is on, is trigger is on and everything.
And make sure that our object is set to the water layer.
I'm going to save my scene, and then let's open up the water script.
Let's add a new method in our water to set the speed of its buoyancy.
So, we'll do a public void set speed.
We'll take in a float named speed, and then we'll just get our oops, I got an extra parenthesis there.
We'll get our buoyancy.
Get component buoyancy.
B O U Y B U Y.
There we go.
Buoyancyector 2D.
And we'll set the flow magnitude equal to our speed.
So that we can turn this on and off or set the direction externally.
And we're going to do that from our B encounter.
So let's go back to that B encounter.
And inside of our B encounter, we've got a reference to our water.
and we set it and turn it kind of on and off here, moving it up and down.
But let's also just set that speed depending on what our enable or disable state is.
So we'll say underscore water set speed and I want this to go off to the right somewhat fast.
So we'll say enable flood.
Then it'll be a 5F.
Otherwise it'll be a zero.
So it's going to set it to either five or zero depending on whether or not we're enabling the flood.
Let's do a quick save.
do a build and jump inside and try it out.
All right, here we are.
We're in the water.
I can't really move around.
I just kind of float.
I can jump get over to where I wanted to be.
I think I'm going to get over here and just blast him a whole bunch.
Oh, he's invulnerable while he's shooting.
See if I can get a whole bunch of shots off on him real quick.
Kill him for real without having to cheat.
Look at that.
There's the water.
Okay, I can It's pushing me.
It's pushing me.
Oh crap, I died fast.
Okay, well that seems to be working.
I'm going to test it one more time, though, just to make sure that the behavior is right.
Uh, so it was kind of a quick test.
We'll go to the B encounter now that I've got my hotkeys here or my shortcuts.
We'll do half health.
Bam.
Should be getting pushed to the right.
I can jump out and I can move left and right when I'm in the air, but when I'm in the water, I'm just getting forced over to the right nice and slowly.
It could probably speed that up, crank it way up if we wanted to make it more difficult, but I'm good with that for now.
And I'm going to go into plastic and commit our changes.
So, we'll go back to plastic and make sure we save the scene and say that B water forces player B water moves player uh let's say player handles water properly and B water flows to the right when flood starts and we'll check our changes in now that our water is pushing the player.
Let's make the visualization on the water match up as well.
We're going to animate the sprite and have it slide off to the right so that we can have it look like the waves are actually waving.
Let's do this manually real quick and see what that would look like.
So, I've got my water selected here.
I'm going to collapse out a couple of these properties or these components and expand out our material here.
So, what I want to do is be able to adjust this offset right here.
Now, if I just go in and try to change it, you'll see that I can't actually modify this offset.
If I create a new material, I can modify this offset at runtime.
Let's do that real quick.
I'm going to do it, but you don't do it.
Just watch along.
I'm going to delete it and show you right afterwards.
So, we'll create a new material right here.
I'm going to call this water, and then we'll just assign it up here instead of using the default sprite.
So, go to the sprite renderer, and we'll assign that material.
We'll go pick the water.
Oh, looks like water already got picked.
And then we can now drag that offset.
And you can see that it will tile.
Although it does do a little bit weird, something a little bit weird, but it's sliding off to the left.
And it slides off to the right when I adjust this offset.
So, we're going to write code to adjust this offset.
But first, let's figure out why it's doing that weird thing.
So, if we pull this offset to the right, goes totally flat after one.
And if we pull it to the left, it goes totally flat after negative 1.
What's actually happening here is that our texture isn't set up for repeating or tiling.
So, if we click on our water top high, you'll see that the wrap mode is set to clamp.
If I switch that over to repeat and apply, I can now go over here and adjust this offset and watch as the water just kind of slides back and forth along.
Now, I don't need to create a new material for this.
So, I'm actually just going to delete it.
I'm going to go back here to my scripts, delete that water material, go back to my water here, and we'll just change the material from missing back to our default sprite.
Where was that? Ah, sprites default blind.
It was right there in front of me.
So, now that we've got that, let's go into our code and write the code to make that animation happen without having to do anything to our materials.
So, we're going to open up the water script, and I'm just going to start typing at the bottom of it.
I could add something into this water script to make it flow to the left.
But remember, I've only got the water script on the top level component, not on the water that's down below.
And I want this to animate for both of those water objects.
In fact, I want to animate for anything that could really animate a texture to the left or the right.
But for now, we're using it only for water.
So, I'm going to keep it named specifically a water flow animation.
So, I'll call this public class waterflow animation.
We'll make it inherit from a mono behavior so we can add it on as a component.
And then in the start method, let's add a start.
We'll just cache our sprite renderer.
So we say get component sprite sprite renderer equals get component sprite renderer.
We'll add a field for it.
And I'm going to add a require component attribute as well.
So say require component type of sprite renderer.
If I can spell sprite renderer right.
Okay.
RI T renderer.
There we go.
So that we have to have a sprite renderer if we're using this waterflow animation because it's definitely going to require it.
Now let's add an update method.
In the update method, we want to figure out what that new x value is going to be.
So we'll say float x equals.
And we just want this to be a value that changes over time pretty smoothly, but we want it to go from, you know, probably like a 0 to one or a one zero to negative one or or something like that.
So we'll say math f.re repeat and then we can use time time time and then give it our max value or the length that we want to repeat.
So we give it a one.
It's going to give us a value between zero and one over and over and over every single second.
Kind of like just getting the seconds.
We could of course multiply this and do some sort of a speed.
So we do times scroll speed and then generate a variable for that.
We could have that be a serialized field and then default it to one.
So, it's kind of the default, but then we'll be able to adjust it in the inspector and figure out a value that looks pretty good.
Once we've got that X value, we going to want to set that texture offset.
But the texture offset requires a vector 2.
It wants the X and the Y.
So, we're going to need to create a vector 2.
We'll call this offset.
And we'll assign it to a new vector 2.
and we'll give it the default or the value of x for its uh x parameter and then a zero for the y parameter because we don't want to offset the y at all.
And the final thing we need to do is call the sprite renderer and tell its material to set the texture offset to that offset value.
First, we have to give it the texture that we want to offset though.
And we're going to offset the main text, which is that main texture, and then we're going to give it our offset value and a semicolon.
We'll save that off, do a build, and then realize, oh yeah, we got to move this waterflow to its own file so that we can actually attach it.
So, we'll move it to a file.
Let's say move to waterflow animation.cs.
And then we'll jump into Unity and go attach it.
We've got our water here.
Let's go select the two water objects and add that water flow animation.
It should have a Let's go double check it.
It should have that one value.
So, I thought we had a uh Oh, I removed my serialized field.
Oops.
Let's go read that.
I copy pasteed and removed my serialized field for our scroll speed.
So, we can adjust that.
All right.
Here's our water flow animation.
By the way, on the water, I think I covered this, but just in case, if not, I did change out the polygon collider to a box collider because it just works a little bit better with these wavy shapes and end up with slightly better collision detection.
All right, so we've got our water flow animation.
Let's press play and play and see what happens.
We should expect to see our water now flowing off to the sides and then getting weird or not getting weird.
So, the water on the top is doing absolutely nothing.
Does it have the water flow animation? It does.
And the water on the bottom is animating, but it's animating incorrectly.
It's animating looping over that texture.
So, let's fix that first.
We'll go select our water and we're going to make it repeat instead of clamp.
So that water is looking good.
And then for that top one, it's probably actually working for you.
The issue is really simple.
I just grabbed the wrong sprite material.
So I need to find the sprites material that is the lit one.
There we go.
And now my water is flowing as well.
The speed is a little bit off though.
So let's stop playing and go fix those in edit mode.
So go sprites.
Okay, we'll just reset this sprite.
There we go.
Now it's got the correct material.
And I just need to adjust this tiling width so that it's right.
I'm thinking it's probably what, like 36ish, 35.
36.
There we go.
So there we go.
I've got my water stretched out properly and I've got the correct material.
And now if I press play, well, my Yeah, my water flow speed is as long as they match, they should flow nice and evenly.
There we go.
I've got water flowing off to the left.
And of course, I can also make it flow to the right.
So, let's change the scroll speed to negative one.
And we can see that it's going the correct direction.
So, I'm going to stop playing one more time, go back in and select both of these, set them to a -1 value for now.
And then we'll go to our water script and we're just going to tell our water to turn that component on and off.
So, inside of our water, when we set our speed, if the speed is greater than zero, we'll turn them all on.
And if it's less than zero, we'll turn them all off.
So, we're going to do another for each loop, and we'll say for each animator in well, let's let's call this uh let's call this WFA, waterflow animator, or I'm waterflow animator.
I don't really like shortening names.
In get components in children, waterflow animation.
Oh, yeah.
I guess that should be animation.
M match the name.
Oh, and we need our parentheses.
So for each of those, we're just going to set them enabled or disabled uh based on whether or not our speed is greater than zero.
So say water flow animation.
Oh, I need the var keyword.
And I'm missing all kinds of keywords and typos here.
Waterflow animation.enabled equals speed not equal to zero.
So we'll turn it on if the speed is greater than zero and off if it's less than zero.
That should allow our water to start animating automatically.
Um, but we do need to turn it off by default as well.
So, we should probably inside of our start for our water just tell all of these things to be disabled.
So, we'll add in a start method, loop through all of our water flow animators and set them to not flask false there so that they are not enabled.
And I'll delete out these extra braces because we just don't need them and they're making our file longer for no reason.
All right, we'll save and build.
Here we are back in game.
Oh no, I've messed up my layer on the on that front water.
Let's uh adjust that sorting layer real quick.
There we go.
Got my water layer right.
I should be able to run around and blast my bee.
Get that water flow going.
Now I've got a much harder fight where I can only jump in the ground or jump from the water.
And then I assume once I kill him that water is going to turn back off.
I don't know if this guy is still too easy or if I'm just really good.
There we go.
And the water has stopped flowing.
It's nice and chill now.
All right, let's stop playing.
Make sure that we've saved our scene and updated that player prefab.
I want to make sure there are no updates for it.
Looks good.
And then we'll make a commit.
So water for B boss fight is done.
And check it in.
Now we're going to work on persistence.
Our current game persistence setup works, but it's very basic, and we need to build something that's going to work for a large scale game.
something that'll allow us to persist all kinds of data and make it so that we don't have to write a bunch of code every time we want to add new stuff that's being persisted.
We'll make it so that we can persist things like the state of different collectible objects, the state of our different switches in the game and other things in the game, as well as our players position and location, maybe their velocity, so we can save when they're mid jump and reload and have them continue being in a jump.
and we're going to make it very easy to debug and test with some custom editors.
And that's actually where we're going to get started.
To begin, we're going to create an editor script for our game manager.
I've got my game running here.
I'm actually going to stop playing it.
Right click in the project view, hit create, and create a new editor folder.
It needs to be named editor, spelled exactly like that, edi.
I'm going to go in there, open it up, rightclick, hit create, choose C# script, and we're going to make a game manager editor.
So, capital G, capital M, capital E, and we'll open it up.
This is going to be a custom editor for the game manager.
So, when we select the game manager, okay, got to go back to that file.
There it is.
When we select the game manager, it's going to render the game manager in the inspector and add a little bit of extra stuff.
So, now to make that happen, we're going to need to replace the base class with editor instead of MonoBehavior.
I'll hit enter, and it automatically added the using Unity editor statement up there.
If yours doesn't, just go put it up there.
Next, we need an attribute to tell the editor what type we want this to be a custom editor for.
So, we put the break brackets here and then custom editor.
There we go.
And then we got to put type of inside parenthesis and open another parenthesis.
And here we want game manager.
Well, I got to close this out with two parenthesis and a square brace.
Now, the editor class has a couple methods that we can override.
Start and update are not them.
So, we're going to delete both of those and put override.
Oh, not onride.
Override.
And then we should see the one that we want is on inspector guey.
I'll hit enter and save.
That should now give me a custom editor that doesn't break anything and still shows the game manager in Unity.
Let's go make sure that that's the case and then we'll work on editing it.
So, go back into our game.
Go select the game manager.
I can see the game manager.
No errors here.
Even if I hit play just to force and make sure that it recompiles.
No errors here.
Looking good.
Now, if you run into some errors, just make sure that your game manager editor is in the correct folder and that you don't have like two of them if you search for game manager editor.
Make sure that you don't have a second game manager editor in another file or somewhere else like that.
Or just look at what the error message says.
All right, let's go back into the code.
Now in the custom editor, we automatically get a reference to the object that we're inspecting.
But that object is typed as a game object, not the thing that we need.
So what we can do is add a variable here and use that object by casting it.
So say var game manager.
Oh, look at that.
It's going to autocomplete.
Game manager equals and then we're going to get the target, but we're casting it as a game manager by using the parenthesis here.
Next, we just going to call game.
Oh, no.
We're not going to call anything.
We're going to add a button.
Next, we're going to add a button to save our game and another button to load our game.
So, say if.
And then we need what is it? It's guey layout.
I always forget which one it is.
And then we do open parenthesis and the name of our button.
So, this will be save.
I'll just let's call it save game.
And if that is pressed, then the code after it or the code inside the parenthesis will be called.
And I want this to be game manager.save save game.
Now, if I want to load a game, I want to be able to just press a button as well.
So, I'm going to hit duplicate and just select those lines there, hit duplicate, and I'm going to put reload game.
And here, we're going to call a method called reload game on our game manager.
Now, save game exists, I believe, but reload doesn't.
So, we're going to need to create that.
Let's hit alt enter and generate a method for reload.
And then, let's click on save game and just hit F12 to go to it.
You can see it exists, but it was read because it's private and not public.
So, it couldn't be accessed by another class.
We need to make this public so it can be called from our editor script.
And then down below our save game, we're just going to add a reload game method.
I'm going to put a public void.
Oh, wait.
We already generated a reload.
So, I should actually just go find that because that's going to be in here somewhere.
I think I generated it.
Okay, I didn't generate it.
So, I will type it in here.
For some reason, I thought I hit generate on it.
Okay, so we go to load game.
Right here, we're going to put public void reload game.
And this can just be an expression body method that calls load game and just passes in our game data.
Name.
There we go.
So, remember our game data.game name is the thing that's set and used for saving off our game.
So, we're just going to reload the game by calling load game and passing that name in.
Let's save and do a build real quick.
Make sure I haven't missed anything.
Go back into that game manager editor.
There we go.
We see I've got my two buttons available.
And then we'll go into Unity and see if they work.
All right, here we are in Unity.
We'll hit new game.
Run around.
Let's go take some damage.
Oh, I got hit a couple times or one time.
We'll save and then reload.
You can see I come back with my health at five.
Let's go grab some coins real quick.
Not coming back to my start, the correct position yet.
But I am coming back with the correct health.
Let's save and reload.
And I come back with 13 coins and my health's right.
But if we go back over here, of course, all of our coins have reset.
So, we do have a save and a reload option now available.
See, I reloaded and our coins went back down to the last time we saved.
But we've got a couple things to address.
For now, though, let's do a quick commit that we've added our added game manager editor.
We'll check that in and then we'll continue on.
Now, we're going to take a look at our player data.
We're going to add some data there and check out our entire workflow for it, as well as track down a bug.
So, here you can see I've got my player data visible underneath game data.
If you don't see yours, you can just expand it out.
I've got a couple saved games in here.
And if I save game and reload, my player data shows up.
Now, the reason I don't get my player data showing up automatically right now is cuz I didn't come in through the menu.
And I don't have this binding up to anything.
So, we're going to need to address that.
We're also going to want to store the position of our character so that we can reload that when our player comes back in so they can come back into the same spot in the world.
So, let's stop playing.
Well, first actually, let's shoot and let's take a look at the console because you see that we've got a couple errors down here as well.
I'm going to reload again.
And look, now we've got more errors.
It went up by four every time I clicked.
If I reload again, you'll see that it went up by six every time I clicked.
Click again, it's going to go up by eight every time I click.
So, something is happening every time I reload that's causing me to get two extra errors every single time I click.
Let's take a look at what those errors are.
We'll use that as our starting point and jumping into the code.
So here you can see I can click on these.
This one just tells me it's something in the the input system.
But the one below tells me is something in the blasters use method which is calling fire which is called from the use equipped item here on player inventory line 46.
And that's called by some delegates passed in from our input system.
So let's go take a look at line 46.
Here we can see here this is where it's trying to use our equipped item.
And the problem was that our item is destroyed or null.
At least that's what the error message said.
So let's take a look at the references for use equipped item and click here or hit shift F12.
Whoops, the wrong key there.
Shift F12, find all references and see that we register for the performed event right here in awake.
Let's check and see if we ever unregister for it.
An easy way to do that would just be to search for my fire string.
Just do a control F and hit enter.
And I can see that well we never unregister for that.
We also don't unregister for the equip next event.
So let's copy both of these lines on 19 and 20.
And then down here add an on destroy so that we can remove the registration.
I'll just paste it in and replace the pluses with a minus.
What's happening here is that our player inventory even though it's getting destroyed, it's still registered and bound into this player input event which is or this player input objects event or its actions here.
The input action asset technically.
And that's tied into the event system and that event registration doesn't go away automatically.
So whenever we press fire, it's still trying to call into this destroyed inventory of a past character and then use its blaster that no longer exists either and then eventually blows up.
Now it doesn't blow up in use equipped item because there's nothing here that references an object that's actually been destroyed.
The equipped item is still technically around.
It just hasn't been completely destroyed.
it's around because the C# part of it couldn't ever clean it up because there was still an event registered for it.
But Unity has destroyed the object.
So, we can't actually use it and we don't want to.
Now that that's fixed, let's go back into Unity and double check it.
All right, here we are.
We'll shoot, save, reload, shoot, reload, shoot, reload.
It's looking good.
Now, we're going to adjust our workflow for loading games.
Instead of having our player data be empty here because we didn't come from the main menu, we're going to make sure that whenever we restore a level, we make sure that we've got some player data here and that we have the recent data actually bound up to our players.
To do that, we're going to open up our game manager and in our handle scene loaded going to do two things.
First, I'm going to just comment out the save game because I don't want it to keep saving game constantly.
I want to just take tight control over that for a while and then we'll figure out where we want it to actually save after we've got all of the save systems up and working.
Instead, what I want to do is find all of our players.
So, I'll say var all players equals find objects of type.
And we're going to remove this in a while, so don't worry about optimizing it.
Find objects of type, not all.
There we go.
And we're going to find all the player objects.
We'll loop through each of the players.
Loop through each player in all players.
And then we're going to bind all of those players to their data.
So we'll say var data equals and we'll want to call get player data.
And here we need to give it the player index, but we don't have that yet.
So we're going to need to get our player input as well.
So say var player input equals player.get component.
We don't have it cached, do we? Nope.
So we'll do get component.
Got to double check.
And it's going to be that player input.
And then we'll pass in the player input dot player input.
There we go.
Player index.
And again, don't worry about optimizing this.
We're going to refactor this all the way into something more generic really soon.
Now that we've got our data, we just need to tell our player to bind to that data.
So now we're going to automatically bind up whenever we load into a scene.
Let's go try it.
All right, we're back in Unity.
We'll press play.
And we can now see our player data there.
Let's go take some damage and see what happens.
I take some damage.
My health is going down.
And if I go grab some coins over here, my coins go up.
I can save.
I can reload.
And I can see that data looking right.
Let's stop playing and we'll go make a quick commit that we've fixed event regist dregistration.
and and and default.
Oops, hit the wrong key there.
Okay, fixed event dre registration and default player data and check it in.
Now, we're going to start keeping track of our players position and velocity, as well as our saved game name.
when I save, I realize my game name is blank right now.
I can reload it, but I won't be able to come back in after I save and reload again because I'm saving off a blank name.
So, let's dive into the code and adjust both of those things.
I think we'll start by let's just go into the game manager and do the saving first.
So when I save my game right here at the beginning, if my game data name is empty.
So here we actually want to do a if string is null or white space.
So that way we can get blanks and spaces as well.
Then we just want to give it a new name.
We'll say game data.ame equals.
And here I'm just going to call it game.
And let's let's use like a game plus the number of games that we have.
So I think we have an all game names and we'll use dot count.
Should we do count plus one? So if we have one game, no, it should be exactly that.
So this be the game and a number there.
All right, let's go on to our player data now.
So our player in its update is going to just store off where it is so that we can keep track of it and then we'll be able to view that in our game manager.
That'll be stored off in the player data class though where we're storing our coins and health.
Let's go add these two things as fields.
We'll put a public vector 2.
And the first one, I want to make sure I get the Unity engine one, not the numeric.
Don't want to have a numeric using statement up there, or else we'll have an error later saying that the types don't match.
So, this first one's going to be position.
We'll give it a capital P.
I'm going to duplicate that and then make a velocity.
P E L O CI TY.
There we go.
Then we'll jump back into our player.
Now in our player in the update right at the end of it, let's just set our player data.
So we'll say player data.position equals and here we'll get the position from our rigid body which is a vector 2D.
And we'll duplicate that and do the same for our velocity.
Let's see.
Oh, I spelled velocity wrong.
Let's rename that V L O CI TY.
I had an extra C in there.
All right, we'll save and do a build and let's try that out in Unity.
All right, here we are.
You can see I've got a position and velocity and they're actually updating.
I can save my game now and it shows up as game three and I can reload my game, but it doesn't actually keep my position.
So, now that we're storing off or saving our position, I'm pretty sure we're saving it.
We're in that position.
We hit save, it should be serializing, right? We need to figure out how to restore it.
Let's take a look at our code again.
So, here's our update where we're setting the data and reading it from our rigid body, putting it into position and velocity on our player data.
But where would we restore it? And there are a couple things we could do here.
First, if we go down and find our bind method, we could theoretically do it in here.
The reason that I don't want to do it in here, though, well, there's twofold.
One is that bind generally just should be hooking up the data.
It shouldn't necessarily be moving objects around and doing more complicated things.
I I prefer if it just sets up the data and then maybe sets up the initial state, but we're going to keep a very generic binding system.
And we're going to extend this out to be even more generic.
And I don't want them to have very different implementations for each one.
So instead, we'll create another method.
And where we call bind, we're going to call this method to restore our position.
And one of the key reasons for this, by the way, is imagine that we are restoring the position in our bind method.
If we save off our position and then we load into level two and then we call bind again on the new player there, we're going to instantly bounce that player back to the position that they were at in level one.
So that could be maybe, you know, some random offscreen position or something else, but it's not the position that we wanted to teleport them into.
it's not the starting position for that level.
So, we want to be able to have some tighter control over that.
And we could maybe have a parameter in here for do a restore or something, but I think that having a separate method tends to be cleaner.
It makes things less complicated as well.
So, we're going to add a public void restore position and velocity.
And that's going to just tell our rigid body to move to its players player data position.
So, we'll say underscore RB.position position equals player data.position.
And then we'll do the same for velocity.
In fact, let's just duplicate that and replace position with velocity.
I cannot spell velocity.
All right.
So, that should put us back in position, but we're going to need to call it.
So, let's make sure that we call this from where we're calling our bind.
In fact, let's get rid of line 302 here.
We got an empty line.
Go to references, and we're going to find the one where we Let's find it.
where we bind in our game manager.
So not this one in handle player join.
Let's find the other call to player.bind.
That's when a player joins like our secondary player and comes in later midame.
So after scene load, there we go.
We'll say player.restore position and velocity.
Now we're not going to restore position and velocity on a second player that joins in the game afterwards.
And we'll deal with second players a little bit more later, but for now, we just want to restore the position of this player.
The first player when they come back in, or the first player that loads back in, second player will just appear near that person that's been saved off.
All right, we'll save and make sure that we save.
Let's go try this in Unity and see what happens.
So, here we are.
Let's run around.
I'm going to run right over here by the blue flag.
In fact, I'm going to start jumping upwards and hit save.
And then let's go over here to the right somewhere.
I've got game four saved.
You can see that's my game name.
And I'm going to hit reload.
And look at that.
I reappear over there popping up into the air.
Now, there is still one problem with this implementation.
If we land on this flag, look at that.
Look at where I reappeared.
I actually reappeared in the exact same spot as where the flag was.
We can see that a little bit better if I stop playing.
Let's go over here and just going to take this flag.
We'll move it up here.
We'll save.
Well, actually, I didn't save, but that's okay.
We'll press play, and I'll just run up there and jump on that flag and watch what happens.
So, come down here.
We'll go jump on the flag.
And now I appear up here.
So, I don't want that to happen.
I want that position to not restore.
Just like we talked about, I don't want it to happen every single time we bind.
So, we're going to go back into the part where we're calling this the restore position and velocity here.
And we're only going to do this if we're calling a load game.
So if the game is being loaded then we'll do this otherwise we'll skip it.
So we'll say if load actually yeah if load game or no game manager can't get my words out is loading.
There we go.
Then we'll call restore position and velocity.
We'll add a boolean property is loading to our game manager.
Oh look at that.
It automatically added a public static bool is loading with a private setter.
That's exactly what I wanted, just like my is cinematic playing.
Now, we're going to scroll down to where we do our load game.
And right at the beginning of it, we'll set is loading equal to true.
And then when we actually uh check it, so let's do another search for is loading is loading.
There we go.
Right afterwards, we'll set is loading to false.
Now, we're going to use this in one other place in our players update.
Let's go find our update method.
Where are we? There.
Oh, update grounding.
Right here at the top of our main update.
If we're in this loading state, we don't want to be moving our player around.
We don't want to be setting the position and velocity.
Right now, it's really fast.
It's almost instant.
But if we have a larger level and more stuff going on, we don't want to start kicking off actual movement and and controlling our player or doing anything like that.
We also don't want to be updating the position and velocity.
So say if game manager is loading, then we'll just return.
So it won't do any input or anything like that until we've finished.
Now let's go into Unity.
We'll go grab our our our game manager.
Let's go select it right here.
We can watch our data.
We can run around.
We can take some damage here.
Let's run over here.
Go grab a couple coins.
Save our game.
Jump over here.
Continue on to the next level.
And you can see I'm at the same the correct spot.
I can come over here, take some damage.
Let's see if we can find something.
Pretty sure I got some spikes over here that can hurt me.
There we go.
And then we'll reload.
And look at that.
I'm back here with five health.
Let's go into the other scene, though, and save our game here.
And reload.
Look at that.
We're not saving our scenes.
Let's take this as a quick opportunity for a challenge.
See if you can figure out how to get the scene to persist.
It should be very simple.
Just take a look at some of the existing code that we've been looking at recently and maybe one of the arguments and see if you can track it down.
Give you just a moment.
Go ahead and pause, of course, and let's continue on.
I'll show you the solution.
So, if we go back into that game manager right here, when we load a scene, we get arg.
can just cache that off in our game data so we know what level that we're we're currently in and then we can reload that level when we load our game.
So maybe let's say right down in here in any of the parts where we're not loading the actual menu scene, we'll say underscore and here we want our game data and we're going to use current level name equals arg0ame.
We'll generate a field for that.
It should just be a nice string.
Go a hit F12 and take a peek at it.
We'll go make that public as well.
And then we'll go back into our load.
So when we do a load game, there we go.
We'll figure out our level to load.
Instead of loading level one, we'll load a level based on the game data that we've got here.
So I'm going to cut level one right here.
And we're going to put it let's say var scene name equals and we'll say underscore game data current scene or current level name and we need it in actually a stringisnull or white space.
Oh yeah yeah then we'll return level one.
Otherwise we'll return game data current level name.
There we go.
Let's take a look at that logic since I kind of confused myself in my wording.
So, our scene name is going to be equal to if the current level name is set or not set, then it'll be level one.
Otherwise, if it is set, it'll be the current level name.
In fact, what we could probably just do here, I think it'd be a little bit cleaner to say if game data.curren level name is if string.isnull or if string.isnull or whites space current game data.current current level name.
Then game data.curren level name equals level one.
one.
one.
And then here we'll just pass in game data.current level name.
It's always good to look at the code, refactor it, and clean it up as you're writing it.
Make it a little bit easier to understand.
So now we should load the correct level.
Let's go try that out.
All right, here we are.
We're going to run across.
Actually, let's reload.
Make sure that we still end up in level one.
Yep.
And then we'll run over here, jump on this thing, run off to the right a little bit, save and reload.
And look at that.
We're back in level two.
I'm going to cross over to level one.
Reload.
And I go back to level two.
Things are looking good.
It's time to go make a commit that multi-level player position persistence works and check it in.
Currently, our data binding is working pretty well for our player, even across scenes.
But it doesn't work for anything inside of our levels, like these coins.
You can see again, I can pick up coins, of course, save and reload, and come back, and the coins are there and keep picking them up.
So, we're going to want to be able to persist things for each level.
And to do that, we're going to add in a new data structure.
Let's go into our game manager and then find our game data.
Let's go find game data.
We'll control leftclick on it.
And in here, we're going to add in a new structure that's going to handle all of the data for a single level.
We'll call this level data.
And then we'll fill it up with the different types of things that we have in the levels.
Remember, our player data is a little bit different because our player goes across levels.
And we're also going to have another type of thing that's a little bit different from our level data for items because they'll be able to move across levels.
But a lot of things stay in a single level and we should be able to handle those pretty easily with a level data.
So we're going to add a public list of level data named level datas.
And we'll initialize that to a new list of level datas.
Just like that.
We'll need to generate a class for level data.
So I'll hit alt enter.
And let's do it in this file.
I'm going to copy that serializable attribute and add it up here.
We're going to need a couple of properties.
First, a level name.
seems like an important one so that we can bind the level data specifically for a level.
We know what when we load level one, we know which level data to use.
So, we'll add that level name field.
And then I know I want to store the state of coins.
So, let's put in a public list of coin data named coin datas.
And again, we'll initialize that to a new list and then generate a type.
So, we'll hit generate type and we're going to do it in the same file.
Come down here one more level.
We'll copy that serializable attribute again, paste it in here.
And now for a coin, what do we really want to keep track of? I don't want them moving around.
I don't want them really changing anything other than their kind of is collected or is enabled state.
So, I'm just going to add in a bool, a public bool is collected, and then we'll save.
Now, inside of our coin, we're going to bind up to one of these coin datas from our game data.
And then we'll just toggle that field on whenever our object gets collected.
So, let's add in a bind method public void bind.
That'll allow us to bind to a coin data.
And we'll figure out where we're going to get that from in just a moment.
We'll name the parameter data.
And we'll just say underscore data equals Whoops, it autocompleted the wrong thing.
Equals data.
We'll generate a field for it.
And now we've got a coin data that we can use.
So delete that private keyword.
And down here when we add a point before we even add a point, let's just say data is collected is equal to true.
So now we've got something that we can set in here, but we don't have this bind method being called.
We need to figure out where that's going to happen.
And my recommendation where I would put it is right here after we've loaded our scene.
Once we load our scene, before we go through and restore our player position and all of that stuff, let's restore all of our coins or bind up all of our coin data.
I'm going to add in some new lines right here and just give myself a little space on line 52.
And I'm going to call a method.
Let's call this bind coins.
That seems good enough.
We'll generate a method for it.
And then in this bind coins method, we'll find all of our coins.
So say var all coins equals and we'll just do a find objects of type.
Make sure I do the of type.
I have to add in extra parameters and we'll find all of the coin objects.
Then we'll loop through each coin in all coins.
So for each var coin in all coins and then we're going to bind each coin to its data.
So we want to call coin.bind.
But we're going to need some data.
So let's get a data parameter up above.
Let's say var coin data or just call it data equals and we need to get something from our game datas level data.
So we're going to have to say underscore game data dot level datas and we're going to need to know which level we're currently in.
So here we're going to have to find the correct level data.
And since we're going to do that multiple times, why don't we do that one level up and pass it in here? So let's assume we have a level data and then we'll loop we'll get the data from our level datas level data coin datas and we'll do a first or default and we're going to match the coin data to our coins name.
So I'll say t dot and we want to use our name equals and then we're going to use this name or just name.
So, we're not not this.
Whoops.
What am I saying here? We got Oh, coin.name.
There we go.
Get our coin object.
Now, our coin data doesn't have a name property, and that's what we're going to use to match it up.
So, instead of having these all be indexed, which we could do, or having a unique key or a unique ID, one of the easiest things to do, one of kind of the cleanest things until you get to a very large scale is to just give them a unique name.
And we'll do some editor tooling to enforce this and link them back to prefabs later.
But for now, we're just going to generate a field.
We'll generate a field called name on our coin data.
Let's go take a look at it.
So, we've got a field here.
Let's make that public instead of internal.
And then we'll now that we've got our data, we'll bind it up.
Now, if we don't have a data for it, so if the data is null, so if data is equal to null, maybe we've added a new coin to the game or we've just never loaded before, then we're just going to instantiate it.
We'll say data equals new coin data.
And then we're going to give it our is collected is equal to false.
And our name is equal to the coin's name.
We'll save that off.
Hit control D to clean up our reference or our formatting.
And then finally, we need to call bind coins and pass in that level data.
We have our bind coins call, but we don't have the current level data.
So, let's get our current level data one level up here.
Say varle data equals, and we're going to get our game data level datas first or default.
Just like before, we're going to check the t.name or level name against our arg name.
So the level that we've loaded, remember scene zero or arg0 is the scene that we've loaded into.
So we're going to find the level data for the one that we've loaded into.
If that doesn't exist, just like before, we'll create it.
We'll say level data equals new level data.
And we actually need to make sure we add these to the list.
The level name is going to be equal to arg0.
And then we'll bind to that level data.
Now, we need to do two more things here.
We need to add these level datas that we're creating or this new one to that level datas array.
And we need to add the coin data that we've created to the coin datas, right? And I said array, but I mean list in both of these cases.
So let's add in some braces here.
Oh, not just an open close down below.
We'll say underscoreame data.le datas.
Uh it was going to autod do it for me.
Add There we go.
Level data.
And down here in our coin datas, we'll do the same.
When we create a new data object, we need to make sure that we add it to our list.
So say level data coin datas add data build and fix my typo here.
This should be equals null, not not equals null.
We don't want to create a new one if it exists.
Once that's good, we should be able to jump into Unity.
And then we when we hit play, we should expect to see a new level datas get created along with a coin data for all what do we have 16 coins.
So we've got a level datas object underneath there.
We've got all of the coins, all 16 of them.
And we can see that none of them are collected.
Let's go collect one and see if the state changes real quick.
So we'll run over here.
We'll go grab some coins.
Uh oh, looks like one of them changed.
There we go.
That other one changed.
Now they're all collected.
and we can save and reload, but the reloading doesn't do anything yet.
The state is still correct.
It's got that they're collected, but we're not restoring them to a collected state.
So, let's make that final change.
So, back in our coins bind method here, we've got a slightly different scenario than the player where we have to worry about our player updating and moving and doing other things during the loading system.
And and in there, we don't really want to adjust the player's position or move them.
At least I I don't.
But for our coin, we can restore its enabled state.
So when we bind, we've got the data in its correct state already.
And we just say if data is collected, then we'll just set our game object to inactive.
So say game object set active to false.
Now, if we go back into Unity and we reload our existing game, we should expect to see that the coins have disappeared.
So we'll press play.
Actually, I won't be able to reload the past game because our game level name won't match with our previous one.
But if I go into here and I just find our game name and put in game six and then hit reload, I got to tab out of that field.
Make sure that it saves my change over.
Hit reload.
Okay, that didn't work.
Let's just jump over, go into level one, grab those coins here.
We'll do a save and a load.
I'm not sure what the state of game six was.
I may have messed it up in between.
All right, so I go grab all my coins except for that one.
We'll do a save and a reload.
And we come back and there's just that one coin.
I go grab that last coin and reload.
Come back and the coin is still there cuz I didn't save.
And if I get it again and then do a save and a reload, of course, the data comes back correct.
And this is what we want to happen going forward.
Although we're going to want to make this a little bit more generic so that we can write even less code for all of the other things that we want to persist.
For now though, let's go into plastic and commit our level and coin data are persisting and coins properly restore and we'll check that in.
Now, we're going to extend our persistence to handle laser switches.
And we're going to do this in a relatively simple way again.
In fact, what I'd like to do is present this as a quick challenge.
See if you can figure out how to get the level data working with the switches.
So, you do the same kind of thing that you're doing with the coins, but do it with the switches so that you can toggle them on and off and persist their state.
When you're done with it though, follow along and watch my implementation and then get ready because we're going to do some advanced stuff in the next section where we're going to take both of our methods and do some combination stuff to make it so we can keep building extensible systems in the future.
I don't want to spoil it too much or talk too much about it.
So go ahead and see if you can figure out the level switch part, the the laser switch and the level data for your laser switch and then continue on if you get stuck or even when you're done just so you can see my solution and see how it compares and then be ready for the next part where we build out our bigger, more complex solution.
All right, I'll assume that you've either paused and gone through it or you just want to continue on.
So let's get started with the switch.
First, I've got a yellow laser switch.
Now, I already dragged this one out, but I'm just going to delete it again and go through that process again.
So, grab our laser switch, our yellow laser switch prefab, the one that we made before.
I'm going to pop it right over here.
I'm going to name this thing yellow laser switch 2 because I've saved some data on.
Actually, you know what? I'm going to just rename it back to yellow laser switch.
We'll press play.
And right now, if I load and save my game, I expect the state of this thing to not save at all, but my position to save.
Let's just go verify that we're in the correct state and that we understand where we are.
So, we come over here, we run across, we switch our switch on, doesn't do anything yet, but if I save the game, I don't have any level any switch data here or anything.
So, as soon as I reload, I expect it to Yeah.
flip back over.
So, how are we going to address this? Well, let's dive into our system right now for persistence.
We'll go into the game manager in just this window and then we're going to dive into our part where we're binding our coins.
So when we set up our coins right now, remember we find all of the coins in the scene and then we use this coin datas array or it's actually a list on our level data and then bind each coin up to one of those items and then we create new coin data items if they don't exist.
We're going to do the exact same thing for our laser switch.
So, we're going to need to create a laser switch data, give it a bind method, and then kind of copy this code right here.
So, what I'm going to do to start is just duplicate our bind coin.
So, just select it all, hit control D, left arrow, enter twice, and let's call this bind laser switches.
I need to make sure I use the word laser switches because if start using switch, it's actually a reserved word and it'll start causing some issues.
So, I just like to put laser switches in there and be super explicit.
Now I want to bind it to my level data still.
I don't want to get all coins.
So I'm going to rename this to all laser switches.
And then I don't want to use coin here.
I want to use a laser switch and continue on.
I don't want to use a name coin.
It's a laser switch.
So again I'll just rename again laser switch.
And then let's continue on to the next line.
So this is looking at coin datas.
I want to look at laser switch datas and I haven't created those yet, but we we'll figure it out.
We'll create them.
And I want to make sure that the name matches the laser switch name.
That looks right.
Data equals new coin data.
Doesn't sound right.
This should be a laser switch data.
And then is collected.
That doesn't make sense either.
I think for a laser switch, it' be is on, not is collected.
And then finally, we've got laser switch data.
So, let's just copy that and paste it in.
So now we've got a method to bind up laser switches to datas, but we don't have a laser switch data class or the list here.
So let's create both of those.
We'll copy laser switch data onto the clipboard.
Controllclick on coin data.
And I'll go down here and actually let's just select the entire class, duplicate it, hit that left arrow again, and enter and paste.
We'll replace is collected with is on.
And now I've got a laser switch data class.
Let's go back.
Next thing we need is laser switch datas.
If I just hit alt enter here and hit generate field.
Make sure not to hit rename.
I should end up with an object.
That's totally the wrong thing.
So I'm just going to replace this with list of laser switch data.
Now that said, it's I I really wish uh Visual Studio would get those right instead of uh making me have to correct the type.
But there we go.
We want this to be a list of laser switch datas so that they will get stored off.
All right, things are looking good so far.
We've got one issue left though, and that's that we don't have a bind method for our laser switch.
So, we're going to need to generate that as well.
I'll hit alt enter, generate a bind.
And inside of here, first, let's make this public.
We'll just set our underscore data equal to data.
And that autocompleted totally wrong thing.
So, I'll go back and retype it.
Hit alt enter and generate a field.
And then we want to use the is on state of this data object instead of the is on bool here.
So, I'm just going to delete this is on bool.
Delete that private keyword and then do a quick build because that's going to show me all of the parts where I referenced is on and then I can fix them.
So, just double click on it.
And here I want to use underscore data is on.
And in all of these other spots, I'm just going to copy and paste is on is on and is on.
Now, oops, got that twice and I just undid it.
Okay, let's see if I can get that correct in there.
Okay, there we go.
is on is true.
So the last thing that we need to do is deal with when we binding it.
When we bind it, we want to restore the state of our object.
If we just call turn on and turn off inside of our bind based on our data state, it's not actually going to work because the data state isn't changing.
If we call turn on with our data is on, well, it's already going to be on, so it won't do anything and it won't run this code in here.
So, we're going to extract out the code that switches on or deals with activating our switch or deactivating our switch and updating our say it's kind of our switch state.
So, to do that, we're just going to cut let's take lines 48 and 49 and actually let's do a refactor instead.
Hit alt enter and we'll extract a method and let's call this update switch state.
And then we only we don't this is only the stuff that we want to do if it's off.
So, I'm going to add in a check here for if data is um off.
Yeah.
So, if data is on, we'll do something else.
Otherwise, we'll do the off code.
There we go.
And then for the on code, we're just going to take this bit right here, 71 and 72, switching the sprite to the right mode, and calling the on method.
Finally, we need to call update switches from turn on so that we still run that code.
We just call the correct one.
And then in our bind method, right after we bind up the data, we'll call that update switch state as well.
Let's rearrange these real quick.
Get this update switch state.
I want to move this down.
Just cut it.
And I'll paste it down below.
All right.
And there we go.
That is our entire laser switch code.
Let's go check it out now.
So if I press play, I can see that I've got a laser switch datas, but I have no entries for it.
And the reason for that is simple.
I forgot to call our method.
So let's jump back into Unity and make sure that we actually call our new method from inside our game manager.
So we've got bind coins and see bind laser switches is light gray.
It's just because it didn't call it.
So duplicate bind coins, put in bind laser switches.
We go back in and now we should see our data bind up.
There we go.
You can see our laser switch is on or it's in here.
I can run across.
It turns on.
I can save my game and reload my game.
And it's back in the correct state.
If I switch it back off, I can save and reload and it stays in the correct state.
And go duplicate that switch.
Let's go make a yellow laser switch.
One and a two.
And we'll just drag these over into different spots.
There we go.
Save and play.
And we'll just go make sure that they all save independently.
And we can see multiple laser switches in here.
Let's just go double check that.
So, we'll run around.
We'll go select our game manager.
Go over here, flip some switches.
That's probably one of these.
There we go.
Flip another one.
Flip another one.
Let's flip that one back over.
Save and reload.
And things are in the exact same state again.
So, there we go.
We've got a nice simple setup for binding up our laser switches.
And hopefully you're starting to see how we can bind up any kind of data.
Although we are getting a little bit repetitive with the code.
So it's about to be time to start refactoring and making things a little bit more generic.
For now though, let's go into plastic and make sure that we commit our changes.
We bind laser switches to persistent data.
And we'll check that in.
Our current data binding system handles our player coins and laser switches, but it does the players in a slightly different way.
And if you take a look at our coin and laser switch code, they're almost essentially duplicates of each other.
They do about the same thing.
They find an object by name and then match up that data.
If the data exists, it m binds up to that data.
And if not, then it creates a new one.
And if we want to create new items that we want to bind to, for instance, items that we can pick up like our keys and blasters or anything else that we want to bind to, we have to copy and paste this code and make little modifications to it.
And I'd like to eliminate that and dive into a slightly more advanced topic of generics.
Now, you've used generics before.
You can use generics right here.
Find objects of type is searching for things using the generic syntax and finding all of the laser switches or the coins.
But we're going to use generics in a slightly different way.
Instead of just using a method that implements or takes advantage of generics like find objects of type, we're going to create our own bind method that takes some generics and allows us to generically bind up one object to its data.
no matter what type of object and data we have as long as they follow the same contract or interface.
And to start, we're going to create some interfaces and then we'll do our binding.
Let's start with the coin class.
Let's go take a look at our coin.
Our coin has a bind method and it binds to coin datas.
So, we're going to add an interface here that tells our system or our persistent system that our coins bind to a coin data.
We'll do that with an interface and let's call it ibind.
We're going to just add this at the end of coin and then we'll create the interface right afterwards.
So say ibind and we're going to give not ibindable.
Ibindable is part of the UI elements.
It autocompleted.
So we're going to do ibind and make our own.
It's part of the UI elements package.
So we're going to do our own one called ibind.
And we're going to bind to coin data.
We're going to give it the type of coin data.
And we don't have an interface called ibind yet.
So we're going to need to either generate it or go type it down below.
I'm going to create it right here in this file and then maybe move it over to our game data class later.
So, our game data file.
So, we've got an internal interface named bind.
Let's make this public real quick.
And it binds to a type of t.
Inside of that interface, we just want to have a single method called bind to the data.
So, now we've got this interface here.
Absolutely nothing has changed.
Though, let's go take a look at our game manager.
So in our game manager, now that we have our coin as an ibindable, perhaps we can implement a way to bind it up.
Let's go take a look at our bind coins method.
So here, remember, we loop through all of our coins, and then we find the coin data by name, matching it to our coin object, and then we bind it up or add it to our we add it to our coin data.
If it doesn't exist, then bind it to the actual object.
So let's add a method here that allows us to bind things slightly more generically that allows us to bind things that are ibindable to a type.
So we'll do void bind and we're going to take a type and then the data type and we're going to call this method bind and then whoops going to call I already called the method bind.
We're going to give it a parameter and the parameter is going to be a list of d and we'll call this datas.
So, this will be either all of our coin datas or all of our um item datas or laser switch datas or whatever other type that we want to pass in instead of passing in the level data cuz if we passed in the level data, we'd have to figure out which object to get.
So, we'll take our list or our bind method here and we're going to do the same thing that we do in bind coins.
First, we're going to find all of the objects that match the type.
So, I'll say var instances equals find objects of type.
Let's see, find objects of type.
There we go.
And then we're going to give it the type T.
It's going to find all of the objects of type T.
But now you see we've got an error here because it says the type T can't be used as a parameter in the generic find objects of type because there's no conversion from type T to object.
So let's go back to our or actually let's add a restriction here that says that T must be a game object or must be a MonoBehavior.
So we'll say where T colon mono behavior.
That'll get rid of the error here because now it knows that whatever type we specify here will be a MonoBehavior that has to be able to be getable with find objects of type.
So now that we've got all of the instances, let's loop through them.
So say for each instance and instances and then we'll find the data for that instance just like we're doing down here in bind coins.
We can pretty much follow along just rewriting the method a bit more generically.
We'll say var data equals datas because remember we're going to pass that in do first order default and here we're going to want to match on the name t do.tname is equal to our instance name.
Now we've got another error here because t.name does not exist.
Remember our coin data has a name on it.
So we're able to find it down below.
And our laser switch data has a name on it.
But our data object here this d does not have name on it.
So, we're going to need to be more specific and say that our data type must also have a name.
To do that, we're going to add in another statement here.
We'll say where don I named.
And we're going to need to generate an interface for I named that just has a name property on it so we can get that name and read it.
So, let's go generate an interface now.
We'll generate this down here at the bottom of our file.
And we'll add in a scroll down here a little bit.
string name and we'll add a getter and a setter because we're probably going to want to set that later.
All right, so we've got our I named interface and now our data line works.
We can now get the correct data from our list of datas.
If we don't get a data object back, just like on 94, we need to create a new one.
So we'll say if data equals null, then data equals new.
And here we're going to give it a new D which is our data type because it could be a coin data, it could be a level data or something else.
We'll add in our parenthesis there and then our let's put the braces so that we can assign the name.
We'll say name equals instance.name.
Now we're going to have an error here.
And again, this error is because we're not being specific about what type of data it is or what the data type has.
And here it says that we cannot create a new instance of variable D because it doesn't have a new constraint.
And what that means is that we haven't told this method that D is an object that can actually be nued up.
You know, some objects you can't do a new instance of.
Most of them you can, but in this case, we just need to be very specific and say, hey, this thing can be new by adding a new right at the end.
So, we add a comma after the I named and new, which just means that this part here, the data object, implements I named and can be instantiated.
So now that we've got a new data, we'll just say datas.add and we'll add in that data and then close out the braces and then finally call instance.bind and we're going to bind to that data.
Now we don't have a bind method on our instance.
So why is that? Well, it's because our t right here doesn't specify that it's also ibindable.
So we need to add that as well.
We've got our mono behavior.
We're going to do a comma ibind.
And I said ibindable, but I meant I bind.
and we're going to bind to D.
So now we've got this complicated looking method, but it's really just binding up types of T to data objects of D.
And we pass in a list of data objects of D.
D is our data type.
T is our object instance type.
So now that we've got that working, we've got that um completed, let's go hook it up instead of calling bind coins.
So we're going to go up to our part part where we call bind coins.
Let's see if we can find it.
Bind coins right here.
and we'll call bind and we're going to bind coin to coin data and then we'll pass in our level data coin datas.
Whoops.
Let's see if I spell it right.
Now I'm going to comment out the bind coins method and we're going to fix the last error here which says that the coin data cannot be used as a parameter D because the generic type because there's no implicit conversion from coin data to I named.
And that's because if we go over to our coin data, we added that I named interface, but we haven't actually implemented it.
So, we're going to add in an I named here.
And then that also means that we're going to need to make our public string here be a property instead of a field.
So, we're going to add a get and a set.
We'll save and do a build.
Now, if we just jump in and play and grab our coins, you'll see that there's actually an issue with the way that it persists.
I can go grab and collect all these coins.
But if I save and then reload, we're going to get multiple new elements and our coins aren't binding up properly.
And the reason for this is actually very simple.
If you look at these element names, notice something that's missing or these I I think I might have kind of hinted it there.
But if you look at these, notice that the name is here on our laser switches, not on our coin datas.
The reason for this is simple.
When we converted our property here, the name to be a property, it stopped getting serialized by Unity.
Since we're using Unity serialization system, we need it to be serialized by Unity for this stuff to work.
Otherwise, we're going to have to swap out our safe system, which is another viable option.
But an easy solution for this, so we can also see it in the inspector, is right at the beginning of our property here, and you can do this on any property that's got a getter and a setter, we're going to add a field colon serialize field.
I spelled that wrong, but if I can fix my typing.
There we go.
What this will actually do is take the backing field, the hidden backing field for our name property that's automatically created whenever you create a property.
It creates an like a a hidden name property that's going to be get and set.
When you call this getter and setter, it kind of autogenerates that code.
And this is saying, hey, for that field that you're autogenerating, serialize it.
That's all we need to do.
Let's go back into Unity now.
Press play.
And now when we look at that player data, notice that we've got all of the coin names.
Those are working.
I can run over here, collect things, save them all, reload.
I don't have duplicate data, and my state is correct.
Now, before we commit, let's do a quick diff on our files.
Just make sure we've got everything right.
So, our coin now just has that I bind interface in it.
We'll move that around later.
And then we've got our game manager which has the bind method and is no longer calling bind coins but calls the generic one.
And then we've also got our coin which has or our coin data which is now I named and we have that I named interface.
All right.
So with that I think we can commit that we've added generic data binding and check it in.
Now that we have a generic binding system, we're going to do a little challenge to make sure that it's clicking and that you're understanding how the binding system actually works.
So, what I'd like you to do is hook up the laser switches to use our generic binding system instead.
Remove the bind laser switches method or at least the call to it and use our bind method instead.
Go through the process of hooking up whatever it is you think needs to be hooked up.
See if you can figure it out and then follow along and I'll show you the steps.
So, go ahead and do that now and then we'll get going.
All right.
I'm going to assume that you've either paused and gone through it or again you just want to see the steps, but I would highly recommend that you've gone through it and at least tried it real quick because it's going to be very, very simple.
Let's dive into it now.
So, first thing we're going to do is go to our bind method.
Let's go find the part where we're calling our binds right here.
And I'm going to duplicate line 59 and comment out line 62.
We'll change coin to laser switch and copy that and replace coin data with laser switch datas.
And then finally pass in our laser switch datas.
Now, of course, we've got some errors here saying that laser switch and laser switch data don't match our generic types because they don't implement the two interfaces that we've created.
So, let's go to our laser switch data first and let's add the inamed interface.
And then finally, we'll just copy line 35 and paste it over 42 for speed.
So we can implement that interface without having to type a whole bunch.
Then we'll go back and just do control minus on my keyboard, by the way, or I have a a mouse key bound to it.
And then we've got to fix our laser switch itself, not the laser switch data.
So we'll go to the laser switch and we'll say that it has an ibind interface or implements the ibind interface and binds to laser switch data.
add in that closing one and don't let it add in a duplicate brace.
And since we already implement that method down here, we shouldn't have any errors.
It binds to laser switch data just like we would expect.
And then um that's it.
We're literally done.
Now our data binds up to laser switch data.
And hopefully you're starting to see the value here.
When we want to add in a new object type, we just have to implement those two interfaces and call this bind and our data should bind up.
Let's go test it out though just to make sure that it's actually working as expected.
So, we'll play.
We're going to run over there, smack some of those switches, and then save and load.
All right, we're almost in.
Get that game manager selected.
Scroll down here.
Do my save.
Let's go flip some of these switches over.
We'll just do those two.
We'll save and reload.
You can see that it switched state.
And now, let's just go flip that one over here.
and maybe these ones back.
We'll jump up.
Let's go over to level two.
Come back over here.
Jump back in.
Go into level one.
And my switches are still in the correct state.
So, my data is persisting and everything's working with our new generic system.
Hopefully, again, this is expanding your mind, giving you some ideas for how easy it's going to be to save any type of data that you want and for possibly ways that you can use generics in the future.
Whenever you got something that's super reusable like this where you've got the same pattern and you're finding yourself copying and pasting, generics might be a good option.
All right, let's go back in and commit our changes.
So, say that we've uh switched laser switches to use generics and we'll check that in.
All right, now it's time for items.
This is going to be a big section and hopefully very interesting.
We're going to get into refactoring a little bit, dive into editor tools and dig a lot deeper into data binding.
We're going to start with level one though and start by just putting out another item.
I'm going to take my yellow key here, drag it out.
So, I've got a yellow key one and um I think that I'll start with just that.
And then we're going to go save, pick it up, and just verify that nothing is persisting with our items.
I always want to do a quick verification, see what's happening, and that we're getting the same state.
So, I run over here, I grab that key, I go to my game manager, and I save and reload, and I come back in without a key.
Of course, if I went over here and saved and reloaded, then I would come with a key because I happen to reload right on the key.
But, of reload, and the key is over there because the key wasn't actually attached to me.
I just happen to save myself in that position.
Everything else is saving though.
My switches and my coins should still be saving.
Save and reload, but just not the items.
So, we're going to need to make a change and bind up our inventory to some sort of item data.
So, let's stop playing and go into our player inventory script.
Here's our player inventory.
We've got our items list.
We have our current item index.
And down at the bottom, we have that pickup method.
What we're going to want to do is save off any items that we've picked up and then be able to restore them.
And since we already use a game data system that stores off all of our data and binds through the game manager, we're of course going to follow that same pattern.
So, we're going to make our player inventory bind up to our player data.
To do that, we're going to need to add the comma here and the interface I bind again to player data.
Then we'll hit alt enter and generate the interface.
I'm going to leave this method blank for now.
Actually, let's just assign the data.
We'll say underscore data equals data and we'll add a semicolon.
That's because we don't have anything in our player data to bind up to.
We don't have any player data specific stuff or player inventory specific stuff in our player data.
Let's hit alt enter and generate this field real quick and we can go take a look at that player data.
So, hit control and click.
Go to our player data.
And right here, we don't have any inventory or item related data.
So, let's actually add some right now.
We'll add a public list.
Oops, that's not how you spell public.
public list of strings.
And we'll just call this items.
And make this a new list.
This will be the list of all of the item names that we've picked up.
And these will be unique item names.
Now we can go back into our player inventory and we could loop through all of those items and say for each see var item name in underscore data do items and let's just look in the scene.
We'll do a game OB let's say var item game object equals game object.find and we'll just try to find it by the item name.
This be our initial version.
If we find the object, then we'll just tell our player to pick it up.
So say if item game object is not equal to null and we'll get the um component that we need, the item component.
So we do item game object.
Try get component.
Give it the type of item.
And whoops, that's not it.
I item.
There we go.
I I hit the autocomplete incorrect there.
So we give it our I item interface and then outvar item.
So, if the game object is not null and we're able to get an item out of it, this will be true.
And then we'll have the item assigned to item.
And we'll just say pick up the item.
There we go.
Now, we're going to need to put some data into this data items list.
And we could probably do that right here in our pickup method.
So, just go right here at the end of it and say if data do items.contains contains and we'll give it our item.name and we we don't have access to that yet but we'll get it in a moment.
If it does not contain so we're going to add a not sign at the beginning or here let's just remove that and I'm just going to add a double equals false just make sure that it's very obvious and that there's no missing the not sign.
So if it doesn't contain it then we'll just add it.
We'll say underscore data do items add item.name.
Now I can remove these extra braces and we're going to need to get the name visible.
So right now our item is always on a MonoBehavior and MonoBehaviors always have a name property just like this this lowercase name.
But since it's not defined in our item interface, we can't access it.
So we're going to just go to the item interface and I'll just type it up here.
Public or not public just string name and we need a getter.
It has to be that lowercase one though to match the Unity naming setup they've got.
All right, now that should work.
We've got a bind method.
We've got a pickup method.
We've got some data.
The last thing we're going to need to do is go to our game manager and call this bind.
So, we'll add a bind to player inventory and we're going to bind it to a type of player data because that's what it binds to.
And we're going to give it our list of our player datas.
If I can find it.
Oh, not level data.
I've got the wrong thing there.
Game data.player datas.
Add that semicolon.
And then the Oh, last thing I need to do is go to our player data and make sure that it is also named because to bind we need to have the I named interface.
So, I'm going to just copy this right here, paste it right here, and then add our colon and I named so we can actually bind it.
Now, I should be able to do a build.
Looks like the build was successful.
I'm going to go back to the game manager, though, and just remove these two extra binding methods that are commented out, the bind coins and bind laser switches.
And I'm going to go down here and just remove these as well, just to make sure that we can clear up some of the clutter and keep our stuff easy to read and easy to manage.
All right, we should be able to test it out now.
All right, here we are.
We're back in Unity.
And while this is going to work, we do have an error message down below that we're going to need to take a look at.
First though, let's go grab the key.
Run back over here to the left, save, and reload.
And look at that.
We come back with our key and our switch is in the right spot.
If I go over to level two, well, my key is gone.
It doesn't exist anymore because remember, we're finding the key by doing a game object.find.
and that game object doesn't exist in the scene.
If I go back over to level one though, I've got my key.
So, let's take a look at this error and then we'll dive into how we're going to do that multi- scene persistence.
First, we get take a look at this log right here that says we've got an error in pickup.
There's a no reference exception.
It's in this pickup method on line 68 and it's being called by player inventory awake on line 24.
If we go click on line 24 here, you see that this is that part where we grab our blaster that's a child.
This is where we're automatically equipping our kind of default items or the ones that we've pre-attached to the player.
So, we're going to need to do something a little bit different here.
What's actually happening is if we go into our our pickup method, we're trying to um rebind to an item that's already got bound up that's already set up and hooked up to our player.
So, what we're going to do is add in an option to not add data for inventory items that are automatically added.
So, when we pick an item up, we'll just say whether or not we want it to persist.
If we don't persist, we won't add it to the items data.
So, here we're going to add an optional bool.
Bool persist.
And we're going to default it to be true for now.
That way, I can just pass in false on the one spot where I want to override it.
Now, this is an optional parameter.
You can always do this and just give it a optional default value.
I try to minimize these though, one or two at most.
Usually one is good though.
So here we'll go down to line 68 and we'll say if persist and the data doesn't contain that name already or the item list doesn't already contain that item.
Now we'll go back to the part where we're calling this pickup and we'll just pass in false so that we don't persist this item.
All right, let's go back into Unity.
And here we go.
You can see that the error is gone.
And I can run over and grab our key.
Let's just take a look.
Blast a little bit more.
Blast a little bit more.
Run over here and jump across.
And my items should still be gone, but I still have no errors coming into the scene.
I don't have that key until I go back into uh level one.
And now I've got my key.
And again, this error, if we go back to the code, I just want to show it one more time.
The root cause here is just that it's going through calling pickup and then down here in the part where it was trying to bind to our data items.
Items hadn't data hadn't actually been set up because the item hadn't been bound to yet.
So that's why it was throwing an error.
But we do need to not store this data off because if we stored it off anyway.
So say we like maybe did something to save that and then stored this off later, it would still be invalid because it would be data that we don't want to restore when we bind.
Otherwise, we would be calling pick up again when we picked up the item and restoring from the binding.
So we want to do one or the other and not both.
And removing or fixing the error here kind of it also has the side effect of fixing our binding order so that we don't end up rebinding the item.
So let's go back into Unity.
Make sure that everything was still looking good.
I can go back and forth.
I can save and I can reload.
And then let's stop playing and go commit our changes.
So go into plastic and say uh basic player inventory binding in same scene and we'll check that in.
Now we're going to let our player inventory restore items across scenes.
So, really we're going to let our game manager do that.
We'll let it keep track of our item prefabs and then spawn the correct object as needed.
Here in our game manager, if we're not able to find the item in the scene and just bind up to it, we'll just ask the game manager to create an instance of it and give us that.
So, we'll say else we add some braces.
And here I'm going to say item equals and we already have item declared up here.
So, we need to not redeclare it.
Just use item equals.
And here we'll say game manager.instance.get item and then give it our item name.
And then finally we'll pick up that item assuming that the item exists.
So let's first make sure that our item is not equal to null cuz it is possible that maybe we tried to persist and reload some item that no longer exists and we don't want to try calling pickup on that and then bugging stuff out even worse.
All right, let's call get item and generate a method.
And inside of our get item, we'll make sure to add some logging for that, too.
So, we want to be able to get any item in our get item method or any item that we have as a prefab.
And to do that, we're just going to start by creating a simple list of all of our item prefabs.
So, we can make something like a public list of I item and call this underscoreall items.
And then we could do something like bar or let's say string prefab name equals item name do substring.
And right now I'm using a naming convention.
Let's just go take a real quick look at it.
We're using one of the default naming patterns.
We're just doing an underscore after the prefab name and then a number for the instance.
So before we get into anything more complicated, I'll just use that as well.
we'll just kind of substring it and we'll take everything before the underscore and use that as the prefab name.
So say the prefab name is the substring from zero which is the start index.
So we'll start at the beginning of the item name and we're going to go all the way up to the index of the first underscore.
So to get that we do item name dot index of and then pass in our underscore.
So this is going to give us a string that's from the beginning to the first underscore and put that as our prefab name.
Then I'll say var prefab not var var var prefab equals all items and we'll just do a first or default which is just going to find the object or null if it doesn't exist.
And we create a lambda statement here where we'll check the name of the object against the prefab name.
Now, if we don't get back a prefab, this is probably where we want to do that error logging.
So, we'll say if prefab is equal to null.
Then we'll do a debug.log error that we were unable.
Let's put a dollar sign in here.
Unable to find item and then we'll give it the item name and our closing quotes and semicolon.
Then we'll just return null.
And at the bottom, assuming we got a prefab, we're going not to not want to return that prefab.
We want to instantiate a new instance of it.
So we'll say return instantiate.
Actually, let's create a new game object.
Say var ob new instance equals instantiate.
And we're going to instantiate the prefab.
And then I want to make sure that we've set that name.
So new instance.name equal to the prefab name.
There we go.
Um oh, we've got one other issue though.
Let's return our new instance and then figure out why is this a problem? Why is this giving us an error? But the problem is really lying with what we've got here.
We have an interface right now for an object that we're starting to use more like a mono behavior.
In fact, even if we comment out um let's say we commented out all of these lines and just returned null right here, we're also not going to be able to see our all items.
Let's go take a look at that real quick.
we'll fix it and then we'll come back to here and finish this up.
So, if we go back into our project and I go look at my game manager, you see we've got the game data, we've got our all game names, but this new public field that I've added isn't showing up even though it's public.
The reason again is because I item is an interface and interfaces don't get serialized.
They also can't be instantiated.
So, we're going to need to change this up a little bit.
And one of the easiest things that we can do is switch this interface away from being an interface into being an abstract class.
Since we know that they're all going to be MonoBehaviors for our items anyway, it makes it pretty easy to just create an abstract class that inherits from MonoBehavior.
Before I go in here and rename and change things though, I'm going to make the change inside of Unity first.
I'm going to go find the file, go find my I item, and rename it to be item.
So otherwise, if I don't do this, I'm going to end up with multiple files.
I might end up with an extra I items interface just sitting around inside the project if I try to rename and move things around with Visual Studio.
So I'll rename it, let it reload, and then reopen the script.
And now we'll rename this from I item to item cuz it's no longer going to be an interface.
Ah, my rename didn't work.
Well, let's change this to a class.
This happens sometimes where it just does not want to rename, by the way.
Um, let's try it again.
Crl R-r R-r R-r delete and it's not not going to do it.
So I I'll probably just manually do that.
For now though, let's delete out our three properties here.
We'll make our use method an abstract or a public abstract void method.
And we're going to make this actually an abstract class as well.
We'll make this inherit from MonoBehavior that it's already trying to autocomplete.
And I've already got my braces there.
I'm going to do a quick build again and then see if we can rename this item yet.
Rename to item.
There we go.
After doing a build and kind of completing it, the rename started working.
All right.
Now, let's do a build.
Find our errors.
We're going to have a couple of them here.
You'll see we've got cannot convert key to item.
That's because key is right now a MonoBehavior and an item.
We just need to delete the key part or the MonoBehavior part so that it's already it's an item which is already a MonoBehavior.
And then we need to change it up here.
We've got our use method.
We're getting an error here saying that our key does not implement the abstract member item.
That's just because we don't have the override keyword in here.
Since we didn't have the override keyword, it was trying to overwrite or uh replace and it's not exactly the same and cause some problems.
So well causes that error especially, but also would cause our inheritance and our polymorphism to not work exactly properly.
sort of deleting out those extra lines.
All right, let's do a build and find the next error.
We should have one for blaster as well cuz blaster inherits from item or had item as an interface or I item.
We'll delete the mono behavior there and then add the override here.
Save and build again.
I think we've got a successful build.
Now we can go into Unity and assign our couple of items.
Before we do that though, let's create an item folder to put our items in underneath our prefabs.
So, just right click on prefabs.
We'll hit create and create a new folder for items.
And then we'll just move over our couple items.
We don't have very many.
Really, just our yellow key right now.
We'll create a couple more in a moment.
So, we're going to want to have them in a folder nicely organized.
Let's go find our game manager and then drag our yellow key into our all items.
And then the last thing we're going to need to do in our game manager is uncomment out that code that we commented earlier.
Get our new instance spawning with the prefab name.
It should now compile now that we've changed that over to be a game object and not an interface.
And now if we hit play, I expect that we'll be able to persist our key across multiple levels because our game manager is staying around and just spawning that up.
Let's go try it out.
All right, here we go.
We'll run over, grab the key, switch between my two items.
Uh, let's see if I can make that jump.
And here we are back in here with my key.
Let's jump on this key or the flag again.
And I've got my items.
Let's go do a quick save and a reload.
And everything is looking pretty good except for we've got this one error here.
And if we take a look at this error, let's just go click on it and dig in.
Right here it's on player inventory.bind line 76 being called by game manager bind by handle scene load.
So we're loading into a scene binding up.
Our player inventory is getting an exception right here on line 75 because it's call the items is changing as we're iterating over it.
Now I want to present this as a small challenge.
See if you can figure out why this is giving us an exception and what the fix is.
The fix is pretty simple.
It really just requires a change to uh one line of code or I guess two lines of code and they're not in here.
So take a look and see if you can figure out what's going on and how to fix it and then we'll continue on afterwards and I'll show you the solution and kind of hopefully give you a good example and teach you how to track these down in the future.
All right, I'm going to assume that you've either figured it out or you're ready to continue on.
So what's actually happening here when we call bind? We're looping through our collection or our list of items and then we're calling pick up on the item.
So, we're either calling pick up on the existing item or a new instance of the item.
If we go to our pickup method, which is right above and see that we do some stuff, all kinds of other things.
Nothing except for nothing related to items though until we get down right here.
I've got items selected.
So, you can see it's kind of highlighting right there, which is a nice thing to do.
Another thing to do to kind of find some of these errors, just select the the loop or the collection that's causing the problem when you're getting these collection modified errors and hit shift F12.
You can also find them there.
So see that here there's a scenario where we add them, which is this line right here on line 69, which is the only place where it's modified.
So what's happening? We're looping through the items and then we're adding items to the list that already exist in there.
So realistically, we don't want this persist method to kind of default to true.
We probably want this to be false and only add items to this list if they're new items, not if they're things that are being rebound to.
So we're going to change this from a true to false.
And I'm going to rename this variable to is new instead of persist.
Now that said, there must be some scenario where we want this to be true, right? Or when we first pick up an item.
So let's go find that use case.
To do that, we'll hit shift F12 on pickup and then look for the spot where we call it from outside of our other code.
And that looks like right now it's in key.cs.
In our key method, we'll just pass in true as the other parameter so the item can be picked up.
Now, this does make me think though, hey, our on trigger enter for picking up an item is right here.
Shouldn't that probably be up one level in our item? Should that be in our key? It's only in our key right now because the key is the only item that we have.
So, it probably should move up a level.
Let's take this and cut it and click into item.
And then we'll paste it in.
Now, we've got a reason for an abstract class beyond just serializing.
We're also reusing our pickup logic, which probably makes a lot of sense.
Let's save and go back.
We'll go test this one more time.
All right.
And we've got no errors.
We've got a key that we've picked up.
Let's go over to the other level.
Our key is still there.
I come back and it's still here and we've got no problems or no errors down below.
Let's stop playing now and go into plastic and commit.
We can now pick up of items across scenes now works and we'll check that in.
In the last section, we introduced a new concept and now I want to take some time to talk a little bit more about it and that's the concept of abstract classes.
An abstract class is essentially a class that's incomplete and only partially there or one that kind of defines the way that things should work and usually does a tiny bit of work on its own.
It's a lot like an interface except it can actually do things like it can have an ont trigger enter 2D method where an interface can't.
It can also be serialized really easily by Unity where an interface also can't.
There is of course one weakness or downside and that's that you can only have one abstract class that you inherit from unlike interfaces where you can specify a whole bunch.
Now to use our abstract class, we have to inherit from it and create another thing that is actually using it or creating an instance of it.
And that's what we're doing with our key and our blaster class.
And when we inherit from an abstract class, if there are any abstract methods on it like that use method was there, then we must implement those methods as well.
Now, if we also inside of our key perhaps, let's go to the item.
Say we inside of our key also had this on trigger enter 2D.
Let's go back.
Then this method would get called instead of the item one.
It would actually use this one and never call the item one.
And in fact, that could be a problem if I hadn't changed that.
If I just left this right here and I had this other version of a pickup that didn't persist, then my keys would stop persisting.
So, I'm going to delete that real quick and then we'll take a look at one other thing to know about abstract classes.
So, here we are in the editor and I've got my key selected and I'm going to take my item script and drop it on.
And notice I get a nice little error here saying that we can't add the script behavior item because the script can't be abstract.
So, that's the other limitation of abstract classes.
You obviously can't assign them to a component or to be a component.
And that's of course because they're incomplete.
An abstract class needs to have something implementing it for it to be useful.
That's the entire idea of it.
If it's not in that scenario, if it shouldn't if it doesn't uh need something else, doesn't need some other implementation, then it probably shouldn't be abstract.
And maybe maybe it should be abstract and you should just move that implementation around.
It really depends on your scenario.
But when it comes to items, things like that, I prefer to have a nice base class, an abstract base class that I can use for all of my core item logic and to be able to reference them and serialize them all very easily in Unity.
So that's abstract classes for you.
I've done a few videos about this on YouTube.
We go deep and talk a lot about different scenarios with them, but that's really the core of it and what you need to know.
Abstract classes are partially done classes that have methods that can either be fully implemented or overridable.
And a lot of the time the core use is that you're serializing or using this object in multiple places and then overriding one or more methods inside of there.
A lot of time it's just a single method and that can be that can be fine.
That's what we've got here.
All right, let's uh continue on to the next section, I guess, cuz that's all I've got and there's nothing for us to commit.
With our current platformer components, we can build out a full game right now, but it's not very easy because building levels still takes a lot of time.
We've got to create prefabs, place them, stretch them out, and get them all exactly how we want them.
That's a lot of work.
So, in this section, we're going to dive into a way to simplify that process.
We're going to switch over to using the tile map system.
In fact, we're going to use the tile maps along with our existing stuff and kind of merge the two of them together and get the best of both worlds.
The tile map system will allow us to build out big giant maps by easily kind of painting and literally just painting onto the tiles just like you would expect.
It's a very easy to use system, but there are a couple of interesting things that you're going to want to make sure to pay attention to along the way.
Now, before we dive into implementing the tile map system, pulling it in, setting up the pallets and all of that, I want to start with a quick level design.
Let's create a level that would be somewhat difficult to build in our current system, and then see how easy we can put that together once we've got the tile map system set up.
Now, I'm going to draw out my level design, and I'd encourage you to draw out your own.
Maybe change it up a little bit.
Don't do exactly what I'm doing, but maybe steal a couple parts or pieces from it.
So here I've got just an empty paint document.
I try to keep it as simple and unopinionated as possible.
You can really draw in whatever.
I usually just go with paper, but paper is a lot harder to represent digitally and show you on screen.
So let's start with something simple.
I want to have at the beginning of my level, let's just start with my player right here.
Let's get my little player right there.
At the beginning of the level, I want to have the end piece kind of already visible.
So, I want to have the exit be right up here near the entrance.
And then I'm thinking I want to have like a little teleporter here, a door there that you have to get to to jump over to the flag and make it to the next level.
So, you'll see that kind of exit right from the beginning.
From there, I think I want to go over and let's introduce a couple little basic concepts like jumping.
We'll add a couple little jump platforms.
Maybe add some coins here they can pick up.
Get a couple little things right at the beginning.
And then let's do a pit.
So go from there.
They'll go down into thinking a big pit.
And I want to fill this up with little frogs.
Those are my terrible repres.
Let's write frogs.
That'll be my representation of frogs.
And then here, let's do a bunch of uh one-way platforms to kind of jump up.
And I'll make the exit up higher.
So kind of fall in.
If you fall down to the bottom, you might hit some frogs.
And then you got to jump back up and get over the ledge.
From here, I think I want to do a ramp.
That's something that's pretty difficult to do right now.
Let's do like a a sliding ramp down here.
They'll kind of they'll go down that way.
And then maybe into um let's do like a water.
We have water already, so let's add some a little flat area here.
And then some waves.
In fact, maybe I could even put I don't think I want to put a boss fight here.
It's a little too early, but I could put something here.
It's a little bit interesting.
Maybe.
Let's do um another lump here.
And then um think how do I want to do this? What do I want? Like the uh thinking I want you to do some swimming here.
See what that's like.
Um and then yeah, I'll just add some platforms.
I'll just add a couple platforms that you can jump up to get or do I want to add moving platforms? I'm trying to think of what I want to put here for this water.
So I'm thinking I want them to go down.
They get to some water and then they've got to get up over this edge by um jumping out of the water onto some little platform here and then jumping up over I think that that's probably fine for now.
I'll figure out if I want to make it more complicated later.
I'll go down here once I get up onto this.
Oh, you know what? Let's put a um an enemy here.
So, let's put we've got that cat.
Let's put the cat right here with his little tail throwing grenades.
Boom.
So, he's throwing grenades over there and then you're dodging them while trying to get up.
And if you end up Yeah, that seems okay.
That'll maybe work.
Maybe I'll change it up a little bit, but we'll see.
Then from here, let's add a little platform and um actually, you know what? Let's just go straight to like some lava.
Let's do like lava and moving platforms over the lava so you don't want to fall in.
Do like a left right platform.
Maybe another left right platform.
Um, and then we'll go over here to the end.
And at the end, I want to change things up a little bit.
I'm going to switch colors.
I'm going to go to gray.
And I want to put like a castle here.
We have some nice castle tiles.
Do like a castle entrance.
And then in here, I'm thinking like some sort of a a maze.
Oh, you know what? Let's do a Let's add a break here.
Thinking like let's let's do this.
This would be like one castle and then another castle with a bridge across and like a little kind of maybe like a little maze puzzle thing where you got to jump up and then get kind of up to the top and then run across, come down and then grab a little key.
Actually, let's add the key in yellow.
So key down here in this corner somewhere.
So, I'm not sure exactly on this part of the design, but I've got I think the the first part kind of figured out.
And uh Oh, yeah.
With this key, we'll probably want to have a door, too.
So, we'll add one of those.
Let's add another door to the beginning, too.
And go down here and just add a little door right there with a yellow lock.
So, this will be the uh the lock that we go get the key.
So, we'll see from the beginning that, hey, we need to go get a a lock to open up this door.
You know, maybe I'll um think about it more.
Maybe I'll move that up a little bit.
So, put it on a platform like right up there.
Oh, let's go into paintbrush mode.
Put on a platform up here.
Um with a key.
So, there's like Oh, whoops.
Yellow yellow door with a yellow key.
So, you could jump up to there.
Maybe we'll add another platform so you can make it up there, too, so that it's visible.
Or or maybe I'll drag it down here.
I'm not sure.
I want it somewhere though that you kind of jump up, you got a key, you can get to it.
Um, you got a key, it'll unlock and open the door, then you can go through that door or kind of enable that door.
So, that's that's the plan.
Um, I think I also probably want to add a little piranha or something here.
We've got the the fish character.
So, I'm thinking maybe we'll add a um Whoops, that's erase mode.
Add some fish or one or two um fish swimming back and forth shooting off some spikes as well to make the the lava a little bit more um a little bit more threatening.
And maybe we'll add a boss over here.
I don't know something there.
Probably some sort of a challenge there in addition to the puzzle.
But that's kind of the core design.
And again, I think you should build out your own design as well.
You know, kind of copy this, take some good parts, take some other ideas that you've got and put them all down on a page.
And then I'm going to show you how we're going to go about building that in the next section.
All right, we're back in Unity and it's time to set up our tile map.
The first thing that we're going to do is create a new level to build on.
So that way we don't end up overwriting our existing stuff.
We can go back and forth and take a peek at what we've done before and see what we might want to reuse from there and not overwrite those changes.
So we're going to start by just saving our level one as a level three.
So I'll go file and do save as.
Make sure that I'm inside of my scenes folder and I'm just going to name this level three or whatever your next level is.
So go ahead and pick if you have more levels, use whatever.
Next, I want to disable the environment.
So, we've got this entire environment object here that has most of our environment objects or most of our world objects, the ground pieces and everything else underneath it as children.
So, if I just disable that, should see that most of the world except for these more interactive parts just kind of disappears.
And we'll worry about these interactive parts later.
We'll probably just remove them from this level.
In fact, you can just go to the B encounter here.
Let's do that.
And just uh disable that as well to kind of clear this out.
So, we've got a little bit emptier, more of a blank level to start with.
All right.
Now, we're going to begin our tile map system.
There are a couple things that we need to do.
First, we're going to need to create a tile map.
And then, we're going to need to create a pallet.
To create a tile map, we're going to go to game object, 2D object, tile map, and choose rectangular.
That should give us a grid with a tile map underneath it.
I'm going to name it environment, and hit enter.
Now, if you don't see the tile map option there, make sure that you've got the tile map package imported.
You should have it in if you created the project the same way.
But if not, you can go to package manager and then inside of the Unity registry section, scroll down and you should find the 2D tile map editor section.
Grab that, import it, grab the latest version, pull it in, and then you'll be able to create your tile map.
Now that I've got my tile map created, you can see I've got grids here, but um they're all kind of blank and there's not an easy way or visible way to do anything about that except for this little button here, the open tile palette.
And that's what I want to do.
I want to click this and it's going to pop up a new window.
Mine popped up off screen and it's a little bit small, so I'm going to make it nice and big.
We want to make it big enough that we can see everything in here cuz we're going to be creating a palette in here, setting up all of our different kind of paintbrush pieces that we're going to use and then painting with it.
So, to begin, we've got an environment here, but no pallet.
So, we have this environment is showing us which tile map we're on.
That's this tile map right here that's selected.
And the pallet is what we can paint with.
We can create multiple pallets, and that's what we're going to do.
And we'll separate the pallets out based on their use.
We'll do some for environment, some for the background, and then we can do some for other things like props or whatever types of things that we want to separate out on.
Let's do a create new pallet, and then we're going to name this environment.
I'm going to hit the create button.
I'm matching the names, but the names don't have to match, by the way.
So, just because I matched my names doesn't mean that they all have to match.
Now, I'm in the art folder, and I think I'm just going to drop this tile map into my root art folder right now.
and then I'll probably move it into a tile maps uh or tile pallets folder afterwards, but I think I'm just going to leave it in the root for now.
Now that I've got my tile pallet created, you'll see I've got environment here for my pallet and I'm on that map or the tile map named environment as well.
I can go into my art folder, go to my ground subfolder, go to my grass folder, and I'm going to select all of these grass icons.
So, I hit control A.
Make sure that they're collapsed though because if I have one selected like that, and I hit control A, this isn't going to work.
So, I'll collapse them all, hit control A, and then drag them right into this tile map area.
You can do them one at a time, but I find it's a lot faster to do them all at once.
Now, for this folder, it's going to generate tiles into a folder or into whichever folder I've selected.
I'm going to make this match with the visual tiles where the PGs are or the Yeah, I guess these are PGs.
All of our grass sprites.
So, I select that same folder and now you can see I've got my grass tiles here.
I can zoom in and out with the mouse wheel.
So, if you don't see it, just make the window a little bit bigger or grab this bar and drag it up.
There's also an option over here to hide the bottom part.
I turned that on and off so you can see um just the visual change there.
You can drag around with the m middle mouse button to pan and again zoom in and out with the mouse wheel.
Now, it's time to do some well tile map editing.
First, before we draw onto the tile map, let me show you really quickly how we can modify our tile pallet.
So, let's zoom in.
In fact, let's make this much bigger.
And let's say I just wanted to rearrange this.
You don't have to rearrange this, by the way, but there are some nice benefits sometimes for rearranging it.
And it's important to know how to rearrange it.
The biggest benefit is that you can select areas of the tile map and paint with them.
But if I selected this as a brush and painted with it, it would look kind of weird.
I might however want to make like a little platform though that's got a center piece like this, a right piece and a left piece.
To do that, I can go into tile map edit mode and then I can go select the piece that I want and then just click over here and paint it down.
Now, that does give me two of the same tiles here.
So, if I wanted to remove that, I could I could just go in and hit the erase button there and clear that out.
But it doesn't hurt to have multiple of them in there.
Especially if I want to create different sections like this where I've got this little platform that I can then just go out and paint.
Now, speaking of painting, I think it's time that we give it a little try.
First, let's take the tile palette and we're going to dock it down here.
I'm going to grab it and dock it right here on Let's go with the lefth hand side of the project view for now.
Thinking the right hand side might be better, but I'll leave it there for now.
And I'm going to select this tile right here, the middle one with the grass.
And then we're going to go into paintbrush mode.
In paintbrush mode, wherever I click, a tile will appear.
So, I can just click and drag.
And you see the tile appears.
I can drag down here.
Oops, I get some extra tiles.
That's okay.
I just go over to the eraser and hit erase.
Now, if I want to draw a grid or a big chunk of ground underneath it, I probably don't want to go like this and start painting and dragging all around.
It's a little slow.
So, I just use the fill area or the paint a filled box, which is U for the hotkey.
Click, drag, and now I've got a nice big area.
again.
Mouse wheel to zoom in and out and left mouse to move around.
So now I've got the core of my intro part or the that base piece that I had.
Let's take a look at my map again.
All right, here we are.
So I've got my character is going to start right here.
Then I wanted to have a wall up there with a flag on it.
So let's add a wall next.
Let's find um well, let's see.
What do I want to add for a wall? I guess we could just use a big piece of dirt for now.
Do a big tall wall right here.
In fact, I probably drag this out a little bit so that it goes way past the edge of the screen.
And then we'll put a little ledge up there.
So, I want the ledge that looks like Where's the one that I want? I Is it this one? I'm thinking it's probably that one.
And we'll put one of those like right up there.
Let's see.
Zoom in.
Oh, that doesn't have a rounded corner.
Oh, that's the one I want.
Oh, here.
There.
We'll just add two.
And then I'm going to take my flag.
And the flag I'm not going to do as a tile map piece because these flags are interactable objects.
And while you can make tile map pieces interactable, it's not quite the same and it it's quite a bit more complicated and it'll add a lot of complexity that we won't really gain anything from.
So for our interactable object, we'll just place it right up here.
So now I've got the beginning of that level for real.
I've got kind of the the key piece up here that I want to show them, and I've got a bunch of extra junk.
But if I save and press play, I'm going to expect that my character is just going to fall right down through the ground.
Let's hit play and watch.
So, the reason for that is pretty simple.
When you're building out a tile map game, you probably don't want colliders automatically everywhere on the tiles, right? I mean, just like sprites, we don't want everything to have a collider on it.
So, we have to tell the system what should have a collider.
So, we're going to go to the grid and go to the environment object or the subobject there.
And we've got our tile map and the tile map renderer.
We're going to add a tile map collider 2D.
You add that tile map collider 2D.
We leave all of the settings default for now and press play.
And we should now find that our character can land on the tile map and land.
Let's see.
Can run around.
I can hit that wall just like I would expect to.
And I can even almost make it up to that flag.
You can see I can jump and get pretty close.
Things are looking quite a bit better.
So, let's save and take a real quick look at what we've done in plastic.
So, if we go to plastics, see the project settings is not important either.
Is that temp one? We've got our level three.
That's that's something we've actually added.
And then we've got all of these ground assets.
So, these are the tiles that we've created.
You can see over here to the right that it's got a couple of fields on there.
We've got the sprite showing which sprite the tile is for, obviously.
The color if we want to have some tinting, and then the collider type.
We can have none, grid, and sprite.
If you're curious what those do, the none option just makes it not have a collider.
Pretty obvious.
So, if you want to have a section with colliders and have a specific sprite that doesn't have a collider, you can just set that to none or that tile type to none.
If we use sprite, then it will use one based off of the sprite's outline.
So, imagine we've got our ramps.
We're definitely going to want those to match with sprite.
And then, of course, there is grid, which just matches with the cell shape.
So, matches with the actual grid.
So kind of just gives us a square in this case.
Other than that, the only file that we have changed is our environment tile pallet down here, which is this this prefab.
So let's say that we've added our first tile pallet and commit our changes.
Added first tile pallet and started level three.
And we'll check that in.
All right.
All right, now that we've got our tile map and our pallet, let's do some more level building.
Now, we're I'm going to go through the process of building out most of this entire level minus the boss fights and let you kind of follow along.
And again, I'd recommend that you follow along, but make your own modifications.
Add in some different tiles, add in some different, you know, designs and make it your own level as well.
Don't just copy me because that's not nearly as interesting and not nearly as much fun.
All right, so what we've got here is just this beginning part.
I've got my character.
I've got the flag there.
I want this other ledge up there with the door.
And then I want to add in these two ramps and the coins next.
So, let's start with um let's just add in a little platform up top.
First, I'll show you that part that I was talking about where we can select and paint big pieces.
I'm going to begin by just copying this platform and pasting it over to here.
I just got to make sure edit mode is on and it looks like it is right there.
So, I'm going to use the eyropper.
We'll take the right piece and then paste it over here.
And then I'm going to go remove that duplicate right piece and then use the eyropper again.
I'll click and drag to select these three pieces.
That's that kind of platform.
Notice that's now on my clipboard.
And I can paste it.
I'm thinking I'll put it like uh I'll put it over here.
I want it to be somewhere off to the right where you can see it, but you can't kind of make that jump.
Thinking maybe like about there.
I might have to move that up a little bit higher later, but luckily that's pretty easy.
All right.
So now I've got my platform there that they're going to jump across.
And that should match up.
Let's bring up my platform one more time.
That should match up with kind of this.
So, it would probably Yeah, it's going to be a little bit more to the right, but let's add these other uh platforms to go up and up.
I'm going to do that next.
So, we'll zoom out.
I'm going to go to the normal tool.
Let's go eyropper.
We're going to take the ground piece here.
And I'm thinking this will be up like two.
So, right around there.
Probably maybe like five wide.
And then we'll go up and over again.
Is that six? Did I go five or six? One, two, three, four, five.
Okay, cool.
Five and We'll do five and five.
Then I'm going to add some ground underneath.
Oh, it's not ground.
Where's the fill? Phil, fill.
Phil, where are you? Did I lose my ground mid somehow? Did I I must have painted over it.
Okay, not a problem.
Let's go find that tile.
So, if you lose a tile, I've got my grass mid right here.
Somehow that disappeared.
I Oh, no.
That's not the one I want.
I want the grass.
Where's the center one? Grass center.
If you lose a tile, you can just drag the actual tile right back out.
Grass center.
This is it.
Where's grass center tile? There we go.
Oh, the tile is wrong on that.
Oh, never mind.
It was just my clipboard was showing it wrong.
Got it.
So, there we go.
I've got my center piece again.
I don't know how I accidentally deleted that.
Got that selected.
Let's go select that.
And then we'll go to the paint mode and we'll just drag and fill.
So, we're going to drag and fill to there.
Let's try that again.
Drag and fill.
Zoom out a little bit.
It'll work better.
And then drag and fill.
Gonna get this whole uh whole ground area laid out.
So that gets me this and this.
I want to move that piece over and get my coins over there.
So let's go find all of my coins.
Next, I'm going to go grab my coins that I've got.
I've got a couple of them here.
I'm going to take uh let's take one, two, three, four, five coins.
I'm going to move them up here.
And I'm thinking I want to make them linear.
So go L 1 comma 5 and then a Y of zero.
There we go.
And then I'm going to click and drag them.
So the L one to five, by the way, just split them out one meter a piece.
So you do L is linear.
And then the distance, the start position and the end position.
So one and five are the X values that we would give it.
And then it will distribute them across.
So give them 1 2 3 4 and five.
And then that just put them 1 meter away from each other.
Now I've got a couple coins nicely placed.
Uh these other coins, I don't know what I'll do.
I'll move them around.
I'll use them later.
I'll just put them up here for now.
I I might use them later.
I might just delete them.
In fact, yeah, let's just delete them.
Clean things up.
No reason to leave coins here if I'm not actually using them yet.
All right.
So now we've got that done.
Let's move this platform next.
So I said I didn't like that position for it.
I'm just going to select it.
Let's do the do that.
And then we'll paint it.
Thinking like up here.
There we go.
And then erase the previous one.
All right.
Next up, we're going to do a pit.
So, we'll do the big pit with the frogs in the bottom.
So, to do a big pit, pretty simple.
Just go down here.
Oops.
Go select the eyropper again.
Grab my ground piece.
And we'll just do a pit that starts like down here.
And then we'll fill in that ground below it.
Ah, whoops.
I painted over my I should get out of tile edit mode.
Then I won't accidentally paint over my tiles.
It's a much better option.
All right, there we go.
Now we'll add that sidewall again that they've got to jump up.
See, it's going to be up like this or so.
Let's go take a look at that.
So, they come down and there's these little platforms going up and then there'll be a big ramp and then a drop off.
So, let's do the big lift up here.
Go up maybe even one or two more higher.
And then we're going to add some platforms in here.
We'll add oneway platforms in just a little bit.
Let's add the ramp going down next because I think that's a slightly more interesting and important part.
So, to do a ramp going down, first we're going to want to put some grass at the top.
So, go select my grass, go zoom in, and take a look.
Okay, grass looks good.
Next, we're going to add a corner piece.
So, take this corner, just drop it right there, and we're just going to go all the way down one at a time, filling in these ramp areas.
Now, there might be a way you could put together a nice, and there definitely is a way you could put together a nice tool to automate this, but um it's a lot more work than it's worth for just doing a couple ramps.
So, we're just going to put this in manually and just drop in paint in our couple quick ramps.
You can see how easy they are to paint in.
They go pretty quick when we've got a system like this.
And it's super flexible.
All right.
Next, we'll add in the grass center pieces.
So, that's going to be this.
And here, just go straight down a lot of time.
Just kind of going straight down from here until Oops, that's too high up until we kind of fill in the area.
The problem is you can't go below.
Um, you can't go to the right of the tile there at the top.
So, got to kind of just go down and slowly say slowly, but it's not really that slowly.
Some somewhat slowly fill them in.
All right, almost done.
Oops.
Got one little miss spot there.
And then finally, some more grass down here.
You can see how easy this was.
Oh, and then we've got a a spot for our little triangle right there.
Bam.
Now we've got a nice beautiful ledge that is just going to work and we didn't have to do a whole bunch of extra work to create it.
Looking good.
Now at the bottom of this I wanted to create some water and we're going to do water a little bit differently because our water's collider won't be the same as our regular tile map collider.
We're going to want to change that out and we're actually going to create a separate tile map for that.
So as a placeholder I'm just going to put in some grass here and then well actually let's uh let's add in a water.
Well, no.
I'll just add in grass.
We'll do some grass that's very obvious like this little platform here.
Um, that's going to be water.
And then we'll fill that all in in the next section when we add in the water tile map.
So, now I'm going to add in we'll put water right there.
Then we'll go up here with another ledge.
Just kind of matching what we've got here.
So, we'll go back up and kind of match with that ledge height.
And we're going to put a big old cat, an enemy cat right up at the top of that.
So, let's go up like that.
And then, oh, okay, we got to go down one more block.
And I think I want to expand this out like four wide or so.
We'll add some grass to the top.
And then we've got our cat.
Let's see if we can find my cat boss in my prefabs folder.
There we go.
And we'll just add him right up.
Oh, let's get out of uh out of tile mode.
W.
There we go.
And uh oops, I moved my cat around.
See? control shift F and zero on the Z.
That'll move it directly to the center.
By the way, on 2D projects, hit control shift F, move that Z position to the zero, and you got your uh your object right there in front of you.
So, here's our cat showing up.
I think he's looking good.
We just want to flip him around so that he can fire.
And let's just go double check my pool manager.
I know that I Yeah, I lost my cat bomb prefab earlier, so I'm just going to go reassign that in here.
And then apply overrides.
Okay, cool.
So now we've got our cat added.
The next piece will be a lava pool which probably also be a separate layer just like the water like I was talking about.
So let's add that out and then add in the castle piece and we'll start putting together those other layers.
So let's add in our lava area.
And I'm thinking again we'll just do a short little thing here.
So this will be the Oops.
Let's clear that out.
Didn't mean to paint like that.
I want to use the drawing tool so I can do a bigger line.
Thinking like maybe like that with lava and then a couple moving platforms here.
So I believe we have some moving platform prefabs already.
So we can just go take a moving platform and just drop it right up in here.
Got one.
Let's just duplicate it and add another one.
I'm thinking we'll have like yeah three platforms should be good.
And we can adjust the size and look at those in just a moment.
And then we'll go back to our tile.
And the final thing we have is the castle area.
So at the end of the lava, I want to go up onto some grass and then go into a castle.
So we'll say ground right here.
And again, this is all going to be lava in just a moment.
We'll add in a little piece of grass to the edge right here.
So we got this little uh Oh, no.
Let's just go with um a flat one.
the flat one without that icon there or the graphic the circle little cutout spot there.
And then we're going to go into castle area.
So for the castle, we're going to need more tiles.
We're going to need to have the actual castle tiles.
So go back into my ground section and I believe it's stone that shows all of the castle pieces.
Ctrl+ A again.
Select them all.
As long as it's all PGs and shows up as the texture settings up here, texture import settings.
Nothing else is in there.
I should be able to just drag them over and then put these into the stone folder.
And suddenly I've got a bunch more tile maps or a new bunch a bunch more tiles in my tile pallet.
All right, I'm going to take the castle piece and just draw out Oops, that's not it.
Draw out a big square for my castle.
I'm thinking it's going to be like I don't know around that big.
Looks like a decent size.
We'll put in a ground piece like the top that the player will walk along.
And then we're going to add in a couple more spots.
So, I want to have like a a left hand side of this, like a wall, I think.
Um, and have one of those big entrances and uh probably a couple platforms in the back.
But I think we're going to need some more castle graphics to really make this the way that I want.
Thinking about it, I think I'll go to the KennyL page and grab a couple more of those.
So, let's just plat let's uh kind of placeholder this out for now.
Get a rough idea of what we want.
So, I'm thinking we've got the big castle and then two like a split there and a bridge or something.
So, do like a big castle like this and then maybe another big castle like that.
And then this would be these will be like the background pieces and then the key is going to go over there.
So, the capsule part's not quite done, but we've got the rough layout, I think, of what I want to put together, and I'm ready to move on to adding in our new layers and setting up the rest of the tile map sprites.
So, let's save our scene, go into plastic, and say we've added initial level three design, and check that in.
It's time for us to dive into water and lava.
So, how are we going to deal with water and lava in a tile map situation? I mentioned before that we don't want to put them onto our basic tile map or our main environment one because well then they're going to collide just like they would normally with the player, right? So, our player would just walk on water.
That's not really the effect that we want.
And if we landed did the same with lava, well then obviously we'd have to do something special to make all of the lava tiles do damage as well, too.
So, let's actually start with the lava and then we'll dive into water because it's tiny tiny bit more complicated.
So, for lava, what we're going to do is take our three lava sprites right here.
And in fact, I think yeah, just the three lava sprites and then drag them right over to our tile palette for our environment.
I'm going to put these into the correct folder.
So, that's in art and tiles where the lava tiles are.
And now I've got my lava tiles in here.
So to paint my lava tiles out, I'm in my lava section.
I could just select this and start painting and dragging these out.
But then they're going to be on this environment and I'm going to have that problem where I can walk on them.
So what we can do instead is I'll just hit control-z.
I'm going to go to the grid.
I'm going to go to game object 2D object and I'm going to go to tile map and rectangular.
And look at that.
We've got an additional tile map.
I'm going to call this lava.
And then on that lava tile map, so I'll select lava right here.
We're going to draw out that lava.
So, select the lava, zoom, zoom, zoom, zoom, zoom.
Let's see if I can get over there.
Yep.
Mouse wheel and middle mouse button worked just fine.
Oh, but my painting didn't go down.
There we go.
So, now I've got my tiles.
And you can see that the grass is actually behind them.
It's actually painted onto that layer behind them on the other tile map.
So, I also want to go disable the lava temporarily, go back to the environment tile map, and make sure that I erase those because I don't want this grass piece just sitting back there and the player running along it.
So, we'll just delete all of those and then reenable the lava.
So, now I've got my lava.
I can see the lava showing up again.
I'm going to add in the pieces underneath the lava.
So, I'll just click and grab the box mode.
There we go.
Not paintbrush mode.
And drag it all the way down so that we've got lots and lots of lava.
Now I need to add in a collider.
So we're going to add our tile map collider 2D just like before.
So what's the difference? Well, we're also going to add the damage player script to it.
So if we add the damage player script to the lava, any tile that they hit that has the collider on, which is going to be by default all of them, is going to cause them to take damage.
So let's save our scene now and move our player out and just verify that I'm not crazy.
So, I'm going to select my player, control shift F, zero out that Z position again, and then save, and press play.
Got our player right there.
Expect he's going to fall down, hit the lava, take some damage, and go bouncing up.
Boing.
Look at that.
Taking damage.
Everything is working as expected.
And if I'm able to get over here to the ground, look, there's the cat.
There we go.
You can see everything is kind of mostly working.
and jump down here and fall into the pit where I'm going to put our water next.
So, let's stop playing and let's go do the water next.
So, for our water, we're going to add in another tile map.
Go grid, game object, 2D object, tile map, and rectangular.
We'll call this water.
And now, of course, we're going to create our water tiles.
So, select all three water tiles.
Drag those down as well.
Put these into the tiles folder.
And then with the water tile map selected, we'll go down to our section that's going to be water, which is right here.
And we'll just paint on our water.
So go select my water, paint it right over.
I'm thinking uh let's do it even on that entry tile.
So they slide right into the water.
But then, of course, that also means I need to remove those tiles from the environment.
So I'll disable water.
Go to eraser mode.
Bam.
Turn water back on.
And look at that.
I've got my nice, beautiful water.
I got the wrong water visual, though.
So, I'm going to switch it to the water top.
Oops.
Am I on the right wrong layer? Control-r Z undo.
Let's go to water layer here.
Drag and draw.
Perfect.
And then we want to Oh, I accidentally added an extra spot there.
I want to fill in the bottom part here with our our square water.
Like that.
There we go.
That's looking better.
So, now what do we do for the water? How do we make that work? Well, we're going to add our collider just like before.
See? Tile map collider.
But then we'll just add in a buoyancy there.
I cannot spell buoyancy.
So add in our buoyancy 2D.
And on our tile map collider, we'll just hit the used byector.
And then of course uh is trigger because it's a water.
So it has to be a trigger with theector in there.
And now I can press play and move.
Let's uh move our character over there though.
So control shift F or W.
Here we'll just move them right there.
play.
Watch him drop down and fall into the water.
All right, there we go.
And you can see that I'm sitting way on top of the water.
So, we'll just go to the water section here and start adjusting our surface level and our density.
So, I think I actually just want to turn the density down to whatever it was, like a 0.5 or 0.2.
I've forgotten my value now.
Yeah, 0.1 seems about good.
And then finally, of course, we've got to adjust the layers.
So, let's uh right, if I do it at runtime, it's going to not save.
So, if we change that to water, you see that's what it should look like.
So, we know that that needs to go to water, and that should go to a 0.1.
Let's stop playing.
Change this to a 0.1.
Change our sorting layer over to water and save.
So, now we've got water and lava both working.
I'm going to commit that into plastic.
Water and lava both working.
And we'll check that in.
Before we dive into our castle tile map, I want to fix up the beginning parts that we've already created.
Let's go take a look.
If we press play now, first thing that we're going to see is that our platforms are flying over to our face.
You can see the little indicators of them there.
Let's see.
See that? that starting platform.
Those are the moving platforms.
It's because we placed them, but we didn't set their positions.
And also, I feel like our jumping and our movement is probably a little bit too strong.
I can almost already jump up to this platform here, and it's going to be very difficult to limit and kind of set my player bounds if I can jump and move exactly as fast as I can.
So, I'm going to make a couple quick little changes.
First, I'm gonna find my player and I'm going to figure out a slightly lower jump value and maybe a slightly lower speed.
I'm thinking maybe like a 3.5 and a 3.5 for the velocity so that he still moves pretty fast but not too fast.
And when he jumps, it takes a double jump to get up like these ledges here.
I don't want a single jump to make it up, but double jump seems good.
Now, getting pushed by that thing is definitely a problem.
So, I'm going to stop playing and then go reset my player values.
3.5 and 3.5.
Of course, you can come up with whatever values you want, but I think this is a pretty good number based on the size and scale that I'm going with.
And then we're going to go adjust these moving platforms.
See, we've got the indicators for them, the gizmos over here to the left.
And that's because we haven't used the rightclick menus to set position one.
And then go over here and rightclick and do a set position two.
Remember, this is how we determined where it would move.
So, now it'll go from that spot to that spot.
Let's do the same for these other two.
I'm just going to do a let's say right now that's probably a good end position.
So I'll do set position two.
And then I'll drag it over here a bit and do a set position one.
one.
one.
Then I think I'll do the same thing for this middle one.
Let's go over here will be position two.
And then to the left a bit will be position one.
All right.
So now my platforms should move right.
And I should be able to jump about the right amount.
Let's press play and see.
So, run over here.
Go grab my key.
A double jump gets me up.
A double jump gets me up.
And now I can double jump onto this platform.
I can't quite Oh, I missed my jump, but I definitely could have made that.
And then I'm down here in the frog pit and I'm going to need a way to get out of here.
I wanted to fill this up with frogs.
The frogs happen to already be here kind of perfectly lined up.
Um, let's move myself up.
So, drag up.
Let's go to 30.
Oh, I'm not on myself.
That That's the the moving platform.
Grab my character.
There we go.
Move him up and uh to the right.
Just kind of cheat him up there.
There we go.
Run down a ramp into the water.
All right.
What's going on with the water? So, water layer is definitely wrong.
Go double check that as well.
That's under our grid and our water sorting layer is set to player.
That's the problem.
That should be on water.
Okay, cool.
So, now I've got my water layer and I can jump up here and Okay, I've got to get my exit.
So, let's stop playing.
We'll do those little changes.
We'll change that water layer to be on water.
And we're going to add in our one-way platforms.
Now, to get oneway platforms out of here, we've got a couple options.
I could just take our existing one-way platforms and just drag these out here.
This definitely work.
But since we have the tile maps, let's use the tile map system instead.
We're going to go to game object and create a new tile map.
Again, 2D tile map rectangular.
We're going to call this oneway platforms.
And then in here, we'll add another tile map collider and an aector.
So, we need a platformector 2D.
We'll go to the tile map collider and check the used byector option so that our player can now jump through any tiles that are placed on this one-way platforms uh grid.
So now I've got that tile map grid set up.
I'm going to go select it and then we'll go add in a couple platforms.
So I'm going to go select these areas, use that eyropper, go grab the three platforms, and then I'll paste them in.
Let's go one here, one here, uh one here, and then maybe like one more.
Oh, let's do it like right out here.
Straight there.
So, you can go straight jump right up into it.
Let's save and press play.
And now we should have a bunch of one-way platforms that our player can jump right through.
We'll run over here.
Run, jump, jump, jump, and jump.
And we've got our platforms.
You can see I definitely fall into them.
The frog hurts me.
And I can jump up onto these platforms.
and probably make it all the way across.
Let's see.
Looks like that worked.
Okay, looking good.
Now, we need to add a couple of those little one-way platforms to escape the water area.
I'm thinking here we'll do something slightly shorter.
Let's put um let's do this.
We're going to take two of these pieces, paste them together.
So, we'll do eyropper.
Oh, got to go to edit mode.
Eyeropper on the left.
Paste it right there.
Eyeropper on the right.
Paste it right there.
Eyeropper on both.
And now I've got a little 2 by 2 platform.
So, just go drop a couple of these out.
And these don't have to be oneway platforms, but since they're on the oneway thing, they they already are automatically.
All right, we'll save that.
Play again.
Just wanted to go double check that my platforms work.
So, we'll take our player and cheat.
Drag him right over, run over to our platforms, get into the water, make sure I can jump out of the water, and go across.
It looks like it's working.
Now, one thing that's worth noting is that my uh cat bombs are disappearing before they hit the ground.
You see that? They they end right there, and that's because of their lifetime.
So, let's go fix that.
Next, we'll go catbomb.
And if you remember, our cat bombs have a maximum lifetime amount.
So max lifetime amount.
Let's just crank that up to 10 instead of five.
Then these cat bombs when they the new ones at least that spawn would come over here and land.
The ones that we're getting right now aren't because they already exist and pulled.
So I got to go select them and just change those values to 10 as well because they're getting reenabled.
They're not getting reinstantiated.
So those values aren't changing.
There we go.
So now you're seeing ones that last longer.
That other one did it not get the uh uh I didn't change the value.
That's why my multi-edit failed.
All right.
Now they should all do that.
Well, assuming that all of them have the Yeah.
Cool.
Okay.
Looking good.
Let's zoom out a little bit.
And the last part we've got to deal with is our moving platforms and fish.
It looks like the moving platforms are already moving and kind of working pretty well.
Let's just double check that our player can get across it.
So, hit the player, go right here to the center, control shift F, and we'll zero that.
Oh, and then I killed myself.
Well, I'm pretty sure I can jump across.
So, I'm going to go into plastic and make another commit that we've added oneway platforms and fixed cat bombs and moving platform positions and check that in.
It's time to set up the castle now.
And to do that, I want to grab a little bit more art.
I'm going to grab the platformer medieval pack from KennyL.
Just go to KennyL and search for castle.
And you can grab this platformer pack right here that's full of a bunch of different tiles.
I'm going to use the side tiles and the doors and maybe the windows and a couple other pieces to build out a little castle that our player can kind of run along.
So, go ahead and download that.
Once you've got the pack downloaded, open up the PNG folder, select all of the files, and hit C to get them onto your clipboard.
We're going to go back into Unity in the art folder, rightclick, and create a new castle folder.
So, create a new folder, call it castle.
I'll open that by right-clicking and hitting show in explorer.
Hit enter to go in and paste to get all of my castle tiles into there.
Once that's done, I want to make sure that I fix my pixels per unit.
They're going to be wrong.
I think that some of these other things are uh let's see.
Yeah, these are 70 and it defaults to 100.
So, I'm going to select them all.
all.
all.
Make sure that there's no thumb file or anything selected so the popup shows correctly.
And we'll change that pixels per unit from 100 to 70.
Scroll down and hit apply.
It's just going to go nice and slow cuz I got so many objects selected.
And that should fix up my tile map or my my tiles to be the correct size.
Next, we're going to create a new pallet.
So, we'll go to the environment palette here and hit create new pallet.
And I'm going to call this castle background.
Maybe I'll just call this castle.
Actually, this is just going to be all the castle assets.
I'm going to put that into the art folder.
Remember, this is that tile map file.
So, I'm just going to put the tile map file, tile pallet file into the art folder.
And then I'm going to take all of these medieval tiles, select them all again, and drag them right in to create a new tile map.
There we go.
We'll do a select folder here, but we want this to be in the castles folder because this is where it's going to put all of the individual tile files, and I just want them to be side by side with the textures.
There we go.
Now, I've got a beautiful new tile map that I can start using to paint out my castle.
So, there are a couple things I want to do.
First, I'm going to just clear out what I've got here.
I've got my base, but I just kind of wanted to get my uh rough idea of where I want it to be there.
And now that I've got that, I'm going to just delete it.
Got my environment selected.
to go to selection tool and select.
There we go.
Get all these tiles and hit delete.
And oh, let's get these ones up above, too.
And oh, I missed my delete.
There we go.
Select and clear them out.
All right, cool.
Now, let's add in some wall pieces and a background.
So, I've got my environment layer here.
I want to add in a castle background layer, too, where I can kind of fill stuff in.
But, I think I'll do that after we add in the walls.
Let's add in the parts that matter and then we'll fill in the background so that it looks like a castle and not just a black area afterwards.
So, I'm going to add in a left side.
And I believe the left side graphic is right here.
It's this one with a little wood piece on that kind of left.
And I'll go to draw mode.
We'll go over here a couple pieces over and just draw up a big uh a big line there.
See, did I get the right one? It doesn't look like it.
Looks like I've got the wrong object there.
So, I'll select again and redraw it.
There we go.
Now, I've got my my left wall there, which is going to be the edge so that you can't kind of get out so that hey, this is the the edge of the castle.
There's no exiting it.
In fact, you know what? I think that now that I think about it, I might want to put that on the other side.
Do a right wall because this is going to be on kind of the inside here.
So maybe uh maybe it'll look cooler like that if I got a right wall there like that that you can't get past.
And then I'm going to add in a top piece.
So we'll do the top I think is just going to be like this castle looking thing.
I like that.
And then we'll do uh well let let's add in the the pieces that the player has to jump on next because I think that that's probably the most important.
First we'll clear out that little entrance right there.
And I'm going to add in a big door.
So, I want one of these big open doors.
I'm going to just select uh let's go eyropper.
This big open door right there.
That piece right there.
And then we'll drop it in right here.
And next, we need the center parts for it, which I think is this right here.
We'll drop that in.
And then the bottom.
Oh, I guess we just do that same thing again.
Bam.
Look at that.
And then we'll add in a top.
Make it nice and pretty.
Look at that.
Looks nice and fancy all of a sudden.
And then we're going to add in our platforms and our blockers for the player to move around.
Now, the plat platforms and all that stuff are in our environment tab.
So, I'm going to go back over to the environment tab.
And I'm also going to add in some boxes or crates.
Do I have those already? Let's see.
Got boxes.
Let's go find the box single and box double and box crate.
And I'm just going to drop all three of those in here as well.
Put those into the tiles folder.
I'm gonna use those to kind of build out this castle here.
So, I want to have a few things.
I want to I want the player to get like partway across and then do a jump across and then come Yeah.
So, like they're going to jump and then come across here and then get the key maybe over here.
So, I'm thinking like the the main key will be like right around that area somewhere.
So, they're going to come in and do this like little uh not super complicated challenge, but you know, we'll just build out like a little maze here.
So, there's going to be a wall here in the center or something that's blocking them.
So, they won't be able to get across here.
Um, and then I'm thinking a bridge across the top there.
So, let's go add in a platform here that they'll So, they'll run in, come maybe all the way to the end here.
Let's get rid of that piece there.
They'll come all the way over to the end.
Let's add in some brick walls here just as a uh end piece so they can't go past that.
Um, and then they're going to go up.
And maybe I could add in a boss or some enemies or other things in here as well, too.
But for now, I think we'll just go like this.
And um, let's go with a platform here and fill that in like that.
I'm thinking somewhere right around like this.
They'll jump up, go back and forth up until they get to the top of the castle.
Go back to that castle tile map one more time.
And again, I think you could probably come up with a a much cooler design than uh the specific little one that I'm doing here.
But I want to show you how to how to kind of put all of these things together and then let you build out whatever you think will be super cool.
All right, let's add in a wall piece here.
Whoops.
Not on the right tool.
Got to do the the line drawing tool.
So, go from the top down to the bottom and fill that in.
And we'll do the other wall here on the other side.
Top to bottom.
And filled in.
All right.
We are drawing on the environment layer here, though.
So, I'm going to need to add in a little hole to drop down.
And then we're going to go back to the main environment tab and add in a couple more platforms for our player to land on and kind of explore down.
So they land there, come down, and then I'll have two ways that you could go down.
There's one there, and maybe the uh the far one will be the correct one.
So the close one will go down like that, and maybe a dead end.
Or here, let's do a do an opening there.
And then a dead end, if I can draw it.
I find the right tile.
Nope, I had the wrong one.
They're like that.
And we do like some box crates right here to kind of fill this in so you can't get across.
Um, can't get across here.
And a couple more pieces.
So, we'll do another line there.
Yeah.
And then we'll put the key right down here at the bottom.
So, let's just go to key, select that key, uh, control shift F.
Zero out that Z again.
And I'm thinking like right around there.
Let's drop a couple crates in though so that our player can also jump back up and get out.
So add a couple of these.
Um Oh, got to go to paintbrush mode.
Right about here.
Thinking like one or two.
Oops.
Did I select the right one? Paint eyropper.
There we go.
Get our crates there and drop them right in.
So I got a a couple crates placed in here.
Um, I do want to clear out these other crates though because those aren't supposed to be there.
So, let's go to select mode and we'll just select and I'm actually going to get rid of the ground pieces right below it, too.
Let's select all of that and make sure that we're on the correct layer.
Got environment selected.
Go reselect those again and hit delete.
There we go.
Clear those out.
Then I'm going to go to lava and we're going to paint in some lava.
So let's just do Whoops, wrong button there.
I painted a lava over that.
Make sure that I'm not in tile edit mode.
Eyeropper.
Select my lava.
Drag that across.
And then we'll do eyropper again.
Select the internal lava.
And then oh whoops.
I thought I had fill.
Whatever.
We'll just paint that out.
Okay.
Let's get that last piece.
So we'll eyropper that one.
And then did I not do an eyropper? eyropper.
Click paint.
Oh, I'm on the wrong layer.
That's why.
So, these ones actually just need to get removed because I painted lava on top of the environment layer.
All right.
So, now I've got lava there.
I've got a way across almost.
I need to add the bridge.
So, we'll take the bridge tile.
Drop that right into here.
Put this into our tiles folder.
And now I've got a bridge.
We'll drag that across as well.
So now our player can get across, not fall into the lava.
But it looks a little bit menacing anyway, and then um hopefully get that key, make it all the way back out, and then uh pass the level.
I don't know that I'd necessarily love my level design, but I love the fact that I can now very easily modify and adjust this thing.
So let's hit play and just run through it real quick.
and make sure that everything is working kind of as I expect before we finish up the key functionality and the door to continue on to the next level.
So, we go.
We've got our key.
If I don't miss my jump, I can make it over to here.
Oops.
Come run down the ramp.
Got some cat bombs.
Ow.
Got hit in the face with cat bomb.
Jump up.
Jump up.
Jump up.
Oop.
Switch back weapons.
Hopefully my cat is killable now.
Oh, he's not.
I've got to fix his uh his death real quick.
But for now, I can jump into the lava.
Let's see.
Can I make that jump? Made that jump.
And then we get this jump.
We get inside.
Okay.
So, I can't get inside the castle.
That's a slight uh mistake there because I've got this on the wrong layer.
So, if I go to my castle here, my guess is that my environment layer right there, yep, includes the door and that needs to be moved to my castle background now.
So, I want to make sure that my castle doesn't collide and I've got this kind of thing filled in with a nice background.
Let's uh do that in the next section, though.
For now, we'll save save save that.
We've added most of the castle and check that in.
Now, we're going to dive into the interaction system that our players will use to teleport around the level.
We're going to create some doors that our players can interact with that you can extend to be any other type of interactable object as well.
And once we've unlocked the door, our player will be able to walk through that door or use and interact with the object to teleport over to the flag here.
So, we'll put a door up here, another door here, and then we'll have a way for the player to go between the two once the door is opened.
So, we're going to start with an empty game object.
We're going to create an empty game object called door.
And I'm just going to zero out the position for now.
We'll reset the position so that it's all at 00.
We're going to add in a closed door child.
So, I'll just drag that down here as a child.
And then underneath that closed door, I'm going to add the closed door top as well.
The closed door top, I'll set to a position of zero and one on the Y so that we get that nice uh full door.
We've got the top and the bottom there.
Let's go reselect those.
And then I'm going to move them up to the position that I want it to be in.
So, this door I want it to be right over here.
This is that exit that's going to get me to the flag.
I also want to have a door over here that I can get in.
So, this will be like the entrance door.
So, I'm going to select my door closed mid, duplicate it with control D, drag it over here with control, and just get it right up into the I think the position that I want, which is probably right about there.
Now, I'm going to add in some open doors.
I've got my closed doors.
I want to have open versions of them as well.
To do that, I'm going to take my open mid and I'll just drag it over here under door again and do the same with the top.
just to the top as a child there.
I'll set the position here to one and zero on the X again.
And then I'm going to move this thing to just be in the same position as this first door.
So, control drag it up.
Nice and easy.
If I'm holding control, then hit Ctrl + D, duplicate, and get an open door over here as well.
So, now I've got an open door and a closed door in both positions.
I'm going to rename these now.
Let's call this um closed one.
And we'll call this one closed two.
And we'll call this open two and open one.
I want to make sure that they're uh they're matching.
Oh, I didn't put the D there.
Let's put opened too.
I want to make sure that these match just on the the naming standard there.
So, opened and closed doors, one and two.
Now, we're going to need to set up a way to toggle between the two doors.
So, we're going to create a new script.
We're going to create a door script.
We'll do that in our scripts folder here.
Right click, create a new C# script.
We'll call this door.
And then we'll attach it to our door before we open it.
So, we'll grab the door, drag it right on.
on.
on.
Let's see.
Let's try that again.
See if it added.
We'll do a save door.
It just didn't recompile, so it didn't find the script.
Saving seems to have forced it to reload any second now.
We should be able to search for and find door or drag it on there.
There we go.
and we'll open that script up.
So, in this script, I said I wanted a way to open and close doors.
So, I'm going to add those first.
I'm going to delete out the start and update.
And we'll add a public void open.
And then, let's add a context menu item to be able to call this.
So, we'll say context menu name of open.
And then in our open method, we're going to turn both of our doors to the open mode.
So, say open one set active true.
And I'll duplicate that.
We'll do open two setactive true.
And then we're going to duplicate these both for the closed versions.
Say closed one and closed two.
And of course, we're going to set the active state of these to false when we open or when we open the door.
Now, I don't have either of these, so I'm going to go create them.
We'll go up to the top and just do game object, open one, duplicate.
We'll do an open two.
And we're going to duplicate again.
do a closed two and a closed one.
I need to make these serializable though.
So, I'll hold alt and drag and add a square brace.
Serialize field.
And now I've got my openable door.
I also probably want to have it closable though.
So, I'm going to take the open section, duplicate it, hit the left arrow and enter.
And let's call this close.
We'll change the context menu to be close as well.
And then down here, we'll just invert these.
So this will be false, false, true, and true.
Now I should be able to save and build and even execute those in edit mode.
So let's go back into the editor.
Should be able to rightclick, go to open mode, go to close mode.
Oh, I have to assign them first though.
So, let's assign closed one, closed two and opened two and opened one.
Then I'll rightclick and we hit open.
They switch to open mode.
Hit close and they switch to close mode.
Now, for my player, since they're not going to be in the editor, I'm just going to use our yellow lock.
So, we'll take that lock and we'll drop it right up here.
They're going to get the key for it in just a moment.
So, take this.
Let's just click and snap drag it.
Uh what? 17.5 and 7.5 it looks like is a good number.
And then for the unlock action, we're going to take our door.
Oh, got to hit plus there.
We'll take our door, drag it into here, and choose door and open.
So when we unlock this with our key, it'll open up the door.
Let's move our key really quick.
So I'll just take that key.
Um actually, you know what I'll do is duplicate it.
Control shift F it real quick.
zero out that position.
Oh, I had another yellow key right there at the beginning, too.
So, I guess it probably wouldn't have mattered either way.
But I'm gonna hit play now.
Oh, after I move my player back over.
And then we'll uh make sure that our key actually opens the door.
So, let's just grab the player.
Let's just move this guy way over here.
Perfect.
Run over.
Grab our key.
Go grab the second key that I don't actually need.
Go up here.
We'll use that.
The door becomes unlocked.
And now I could go through it theoretically.
The next part will be setting up our interaction system so we can actually go through the door now that it's unlocked.
For now though, let's stop playing, go into plastic, and make our commit that we've added the door and door script with lock to open it.
And I want to make sure that my door is in here.
Got a couple extra random jet marines files from Ryder in here.
And that my level file is in there.
We'll check that in.
So, for our doors, the plan is to have our player interact with them by pressing a hotkey.
I want to give them an interact hotkey that they can use to just use any object that's interactable.
To do that, we're going to need a new script for our player, a player interaction controller script or a player interactable script or something similar that's going to handle our interactable objects.
And then we're going to need a new UI element as well to let our player know that they can interact.
So let's start with the UI element.
We're going to go to our robot and underneath our robot, we're going to add in a new canvas.
So I'm going to rightclick, choose UI, and choose canvas.
We're going to change the render mode to world space and the scale to be 01 01 and 01.
Next, we'll reset the position to 0 0 on the X and Y.
It should already be zero on the Z.
and change the height and width to about 100.
Now you should be able to see that object if we drag it up here.
So if I set this up to like a one drag it up, you can kind of see that little canvas object.
So let's make Oh, I made it too small.
It's 10 x 10 instead of 100 by 100.
So make it 100x 100.
And now you can see that block right there.
This is going to be where we're going to put our text.
But that's obviously not quite wide enough.
So I think I'll triple this to about 300.
We'll right click on it now and add in a UI element.
That's going to be a text mesh pro text.
So, oops.
Got to go select text mesh pro text.
And then in here, I'm going to make this fill.
So, I'll hit the anchor, alt, and shift, and click on the fill option.
Then, we'll go down and we'll center it and center it again.
So, it's centered horizontally and vertically.
And then finally, put in some text like interact.
And then maybe give them a key.
Maybe it's E.
I don't remember if I already bound up E, but if not, we could use something like that.
Now, I can't see this on my view very well.
I think it looks kind of terrible.
So, I'm going to change the font.
We'll go over to a um I'm going to go with bangers and like a bright red just to make it really obvious with an outline or maybe a drop shadow.
So, now I've got this text that says interact over my head in bright red.
And I think that that'll probably look okay.
If I hit auto size and make it a little bit bigger, make it fill out that area.
And I I'll use this, I think, as my um interaction canvas.
So, I'm going to rename this to interact canvas.
And then we're going to go to our player and we're going to create that new script.
This player interaction controller.
So, hit add component, type in player interaction controller, and generate my script.
If that's not in the scripts folder, I'll move it over there in a moment.
It's probably going to be in my prefabs folder.
Let's see.
Go click on it.
It went into the root assets folder.
So, I'll click and drag it into scripts.
and then we're going to open it up.
So, our player interaction controller is going to need to do well really two things.
It needs to keep track of when we're inside or what objects we can interact with.
And then it needs to tell those objects to be interacted with.
So, I think the first thing we'll do is just get rid of uh start and update.
I'm not sure if I'm going to need start update.
I'm almost positive we won't need.
And then we're going to add in let's add an awake and cache our text mesh protext first.
So we'll say underscore text or let's call it interact text equals get component in children and we're just going to get our tmp text.
Now we could make a serialized field if we end up with multiple interactable or multiple text objects under the player but since we only have one for now it's easier and less maintenance to just have it cach it in our awake.
Next we're going to have some sort of way to interact.
So let's get our player input as well.
We'll say underscore player input equals get component.
And since this is going to be on our player, we should just be able to get it at that level.
Player input.
We'll generate a field for it.
And oh, we need to add the using statements for it as well.
So that added our Unity using Unity engine.inimpinput system.
And then finally, let's bind up for the interact action.
So we'll say player input.actions and we'll call this the interact one.
and we'll say performed.
That's the event that gets called back.
And we're going to call a method named uh let's call it interact.
So, we'll register for the performed event and call our interact method whenever that happens.
Oh, and I guess we should probably disable our interact text by default, too.
So, we'll say interact textame object set active to false.
We'll just turn that object off.
We'll turn it back on whenever we can interact with something.
All right.
So now we've got a base for being able to interact, but we don't have something to actually interact with.
We're going to need to go back to the door for that.
So in our door, when a player enters our trigger area that we're going to set up, I don't think we've set one up yet.
We're just going to tell our interaction controller that, hey, this thing can now be interacted with.
The player has come in.
So to do that, we'll add an ont trigger enter 2D.
And we'll say, well, first let's get the player.
say var player equals other.get component and we'll try to get the player.
If there's no player, then we'll just bail.
But if we do have a player, then what we want to do is tell our players interaction controller system to add this object.
So instead of getting the player, why don't we just get the player interaction controller.
We'll do that.
We'll do player interaction controller and then we'll say player, which is actually the player interaction controller.
So let's call this player interaction controller.r control R to rename.
and we'll say dot add and we'll just add in this object.
So we're gonna add a method for add which right now takes a door and you probably have a good idea of how to make that more generic for a more generic interactable.
I'm hoping you've got that concept down.
But since we only have one thing right now, we're just going to use doors.
And we'll say underscore doors add door.
We'll generate a field for that.
And that should be a list of door.
Makes sense.
Again, if we go to an interface or something more generic, it would be an a list of that type of thing.
And we'll initialize it to a new list of doors.
There we go.
I guess the the new shortened down would have been just fine.
Just out of habit, went around and uh and made it longer.
All right, so we've got our doors being added.
We also probably need to remove doors if our player leaves the trigger.
So, let's duplicate the trigger.
Enter, left arrow, enter, and change enter to exit.
and then change add to remove.
Generate a field a method again.
And here of course we're just going to say underscore doors remove and we'll remove that door.
So now we've got a door that we're we can go in or add a door.
We can remove a door.
And then finally we just need to be able to interact with doors.
So in our interact method we'll do a for each var door in underscore doors.
And really there should only be one door ever active.
But if we extend this to be more generic with more interactables, then you could theoretically have more than one interactable object in the area.
And we'll just say door dot and then how do we want to do this? Probably call like a interact.
And we'll pass in our object that's interacting with it because remember more than one player could be in the game.
So we need to make sure that our interactable object knows what thing is interacting with it.
We'll generate a method for our interact.
And then this is just going to well teleport the player from one door to the other, I think.
So, we'll just need to know which door we're at and then teleport to the other one.
Now, I think this is a a perfect place for a quick little challenge.
So, if you've got some ideas of how you want to accomplish that, go ahead and give them a try now.
Experiment a little bit and see what you can come up with.
The solution should be relatively simple, though.
when we're interacting with the door, we're going from one door to another.
We just need to figure out which door we're going to.
So, go ahead and track that down and then I'll show you my solution or go ahead and experiment and figure it out and I'll show you mine.
All right, let's go through my solution.
So, what I want to do is pick a destination based on whichever door is furthest away.
Whichever door is the furthest away one is the one that we want to teleport to cuz we're obviously closer to the other one.
So, we'll say var destination equals and here we're just going to look at the distance.
So we'll say vector 2.d distance and we're going to go from our player interaction controllers transform.position to the opened transform position open one transform position.
So we're going to say if this distance is greater than and let's just zoom that out a tiny bit and then we'll duplicate or copy this line and we're going to check if it's greater than the distance to number two.
Then we'll do a question mark.
destination is going to be open two no open one.transform.position position.
Otherwise, we do the colon.
It's going to be open one or open two.t transformed.
I said my words backwards, but hopefully you get the idea.
So, if this one is further away, if number one is further away, then we'll use number one as our destination.
If number two is further away, we'll use number two as our destination.
And that's just because the one that's closest to us is the one that we're already on.
So, we need to go to the one that's far away, not the one that we're already on.
And then finally, we'll just tell our player to move there.
So, we'll say player interaction controller.transform transform.position equals destination.
Now, let's get back into Unity and finish our interaction setup.
So, the first thing I want to do is let's move our player over here to like a 15.
I want him to kind of drop just by that door so that he's nice and easy to get to.
And then I want to add in our player input action.
We need an interact action.
So, let's go find the jump action.
Duplicate it with control D and rename it to interact.
All the hotkeys work here, by the way.
F2R D and all that.
And then I'm going to set the hotkey here to E because that's a pretty common hotkey for interaction.
We'll delete out the PlayStation control and save that change.
Next, we need to add in some colliders to our doors so that our triggers can actually fire off.
So, I've got open one and open two.
We'll hit add component and add a box collider 2D with the is trigger option set.
I'm going to save.
And right now, if I hit play, I don't expect Well, actually, let's go back into our interaction script real quick and just make sure that when we enter a trigger, um, let's do it right here after we add oursel.
Let's also turn on our text because I realize I don't think I've done that yet in our player.
So, when we add in a controller, let's go into add.
We'll say underscore interact set act or game object set active to true.
And then when we remove a door, we're just going to check if there are no doors.
So, we'll say if doors.count is equal to zero, then we're going to set it to false.
So, we'll turn that interact text off.
All right.
Now, let's save and play and watch and see if the interact text comes on.
I've got my doors in the open state right now.
So, I'm going to drop right into it without having to get the key and see if I can interact with them and teleport or not.
We're going to expect to see a big fat no.
But, let's watch and see if that's the case.
So, I drop in.
Oh, I actually can.
Okay, perfect.
That works perfect.
Oh, that's because I cheated and I already pre-added my composite collider.
Let's stop and remove that, though.
So, if I don't have my composite collider and my rigid body on the door that I accidentally pre-added and I press play, you'll see that I drop down and no trigger fires off.
And that's because the triggers or the colliders are on the child objects and the script is at this parent object.
So the cheat that I had used and let's pause and read it is to add a composite collider which automatically adds a rigid body and if I don't change this to static the rigid body will fall down and then press play and now what happens is it creates a single collider that consists of those two colliders.
So it's a builtup collider of the two.
So now I can use the script at that parent level and then uh have the colliders be children.
So let's jump up there and actually try using it.
So, jump up, jump up, come over here and hit E.
And you can see I can teleport over and now switch out to the the next level.
So, let's stop playing and just double check that I've got that composite collider readded to my door.
I don't.
So, I'm going to read it and set that back to static and save.
And then we're going to go check in our changes.
So, we'll go in here.
So, we've added the working interactable door and check it in.
In this lesson, we're going to add another enemy.
We're going to add the fish, and we're going to have him swimming through the lava and shooting spikes out at our player.
And we're also going to implement the splines library so that we can move our character along a nice smooth path and have them kind of swimming and jumping in and out of that lava.
If you've never seen splines before, they look essentially like a curved line.
You've got a line with points on it and curved data.
And they originate from back when people used to build ships, I guess, by putting these together.
I assume it's all digital now, but back in the day, they used to manually build these out to figure out their curves and put things together.
Nowadays, we just slap them into video games.
Now, in this lesson, we're not going to get too deep into the mathematics behind splines.
I've watched Freya's video on how splines work and all of the details there and I get lost constantly about 20 minutes in.
So, if you really want to dig into the details of everything mathematical behind the splines, I'd recommend go checking that out and check out a couple other resources on YouTube.
But if you want to just see how to use them right away in your game, well, that's what we're going to get into.
Before we add the fish or anything, we're going to start by bringing in the splines package.
We'll go to window package manager and then under Unity registry we should be able to scroll down until we find the splines package.
I'm going to install that.
And once it's done, we can click on the documentation right here to bring up all of the docs about splines.
I'm not going to go over these documents though.
We're just going to go right into Unity and use it.
But if you want to look into more info, you want to see the actual page, just remember that it's always there on just about every package manager page.
You can click on documentation and get more details.
With the package imported, we should be able to create a new spline under game object spline and then choose one of these existing spline types or just hit the draw splines tool.
If I hit draw splines, though, I'm going to get a spline that's located at 0 0.
I can double click on it to go to it.
and also has no points or no knots in it.
So, I'm going to need to add a couple knots.
I'll hit the plus button here.
Let's just hit it twice.
And then in spline edit mode, so I click on this little button right here to go to spline edit mode.
I can now grab and drag these points around.
Let's see.
I think I had one just a second ago.
Let's go grab it again.
There we go.
Now, I can move my point around for this knot.
And I can click on this other point and drag it around as well.
If I click on this little indicator here though, I'll go out of spline edit mode and then I can't select those.
Then instead, I'd be just selecting and moving my entire spline object if I could even click on it.
All right, let's move the spline now.
I'm going to take my spline and I'm going to move the base of it all the way over here.
Notice that those little points here, my two knots that are children of it, move along with it.
I'm going to move this right over to I think maybe like the start point of where I want my fish to swim.
I want my fish to swim up and over and kind of do a loop and maybe jump around like this and shoot off some spikes.
So, I'm thinking right about this point is good.
That means that my first knot I also want to be right at this origin point.
So, I'm going to set the value here on not zero of X and Y to be zero and make sure that Z is also zero.
Not one is at six and 2.8 an 8 and a three, which also means that if I click on 3D space, this knot is way over here off to the side, and we're working on a 2D game.
So, I want to change that.
I want to keep this flat.
I'm going to set this Z to three.
There we go.
And now I've got this nice curved line.
Let's see if I can get into a 2D view where it's trying to go up.
It's still going back a little bit though because of our orientation.
If we rotate the Y value by 90 degrees here and it's going to straighten that right out.
You see it's no longer sticking out.
We'll do the same on knot one as well.
And then just have that continue for our pre our next knots as we keep adding them.
So let's add another one.
I'm going to hit the plus button.
We'll go into move mode.
And I'm going to go into nice 2D view here.
Hit W and see if I can grab that knot and drag it back down.
So, I'm thinking I want this one back down here, but I also want this one up here kind of above the the water.
So, it kind of jumps up and then dips back down.
I want more knots.
So, I'm just going to keep hitting that plus button.
Add another one where I want him to go back up again.
Thinking right about there.
And then a plus again.
We'll drop him back down.
And a plus.
Get him up.
One more to go down.
We're almost to the end.
And then we'll do one more going up here.
And then at the end of it, I want him to kind of turn around.
So I'm going to drop him down a little bit sharper.
Then we'll add another point over here so he kind of swims back this way a bit.
And then have him kind of reverse that loop so that he goes up across those points.
So, we'll hit plus.
Go up to here.
Or, you know, maybe I'll Yeah, go right up to here.
We need to turn the rotation around, though.
So, we'll go to negative 90.
And we're going to start doing a negative 90 on the next one.
Let's see.
90.
And keep adding adding our points.
Think I may have There we go.
There's my point.
Almost lost it.
You can see I'm doing this crisscrossed wave here.
Now, we don't have to necessarily do a wave.
One of the benefits of this curve, I could skip this middle part completely.
It's not programmatic.
So, I'm not forced to have a point every set value or set space.
Hit plus one more time.
We'll get this down.
And then I think that's probably good.
We'll go up to the top and choose the closed option, which will turn this into a loop.
Now, it's going to do a little bit of weird rotation when he comes down here, but that's okay.
He's going to be off screen and not visible.
So, here's our spline.
We've got this nice long line and we're going to have to move our fish along there.
So before we do that, let's save everything off and let's do a quick commit that we've added the splines package and our first spline into level three.
And we'll check that in.
Now that we have our spline for our fish to follow, we're going to add our fish, make him animate, and make him follow that spline, which is going to be drastically easier than you might expect.
Let's take our fish and drag him into the scene first.
I'm going to move him over here to the right.
Let's see.
Just grab him and drag him so he's somewhere near the lava.
And let's go into a nice 2D mode.
There I can see my fish.
And I want my fish to follow along this spline.
Now to follow a spline, we usually call the evaluate method on it.
And then that'll give us a point that's between zero or and one or 0% and 100% along the spline.
We'd get a point here would be 0%.
And then here was probably like I don't know 5% or 05 right around there.
And then we loop around.
You get to like 98, 99, and 100 when we got back to the end of the loop or a one.
We don't have to do that though because moving along a spline is such a common thing that it's already built into the splines package.
So on our fish, we're going to add the spline animate method.
This takes a spline reference.
We'll just drag our spline over here, our fish path spline, and then we can press play.
We don't actually have to press play though because they've added a preview mode here.
So I can actually hit the play button right here and watch my fish completely disappear.
I can see a little bit of flickering going on, but the fish is not staying around.
Well, he kind of is.
He's just not really visible.
What's actually happening here? Well, first, our duration is way too fast.
We've got it one second for it to loop across the entire thing.
And you can kind of maybe loosely see that outline there.
If I turn this up to about a oh, let's go with like 15.
We can see that it's moving along.
And there we can see an outline of something, but it's not our fish.
And the reason for that is that our forward axis of our fish is incorrect.
If I go into 3D mode and go take a look at our fish, you can see that he is facing off to the side here.
But there's an option right here for forward axis.
I can change this from object Z plus to X plus.
There we go.
And now my fish is swimming in the correct direction.
Let's go into 2D view.
And when he turns around, he should also be swimming in the correct direction.
You see, he does that weird flip upside down under the water or under the lava.
It doesn't matter because he's not visible.
Um, there we go.
And then he flips back and looks good.
And he's going the correct direction.
So now I've got something that will move him along.
Again, this is running without me even pressing play.
I can pause, slide along.
It's a nice little editor.
And we're going to add our own editor that's somewhat similar to this for attacks in just a moment.
But for now, we've got a fish that moves around.
Let's make him animate.
We're going to go into our animation folder.
Go to fish and rightclick.
Create a new animator controller.
We don't want to use that override one that was in there.
We'll call this fish.
We'll open up that animator controller and I'm going to just move in my move fish animation right now, which is just the one that causes his tail to wag back and forth so it looks like he's swimming.
We'll go back into our scene view, go find our fish child object, the base one with the animator, and drag in our capital fish animator controller, not the override controller with the lowercase f.
Now, if I save and press play, I expect that my fish will start animating.
Let's check them out.
We'll go into the scene view real quick.
There we go.
We can see our fish animating and swimming around.
And the last thing I want to do with this fish right now is make it so that he actually shows up behind the lava when he's behind it and only shows up kind of when he jumps out of that lava.
It's kind of like his his fish water.
To do that, we're just going to need to add some new sprite layers.
So, we'll stop playing one more time.
Go back to our fish here.
Go select his child objects.
And we're going to need a new sorting layer.
that's behind whatever this is on.
And right now, I believe our lava is on the default.
So, I'm just going to add a new layer and call this um inwater fish or let's let's call it fish.
Actually, I'm just going to call it fish because that's what I'm going to put on there.
And I'm going to move that above the default but below the background.
So, it show behind everything except for the background there.
Now, we're going to open up that fish prefab here.
Go select all of the child objects by expanding this out and searching for sprite renderer.
I put a t equals at the beginning to make sure that it shows up.
That changes in every version.
It seems used to be a colon.
Now it's an equals.
It used to not require anything.
But now that I've got them all there, I'll select all with control a.
And we'll change this sorting layer from default to fish.
Press the back button.
Save.
And now we should have a fish that appears to jump out of the water.
Let's play one more time and check it out in scene view.
Go back over here to scene view.
My fish goes around.
It seems like he's kind of doing a little jump out of the water.
Perfect time for him to do an attack.
Turns around, swims back, does a jump, skips that middle part, does another jump, turns around, and shows back up.
All right, that is looking good.
Let's go into plastic and say that our fish now moves along the spline and animates if you haven't already seen it.
Our fish has a pretty cool attack animation and that's what we're going to hook up now.
You can see he does this roll and he's supposed to shoot off a bunch of spikes.
Those are the spikes on top of his head.
So, let's hook it up.
We're going to go to the fish's animator and we're going to drag out the attack roll fish animation onto the animator.
We need to add a parameter that'll be a trigger for when it should attack.
And we'll just call this attack.
And then we'll make an attack animation transition.
So we'll do make transition, go to attack roll, and do a make a transition back.
But on the transition from move to attack, we'll just add in the attack condition there.
So we have that condition of that trigger to go into attack.
And then we have has exit time on.
So it'll go back out as soon as the animation completes.
All right, that'll work.
But we need something to actually fire this off.
And we don't want to necessarily fire this off on some sort of a timer or something else.
We want it to fire off when it gets to specific points.
I mean, a timer could theoretically work, but seems a little bit complicated when really we want to be able to set the point somewhere along our spline where our fish will attack.
And that's what we're going to do.
We're going to add some fish attack points or just some attack points to our spline.
And you could think of these as any additional data that you could add.
You could always refactor this and change it to do whatever it is that you want at the different points in time.
Let's select the spline and create a new script.
We're going to call this spline attack points.
Generate a script for that and we'll open it up in our code editor.
In our spline attack points, we're going to need a reference to our spline container.
So we'll add a serialized field of type spline container and this is just going to be named underscore spline container.
Now we don't use a spline here because the spline will get serialized.
And if we actually go back to our spline object here, you'll see that this is actually a container that contains multiple splines.
It has the name spline here.
So it gets a little bit confusing.
You might grab the wrong type.
Just remember if you want to reference the scene object here or the component, use the spline container.
Now I can drag my spline container over and you see that that reference appears just fine.
I'm going to go back into code and what we want to do next is add in a list of points or points where our player will attack.
I'm going to add or not our player but our fish.
We'll add a serialized field.
It's going to be a list of floats which will be the percentages along the way.
And I'll call this attack points.
Now, I'm going to get rid of our start and update methods because we don't need these here.
And we'll add an ondraw gizmos instead.
And now we're going to loop through all of our attack points.
And for each attack point, we'll just draw a gizmo on our spline at the point where we want to attack.
That way we can see exactly visually right in the editor where our attacks are going to happen.
So, we're going to do a loop, do a for each loop of all of our spline, no not our spline container, our attack points.
There we go.
And we'll call these uh let's just call them point for each point in attack points.
For each one of them, we'll get the position along our spline.
And we'll do that using uh let's say vector 3 position equals and we need to use our spline container.
And we're going to use the evaluate position.
Let's see if I can get that right.
evaluate position method.
We'll give it our point value.
This will give us a position along the spline at whatever percent we've given it for this point here.
Now we've got our position.
We're going to do a gizmo.
So let's do gizmos.draw color or draw let's say not draw color equals.
And we'll do color red.
Make sure it's nice and visible.
And then I'll do a sphere like gizmos.draw sphere.
and we're going to draw it right at our position and give it a value a size of maybe like 0.2.
So this should give us all of our spline positions that we've added or our attack points visible on the on the object as gizmos or in our scene view as gizmos.
Let's go try it out.
By default, we should have none.
If I expand out attack points and hit plus, I get a point right here at the beginning.
If I hit plus again, I have a second point at the beginning.
But let's say I drag this value out.
You can see that little red dot is moving along.
And if I wanted my first one to be right around here, it looks like 0.1 is too high.
Probably go with a about a 07.
There we go.
Then I can duplicate that.
Add in another point and move it over here to wherever the next position I want to attack is.
It's probably going to be like a point five.
No, two.
There we go.
And so on.
I can keep adding these in.
Now, we could make some slightly better custom editors that allow us to slide and drag this, but realistically, most of the time, it's probably not worth it unless we end up with a bunch of designers building these or we need a lot of control over them.
We need to constantly change them.
But, as you can see here, with just uh a little bit of value typing, and I'm very quickly able to fill in all of these data points, and we can change these very easily, too.
We don't have to do very much work at all to modify this.
So, let's go with like a 61, a 62.
I want them all to kind of fire off right before we get to the peak.
So, I think we've got one more attack point here to add in, which is going to be the one where it comes up and then loops all the way over there.
So, what's that going to be like a 85 or 86.
There we go.
And now I've got all of my spline attack points ready to go.
Next, we'll set something up on our fish to actually use these.
But for now, we've got our gizmos set up and our spline attack point script working.
I think I want to check this in.
So, go into plastic, say we added spline attack points, and check that in.
Now, we're going to create a new script, a fish script that will tie all of our existing code together and make our fish work properly along the spline and shoot at our enemies.
We're going to start by taking the spline attack point script and I'm going to move this in my scripts folder.
It got generated into the root.
Then I'm going to go into the scripts folder.
Rightclick and we'll create a new C script and we'll call that fish with a capital F.
We're going to open that script up and we're going to add a couple references.
First, we're going to need a reference to our spline animator.
Let's get rid of this start method completely.
We'll add a serialize field that references our spline animator or spline animate.
And then we need a reference to our animator because we're going to want to turn that attack animation on and off with that trigger or really just turn it on with the trigger.
So we'll get a reference to our animator.
And then we're also going to need a reference to the attack data.
So we're going to need that spline attack.
There we go.
Attack points.
Now, to keep track of where we're going to attack next, we're going to use two different variables.
We'll create a float that has our next attack point.
So, let's do that now.
float next attack point.
This will be the time along our spline where we'll attack.
So, it'll probably be at I think right now we have one at zero that we'll probably remove.
But then we'll have our 2 and then 3 or whatever it was for our next attack and so on.
That's going to store that value right there.
So, we can do some very quick easy comparison.
We're also going to keep track of all of our next attack points or all of our available attack points.
And we're going to do that in a Q this time.
So we'll use a Q queue EU of type float.
And we'll call this attack points.
This will be all of our available attack points that we have.
And we're going to fill this by grabbing it from our spline attack points.
Let's do that in the start method.
We'll add a start.
I just deleted it, but we'll add a new start.
And inside that start, we'll add a method called refresh attack points.
This is going to give us a new queue, a new set of all of our attack points available that we can start just pulling objects out of.
We can start pulling them out one one after another.
We could use um a list or an array or an index as well.
I just felt like using a Q this time.
So, we're going to put them into a Q and then just pull from there.
So in our refresh attack points, we'll say underscore attack points equals and we'll give it a new Q.
And we're just going to pass in our or actually let's get this directly from let's get this from the spline attack points.
So we'll say attack points equals spline attack points.get as Q and then we'll generate a method to get that back as a Q.
So select the get as Q, hit alt enter, generate a method, and then here we'll return a new Q and pass in our attack points.
What this will do is give us a new set of all of our attack points in just a collection that we can pop and pull things from until it's empty.
Again, we could use integers and an array based thing, but I want to show one other slightly less memory optimized way to do things as well.
So, we've got our attack points here, and the first thing that we're going to need to do is grab the first attack point out of there, and make that be our next attack point.
So, we'll say underscore next attack point equals attack points.
DQ.
That's going to pull the first one right out of that list.
Now that we've got our next attack point, we can just check in our update to see if we've passed that attack point.
If we have, we can fire off an attack and grab the next point.
If we haven't, then we don't really have to do anything.
So to do that, we're going to need to figure out how far along the spline we are.
So we'll say var elapsed equals, and we want to get this data from our animator or our spline animate script.
So we'll say spline animate, and there's a normalized time on here.
This will give us a value of how long it's gone all the way across.
So it'll be zero at the beginning, one at the end, but on the second loop through, it's going to be two, and on the third loop through, it's going to be three, and so on.
So if we want to go halfway through the second loop, that would be at 1.5.
And we really want a value of 0.5.
We're not storing all of the every loop value in our attack points.
We're just storing the 0ero to one value.
So to do that, we'll use the modulus statement or the percent and a one.
That's going to get rid of everything before the decimal point and just give us back the decimal for how much is elapsed.
Then we'll say if elapsed is greater than or equal to our next attack point, well then we want to do an attack.
So we'll tell our animator to set its attack trigger.
So say set trigger.
And remember we named that attack.
And then we want our next attack point to be set.
But we only can set that if we actually have attack points available.
So we'll say if_attack points.
Make sure that we add the using system.link statement up there.
automatically added for me here.
So if we have attack points, then we'll say next attack point equals attack points.d dq.
And if we don't have any, so we'll say else, well then we should probably refresh our attack points and just get some new attack points.
Let's get rid of those braces.
Save and do a build.
And now we should expect to see our fish playing his animation.
Let's go check it out.
Of course, first we'll need to add the fish script and then assign our references like the spline animate, our animator child, and the spline attack points that we're going to be following.
We'll save and press play.
And here we go.
We can see our fish swimming along.
Let's watch him animate.
See, he does his animations, but there's a little bit of a delay there, too.
One thing we want to make sure that we don't have is the has exit time checked for this animation transition.
We want to make sure that he does the transition immediately.
It doesn't keep getting reset back out of it.
Now, the final thing to do is make our fish actually shoot.
We can see here that he's got an animation event that's firing off and nothing listening to it.
If we go look at our animation, let's go find that attack roll fish animation real quick.
Go to our animation window, select the fish, and go to attack roll.
Let's move this animator controller out of the way.
You can see that we've got an animation event right here, which is, I believe, right at the point where he's Let's stop playing.
Right at the point where he's doing the actual attack, where he does that kind of a spin move where he should actually be firing it off.
So, it's right there.
So, let's hook this up to an attack.
And remember, we have that shoot animation wrapper.
So, we'll go to our base object here, add the shoot animation wrapper, and then we can select our animation and just go find shoot animation wrapper methods shoot to call that shoot, and then pass it up to our fish object.
We'll go up to our fish now.
And then in our start method, we can just register for that just like we did with the other ones.
Say get component and children shoot animation wrapper.onshoot plus equals shoot spikes.
And then we'll generate a method for it.
And here we'll say debug.log shoot spikes.
Let's save that off.
See if our log entry comes.
And then in the next section, we'll add our spikes and finish up our fish.
First, we want to make sure that he's actually trying to fire off and the animation is all working properly and everything's hooked up.
Let's go check it out one more time.
There's our fish reloading as domain.
Go back into the scene view.
We see our fish doing a spin and he's calling shoot spikes.
Looking good.
Let's stop playing.
Go into plastic and commit.
Fish is ready to shoot spikes.
And I'll check that in and save our scene.
Okay, let's try checking that in one more time.
There we go.
To let our fish shoot, we're going to need to give him a weapon first.
So, let's go find the spike that came with him, the bullet spike object, and just drag it right out into the scene.
We're going to set this one up to be his projectile.
We'll add a rigid body 2D first so that it can go flying around.
We'll leave all the settings on default for now.
And then we're going to add in another component that's going to be a collider.
So, we're going to need to find a collider 2D, but we want a polygon collider that'll allow us to make a collider that kind of matches up with our actual sprite.
Here, I'm going to modify this by going into edit mode.
If I expand out the polygon collider, I can hit the edit mode.
And you can see the green lines appear nice and bright and click on the points and drag them right to where I want.
I want one point there, one about there, one about there.
I'm going to pull this one in just a little bit.
And then I'm going to delete out those extra two points that I've got down here, the two at the bottom.
So, I'll go select element three, hit delete, and select element three again.
Hit delete one more time.
Ah, looks like my elements got rearranged.
That's okay, though.
I'm just going to drag this point right back over there.
I've got a nice little triangle that should work well for my collider on this spike.
I don't want it to go over the edge.
It's just kind of staying right inside.
I'm going to make sure that that's saved off.
So, we'll go to our bullet spike prefab.
Scroll up to the top.
Go to overrides and hit apply all.
And now we need to add this into our pool manager.
If we go to our game manager and pool manager, remember we've got a pool for our blaster shots, our explosions, and our cat bombs.
Let's expand out the code a little bit more to also handle things like well our spikes.
To do that, we're just going to take our catbomb pool right here and duplicate it.
We'll call this a spike pool.
So, we're going to create a class called Well, maybe we don't even need a spike yet.
Let's just start with a return to pool and we'll call this underscore spike pool.
Now that we've got that, we should be able to copy all of the other places that are using catbomb pool.
So, we'll just find them all.
We hit Crl + F and hit enter to go to the next spot here.
Looks like line 37 where we initialize it.
We'll duplicate all of those lines.
So I'll select them all.
Ctrl D.
Left arrow.
Enter.
Enter.
And then we'll paste.
So we've got our spike pool is going to be an Iobject pool.
That was our type.
Oh no, it's an object pool, not an object pool of return to pool.
Oh, here I've got my type in the wrong spot.
There we go.
That's what we're looking for.
an object pool of type return to pool.
Now, we don't want to return or instantiate a catbomb prefab.
We want a spike prefab.
And then we're going to want to add in the spike pool as its pool.
We'll have it return back out the shot, which seems right.
We just need to generate the spike prefab as a return to pool object now.
So, let's generate the field for it.
Make sure that it's right up here by our other prefabs.
So, I'll move that up.
Control shift alt and move my lines right up here.
And we'll call this a return to pool.
Not spike pool, return to pool.
So now we've got our spike prefab right below our cat bomb prefab.
We've got our spike pool right below our cat bomb pool.
And we've got the instantiation of our spike pool right below the instantiation of our cat bomb pool.
The next thing we need is just a method to get a spike.
So we'll add a public spike or return to pool because we haven't given this a class yet.
call it get spike and we'll return back out the spike poolool.getit.
That's all we need.
We'll generate our code or do a quick build, not generate our code with control shiftb.
And then we're going to need to go into the editor and actually assign our spike.
So, first thing we'll need to do is go to our bullet spike here, and we're going to need to add a return to pool script.
And then we're going to need to assign that.
So, we we'll make this into an a prefab.
We'll apply our prefab changes.
Get my words there.
Hit select to go find that prefab.
Then we'll go find our pool manager and add in the bullet spike right there.
And then apply our pool manager prefab as well.
So that applies across all of them.
Now we've got a bullet spike that we should be able to spawn and instantiate in our attack method.
Let's go back to our shoot spikes method now and instead of doing a log, let's instantiate a bullet or a spike.
We'll say var spike equals pool manager.instance.getspike.
And then we'll just set that spike's position to our current position for now.
So we'll say spike set position or spike.t transform set position and rotation.
We'll set it to our position and um let's just use a default rotation right now.
So we'll I think our our just use quatronian identity.
We're gonna set rotations in a moment so that we can do a bit of a spread.
But this should give us a spike, just a single one facing up.
Let's go try it out.
All right, here we are with our fish ready to shoot.
But I think I want to delete out this first attack point before we do.
So, let's go find on my spline attack points.
I've got this one at element zero.
And I think if I go in here, can I delete this element array? Let's see.
Ah, there we go.
Right clicking deletes it.
And now I've got got rid of that.
I should be able to press play.
Oh, do a little cough.
And let's see if our spikes start spawning at the attack points.
There we go.
You can see spins, does a little spawn of a spike, does a spawn, does a spawn.
So, I think I might want to move those attacks forward just a little bit because the attack animation is so slow, too.
But that's looking good.
The last step will just be to launch those things up.
Now, let's modify our shoot code to launch out multiple spikes.
We're going to add a loop.
We'll do a for loop and we'll go from one to let's call this underscore spike count.
I'll generate a field for that and I think I'm going to default it to a value of five.
So we'll get one spike up and then two off each direction off to the side.
Now we're going to inside of that loop do our spawning and setting position.
So I'm just going to move those up into the loop.
Let's cut and paste.
But the position or the orientation is going to vary based on which spike it is.
If it's the one, the first one, I want to go kind of like off to the left and then a little bit more straight and then straight up and down and then to the right and then more to the right.
So, we're going to need to get that angle.
We'll say var angle equals and here let's get we'll use I minus and we want to use half of our spike count.
So, spike count divided by two.
So, we'll start off with a a negative number and then we'll go up to a positive number that's halfway the bottom of spike count and then halfway above or halfway to spike count.
So, we'll get a negative 2, a negative 1, a zero, a one, and then a two.
Those are the values that we should expect to see.
Next, we want to use that and multiply it by some um spread offset.
So, we'll say var um offset equals spread time angle.
We'll generate a variable for that spread.
Let's call this underscore spread.
And we'll make that a serialized field.
I'm going to set this to oh 15.
And we could use floats here, but I'm just using ins to keep things somewhat steady on my um my angles and and values there.
It could be a float, though.
There's no reason for it to necessarily be an int here.
So, we've got our offset now.
Um, and then we need to give that some like base origin.
So, zero would be off to the right.
And we're probably going to want to go, you know, off to the or start at like a 90 or a 90.
So, we'll say var final angle equals or underscore origin, which we'll make a variable plus offset.
We'll generate a field for that origin as well.
And we'll just leave that at zero for now.
We'll be able to adjust that inside the inspector.
Now that I've got my final angle, we'll use quatronian oiler.
We'll give it a zero for the x, a zero for the y, and then pass in our final angle on that Z so that we're rotated the right way.
And then we want to oh, need to add that closing parenthesis there.
And we also want to give some force to our spike.
So we're going to say spike.get component.
And we'll get the rigid body 2D.
And we're going to set its velocity equal to its right direction.
So sprite spike.t transansform.right times some fire speed.
So let's call this a fire speed.
And this be how fast it's going to actually launch it.
We'll generate a serialized field for that as well.
And I'm going to set this to like a five.
Might be a little bit too high, but we can just adjust it right in there.
All right, I think that we're done.
We just need to go back into Unity real quick.
Make sure that our fish spike is set up right and uh not set to a 0.5 on the cleanup.
Let's go find that real quick.
Bullet spike and our delay right here.
Make sure this return to pool is cranked up a little bit higher than 0.5.
We don't want it to just disappear instantly.
That's how we had it for our explosions and stuff.
And oh, we also want to make sure that uh gravity scale is off.
And I'm even going to freeze rotation on this so that our rigid bodies here don't start spinning around.
we don't get some weird spikes.
It should either disappear when it hits something or kill something or go through things.
And before I press play, the last change I want to make is I'm going to turn this origin to 90 so that my spikes shoot up and don't start just spawning inside of the lava or shooting down into the lava.
So, let's see.
I'll press play.
Go back over to that scene view.
We should expect to see there we go.
Our spikes are firing up.
They are hitting the platform, but that's just because we haven't set them to a layer where they can't.
and they should be able to go up and now almost kill the player.
Let's finish that off so that they can kill the player.
We'll go back to our bullet spikes.
I'm going to adjust this by adding a script that kills player.
So, we'll put the damage player script right on there so that it'll hurt our player when it hits them.
And then we're going to change the layer of this.
So, I'm going to go to layers.
We'll add a new layer.
I'm going to call this spikes.
This would be my spike layer for all of the spike related things.
probably be like an enemy projectile layers would be like a better more generic name for it.
But if change that over to spikes, we'll apply the override here and then we'll go into our settings again.
Remember it's under project settings and then we got to go find our physics 2D and then there's the layer collision matrix.
We'll make sure that spikes only collide with players, not even with other spikes.
There we go.
Save our project off.
And now only our player should be hit by the spikes.
And we'll just go verify that that's the case.
So we should see our spikes go flying through.
Shooting the uh shooting right through.
Looking good.
And if I get my player over there.
Let's just just just see if I can make it.
Oh, almost made that jump.
Oh, let's go bounce in on some frogs.
See if we can get all the way over to the spikes and then let the spikes do some damage.
Ah, if that cat doesn't kill me first.
All right, I got a spike that's still sitting there on the ground.
Oh no.
Okay, let's just move our player over there and and just go verify it one more time.
Benefit of having editor access, we just go bam, drag our player right over here, press control P, and we should be able to see the spikes actually working and hitting our player.
Bam.
Okay, there we go.
Spikes hit me.
Took some damage.
And it's a bit of a challenge.
I do think the last thing I want to do to make this a little bit more manageable though for my actual player is just crank up the uh the follow size just a little bit.
So in our multiplayer camera setup, we've got our target group and I'm just going to crank up the radius here to let's maybe make it about five and unpause.
There we go.
Now I can see the world below me.
Ah, it's interesting watching the the ground move, but the spikes staying in the same place.
It makes it seem like the spikes are doing something weird, but it's really just the ground.
Ah, moving along.
All right, that's looking good.
I'm going to go into plastic and commit spikes damage player and launch at variable directions.